<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sandbox.System</name>
    </assembly>
    <members>
        <member name="M:Sandbox.Diagnostics.Assert.NotNull``1(``0,System.String)">
            <summary>
            Throws an exception when the given object is null.
            </summary>
            <typeparam name="T">Any type capable of being null.</typeparam>
            <param name="obj">Object to test</param>
            <param name="message">Message to show when object is null</param>
            <exception cref="T:System.Exception">Thrown when the given object is null.</exception>
        </member>
        <member name="M:Sandbox.Diagnostics.Assert.NotNull``1(``0)">
            <summary>
            Throws an exception when the given object is null.
            </summary>
            <typeparam name="T">Any type capable of being null.</typeparam>
            <param name="obj">Object to test</param>
            <exception cref="T:System.Exception">Thrown when the given object is null.</exception>
        </member>
        <member name="M:Sandbox.Diagnostics.Assert.IsNull``1(``0,System.String)">
            <summary>
            Throws an exception when the given object is not null.
            </summary>
            <typeparam name="T">Any type capable of being null.</typeparam>
            <param name="obj">Object to test</param>
            <param name="message">Message to show when null</param>
            <exception cref="T:System.Exception">Thrown when the given object is null.</exception>
        </member>
        <member name="M:Sandbox.Diagnostics.Assert.IsNull``1(``0)">
            <summary>
            Throws an exception when the given object is not null.
            </summary>
            <typeparam name="T">Any type capable of being null.</typeparam>
            <param name="obj">Object to test</param>
            <exception cref="T:System.Exception">Thrown when the given object is null.</exception>
        </member>
        <member name="M:Sandbox.Diagnostics.Assert.IsValid(Sandbox.IValid)">
            <summary>
            Throws an exception when the given object is not valid.
            </summary>
        </member>
        <member name="M:Sandbox.Diagnostics.Assert.AreEqual``1(``0,``0,System.String)">
            <summary>
            Throws an exception when the 2 given objects are not equal to each other.
            </summary>
            <typeparam name="T">Any type that supports <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.</typeparam>
            <param name="a">Object A to test.</param>
            <param name="b">Object B to test.</param>
            <param name="message">Message to include in the exception, if any.</param>
            <exception cref="T:System.Exception">Thrown when 2 given objects are not equal</exception>
        </member>
        <member name="M:Sandbox.Diagnostics.Assert.AreNotEqual``1(``0,``0,System.String)">
            <summary>
            Throws an exception when the 2 given objects are equal to each other.
            </summary>
        </member>
        <member name="M:Sandbox.Diagnostics.Assert.True(System.Boolean,System.String)">
            <summary>
            Throws an exception when given expression does not resolve to <b>true</b>.
            </summary>
            <param name="isValid">The expression to test</param>
            <param name="message">Message to include in the exception, if any.</param>
            <exception cref="T:System.Exception">Thrown when given expression is not <b>true</b>.</exception>
        </member>
        <member name="M:Sandbox.Diagnostics.Assert.False(System.Boolean,System.String)">
            <summary>
            Throws an exception when given expression does not resolve to <b>false</b>.
            </summary>
            <param name="isValid">The expression to test</param>
            <param name="message">Message to include in the exception, if any.</param>
            <exception cref="T:System.Exception">Thrown when given expression is not <b>false</b>.</exception>
        </member>
        <member name="P:Sandbox.Diagnostics.Logger.Name">
            <summary>
            Name of this logger.
            </summary>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Info(System.FormattableString)">
            <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Info(System.Object)"/>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Trace(System.FormattableString)">
            <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Trace(System.Object)"/>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Warning(System.FormattableString)">
            <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Warning(System.Object)"/>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Error(System.FormattableString)">
            <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Error(System.Object)"/>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Error(System.Exception,System.FormattableString)">
            <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Error(System.Exception,System.Object)"/>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Error(System.Exception,System.Object)">
            <summary>
            Log an exception as an error, with given message override.
            </summary>
            <param name="exception">The exception to log.</param>
            <param name="message">The text to override exceptions' message with in the log.</param>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Error(System.Exception)">
            <summary>
            Log an exception as an error.
            </summary>
            <param name="exception">The exception to log.</param>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Warning(System.Exception,System.FormattableString)">
            <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Warning(System.Exception,System.Object)"/>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Warning(System.Exception,System.Object)">
            <summary>
            Log an exception as a warning, with given message override.
            </summary>
            <param name="exception">The exception to log.</param>
            <param name="message">The text to override exceptions' message with in the log.</param>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Info(System.Object)">
            <summary>
            Log some information. This is the default log severity level.
            </summary>
            <param name="message">The information to log.</param>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Trace(System.Object)">
            <summary>
            Log some information. This is least severe log level.
            </summary>
            <param name="message">The information to log.</param>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Warning(System.Object)">
            <summary>
            Log a warning. This is the second most severe log level.
            </summary>
            <param name="message">The warning to log.</param>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.Error(System.Object)">
            <summary>
            Log an error. This is the most severe log level.
            </summary>
            <param name="message">The error to log.</param>
        </member>
        <member name="M:Sandbox.Diagnostics.Logger.WrapObject(System.Object,System.Collections.Generic.List{System.Object})">
            <summary>
            Wrap / escape an object for html log messages. Inspectable objects
            will be wrapped in a link, and added to <paramref name="outArgs"/>.
            The link will index into <paramref name="outArgs"/>. <see cref="T:System.FormattableString"/>s
            will recurse into <see cref="M:Sandbox.Diagnostics.Logger.WrapObject(System.Object,System.Collections.Generic.List{System.Object})"/>, so their arguments can also be inspected.
            </summary>
            <param name="o">Object to wrap</param>
            <param name="outArgs">Inspectable objects will be added here</param>
            <returns>Html-wrapped object. Either a string or a primitive.</returns>
        </member>
        <member name="M:Sandbox.Diagnostics.Logging.ShouldLog(System.String,Sandbox.LogLevel)">
            <summary>
            Return true if we should print this log entry. Use a cache to avoid craziness.
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.Logging.Loggers">
            <summary>
            Keep a list of loggers
            </summary>
        </member>
        <member name="T:Sandbox.Diagnostics.FastTimer">
            <summary>
            Like stopwatch, but more lightweight and straight to the point. Use FastTimer.StartNew()
            </summary>
        </member>
        <member name="T:Sandbox.PureAttribute">
            <inheritdoc cref="T:Facepunch.ActionGraphs.IPureAttribute"/>
        </member>
        <member name="T:Sandbox.ImpureAttribute">
            <inheritdoc cref="T:Facepunch.ActionGraphs.IImpureAttribute"/>
        </member>
        <member name="T:Sandbox.ActionGraphTargetAttribute">
            <inheritdoc cref="T:Facepunch.ActionGraphs.ITargetAttribute" />
        </member>
        <member name="T:Sandbox.HasImplementationAttribute">
            <summary>
            In ActionGraph, this type parameter can only be satisfied by a type <c>TArg</c>, such
            that there exists at least one non-abstract type that extends / implements both
            <c>TArg</c> and <see cref="P:Sandbox.HasImplementationAttribute.BaseType"/>.
            </summary>
        </member>
        <member name="P:Sandbox.HasImplementationAttribute.BaseType">
            <summary>
            Base class or interface for which there must exist an extending / implementing type.
            </summary>
        </member>
        <member name="M:Sandbox.HasImplementationAttribute.#ctor(System.Type)">
            <inheritdoc cref="T:Sandbox.HasImplementationAttribute"/>
            <param name="baseType">
            Base class or interface for which there must exist an extending / implementing type.
            </param>
        </member>
        <member name="T:Sandbox.ActionGraphPropertyAttribute">
            <summary>
            In ActionGraph, this parameter should only be configurable in the inspector as a property and not have a dedicated input.
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphNodeAttribute">
            <inheritdoc cref="T:Facepunch.ActionGraphs.INodeAttribute"/>
        </member>
        <member name="P:Sandbox.ActionGraphNodeAttribute.Identifier">
            <inheritdoc />
        </member>
        <member name="P:Sandbox.ActionGraphNodeAttribute.DefaultInputSignal">
            <inheritdoc />
        </member>
        <member name="P:Sandbox.ActionGraphNodeAttribute.DefaultOutputSignal">
            <inheritdoc />
        </member>
        <member name="P:Sandbox.ActionGraphNodeAttribute.InheritAsync">
            <inheritdoc />
        </member>
        <member name="T:Sandbox.ActionGraphOperatorAttribute">
            <summary>
            Display this node as an operator, with no header or socket labels, and a big icon in the middle.
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphIncludeAttribute.AutoExpand">
            <summary>
            If true, double-clicking on an output of the declaring type will auto-expand this member.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.ITitleProvider">
            <summary>
            Provides a title or a "nice name" for DisplayInfo of a member or a type.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.ITitleProvider.Value">
            <summary>
            The title.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IPlaceholderProvider">
            <summary>
            Provides placeholder text for DisplayInfo of a member or a type.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPlaceholderProvider.Value">
            <summary>
            The placeholder text.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IDescriptionProvider">
            <summary>
            Provides a description for DisplayInfo of a member or a type.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IDescriptionProvider.Value">
            <summary>
            The description.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.ICategoryProvider">
            <summary>
            Provides category or group for DisplayInfo of a member or a type.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.ICategoryProvider.Value">
            <summary>
            The category.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IClassNameProvider">
            <summary>
            Provides internal class name for DisplayInfo of a member or a type.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IClassNameProvider.Value">
            <summary>
            The class name.
            Typically a class name is all lower case, has spaces replaced by underscores (_) or dashes (-) and contains no other special symbols.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IIconProvider">
            <summary>
            Provides an icon for DisplayInfo of a member or a type.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IIconProvider.Value">
            <summary>
            The icon. Typically this is the name of a <a href="https://fonts.google.com/icons">material icon</a>.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IOrderProvider">
            <summary>
            Provides an order number for DisplayInfo of a member or a type.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IOrderProvider.Value">
            <summary>
            Order value, for sorting in menus.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.ClassFileLocationAttribute">
            <summary>
            Automatically added to codegenerated classes to let them determine their location
            This helps when looking for resources relative to them, like style sheets.
            Replaced in Sept 2023 by SourceLocationAttribute, which is added to classes and members.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.SourceLocationAttribute">
            <summary>
            Automatically added to classes and their members to let them determine their location
            This helps when looking for resources relative to them, like style sheets.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IUpdateSubscriber">
            <summary>
            Automatically added to classes that implement OnUpdate()
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IFixedUpdateSubscriber">
            <summary>
            Automatically added to classes that implement OnFixedUpdate()
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IPreRenderSubscriber">
            <summary>
            Automatically added to classes that implement OnPreRender()
            </summary>
        </member>
        <member name="T:Sandbox.ReadOnlyAttribute">
            <summary>
            Display this in the inspector - but don't let anyone edit it
            </summary>
        </member>
        <member name="T:Sandbox.TextAreaAttribute">
            <summary>
            When applied to a string property, show a multi-line text box instead of a single line.
            </summary>
        </member>
        <member name="T:Sandbox.InputActionAttribute">
            <summary>
            When applied to a string property, use an input action selector.
            </summary>
        </member>
        <member name="T:Sandbox.FontNameAttribute">
            <summary>
            When applied to a string property, uses a font name selector.
            </summary>
        </member>
        <member name="T:Sandbox.EventAttribute">
            <summary>
            A generic event listener. You are probably looking for Sandbox.Event.* attributes.
            </summary>
        </member>
        <member name="P:Sandbox.EventAttribute.EventName">
            <summary>
            The internal event identifier.
            </summary>
        </member>
        <member name="P:Sandbox.EventAttribute.Priority">
            <summary>
            Events with lower numbers are run first. This defaults to 0, so setting it to -1 will mean your
            event will run before all other events that don't define it. Setting it to 1 would mean it'll
            run after all events that don't.
            </summary>
        </member>
        <member name="T:Sandbox.SkipHotloadAttribute">
            <summary>
            Skip processing a specific field, or any fields in a type marked by this attribute. Field
            processing will still occur if a type marked by this attribute was defined in a swapped assembly.
            </summary>
            <remarks>
            This is nice for speeding up hotloading, particularly when used on types with lots of fields, or
            on fields that are the only path to large networks of objects that all don't need replacing during the hotload.
            </remarks>
        </member>
        <member name="T:Sandbox.SuppressNullKeyWarningAttribute">
            <summary>
            When applied to a member with <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="T:System.Collections.Generic.HashSet`1"/> type,
            don't warn if the key of an item becomes null during a hotload because a type is removed. You should
            only use this attribute if you're sure that it's safe to quietly remove entries.
            </summary>
        </member>
        <member name="T:Sandbox.IHotloadManaged">
            <summary>
            During hotloads, instances of types implementing this interface will be notified when
            they get replaced.
            </summary>
        </member>
        <member name="M:Sandbox.IHotloadManaged.Destroyed(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Called when this instance is about to be replaced during a hotload.
            The implementor may optionally write to the <paramref name="state"/>
            dictionary, which gets passed to the new replacing instance when
            <see cref="M:Sandbox.IHotloadManaged.Created(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})"/> is called on it.
            </summary>
            <param name="state">Dictionary to store values to pass to the new instance.</param>
        </member>
        <member name="M:Sandbox.IHotloadManaged.Created(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
            <summary>
            Called when this instance has been created during a hotload, replacing an
            instance from an older version of the containing assembly. The <paramref name="state"/>
            parameter will contain any values populated when <see cref="M:Sandbox.IHotloadManaged.Destroyed(System.Collections.Generic.Dictionary{System.String,System.Object})"/> was called
            on the old instance that was replaced.
            </summary>
            <param name="state">Dictionary containing values written by the old instance.</param>
        </member>
        <member name="M:Sandbox.IHotloadManaged.Failed">
            <summary>
            Called when this instance could not be upgraded during a hotload, and any references
            to it have been replaced with null. This is a good time to clean up any unmanaged resources
            related to this instance.
            </summary>
        </member>
        <member name="T:Sandbox.InputAttribute">
            <summary>
            Makes this method available as a Map Logic Input, for use in the Hammer Editor. This is only applicable to entities.
            </summary>
        </member>
        <member name="P:Sandbox.InputAttribute.Name">
            <summary>
            Desired name of this input. If not set, the method's name will be used.
            </summary>
        </member>
        <member name="T:Sandbox.ButtonAttribute">
            <summary>
            When added to a method - the inspector will show a button for it.
            </summary>
        </member>
        <member name="T:Sandbox.RequireComponentAttribute">
            <summary>
            When added to a property on a Compononent, we'll try to make that component value non null.
            We will first look on the GameObject for the component type. If it's not found, we'll create one.
            </summary>
        </member>
        <member name="T:Sandbox.ITypeAttribute">
            <summary>
            When applied to an attribute, which is then applied to a type..
            This will make <see cref="P:Sandbox.ITypeAttribute.TargetType"/> set on the attribute upon load.
            <para>This provides a convenient way to know which type the attribute was attached to.</para>
            </summary>
        </member>
        <member name="P:Sandbox.ITypeAttribute.TargetType">
            <summary>
            The type this attribute was attached to.
            </summary>
        </member>
        <member name="M:Sandbox.ITypeAttribute.TypeRegister">
            <summary>
            Called when a class with this attribute is registered via the TypeLibrary.
            </summary>
        </member>
        <member name="M:Sandbox.ITypeAttribute.TypeUnregister">
            <summary>
            Called when a class with this attribute is unregistered via the TypeLibrary.
            </summary>
        </member>
        <member name="T:Sandbox.JsonUpgraderAttribute">
            <summary>
            An attribute that describes a version update for a JSON object.
            </summary>
        </member>
        <member name="P:Sandbox.JsonUpgraderAttribute.Version">
            <summary>
            The version of this upgrade.
            </summary>
        </member>
        <member name="P:Sandbox.JsonUpgraderAttribute.Type">
            <summary>
            The type we're targeting for this upgrade.
            </summary>
        </member>
        <member name="P:Sandbox.LibraryAttribute.Name">
            <summary>
            This is the name that will be used to create this class.
            If you don't set it via the attribute constructor it will be set
            to the name of the class it's attached to
            </summary>
        </member>
        <member name="P:Sandbox.LibraryAttribute.FullName">
            <summary>
            The full class name
            </summary>
        </member>
        <member name="P:Sandbox.LibraryAttribute.Title">
            <summary>
            A nice presentable name to show
            </summary>
        </member>
        <member name="P:Sandbox.LibraryAttribute.Description">
            <summary>
            We use this to provide a nice description in the editor
            </summary>
        </member>
        <member name="P:Sandbox.LibraryAttribute.Group">
            <summary>
            We use this to organize groups of entities in the editor
            </summary>
        </member>
        <member name="P:Sandbox.LibraryAttribute.Editable">
            <summary>
            We use this to filter entities to show in the entity list in the editor
            </summary>
        </member>
        <member name="T:Sandbox.MethodArgumentsAttribute">
            <summary>
            Specify the types of arguments a method should have. Typically used with event attributes to throw an exception
            if an event attribute is added to a method with incorrect arguments.
            </summary>
        </member>
        <member name="P:Sandbox.PropertyAttribute.Name">
            <summary>
            The internal name of this property. This should be lowercase with no spaces. If unset the lowercased C# variable name is used.
            </summary>
        </member>
        <member name="P:Sandbox.PropertyAttribute.Title">
            <summary>
            The user friendly name of this property. If unset, it will be auto generated from C# variable name.
            </summary>
        </member>
        <member name="M:Sandbox.PropertyAttribute.#ctor(System.String)">
            <param name="internal_name">The internal name of this property. This should be lowercase with no spaces.</param>
        </member>
        <member name="T:Sandbox.KeyPropertyAttribute">
            <summary>
            Mark this property as the key property - which means that it can represent the whole object in a single line, while
            usually offering an advanced mode to view the entire object.
            </summary>
        </member>
        <member name="T:Sandbox.InlineEditorAttribute">
            <summary>
            Tell the editor to try to display inline editing for this property, rather than hiding it behind a popup etc.
            </summary>
        </member>
        <member name="T:Sandbox.RangeAttribute">
            <summary>
            Mark this property as a ranged float/int. In inspector we'll be able to create a slider
            instead of a text entry.
            TODO: Replace this with the System.ComponentModel.DataAnnotations.Range one - move step and clamped to their own attributes
            </summary>
        </member>
        <member name="T:Sandbox.ChangeAttribute">
            <summary>
            Combined with [ConVar] this will invoke a method when the property changes.<br/>
            If no name is provided, we will try to call On[PropertyName]Changed.<br/>
            The callback should have 2 arguments - oldValue and newValue, both of the same type as the property itself.
            </summary>
        </member>
        <member name="F:Sandbox.ChangeAttribute.Name">
            <summary>
            Name of the method to call on change.
            </summary>
        </member>
        <member name="T:Sandbox.StringLiteralOnlyAttribute">
            <summary>
            Ask codegen to shit itself if the parameter isn't passed in as a string literal
            </summary>
        </member>
        <member name="T:Sandbox.HideAttribute">
            <summary>
            Hide this in tools/editors.
            </summary>
        </member>
        <member name="T:Sandbox.CodeGeneratorAttribute">
            <summary>
            An attribute that can be added to a custom <see cref="T:System.Attribute"/> class for special code generation behavior.
            They'll then be applied to methods and properties when they are decorated with <i>that</i> attribute.
            </summary>
        </member>
        <member name="P:Sandbox.CodeGeneratorAttribute.Priority">
            <summary>
            Attributes with a higher priority will wrap the target first. The default priority is 0.
            </summary>
        </member>
        <member name="P:Sandbox.CodeGeneratorAttribute.CallbackName">
            <summary>
            The name of the callback method. This can be a fully qualified static method callback or a simple callback to invoke
            on the target object if the method or property target is not static.
            </summary>
        </member>
        <member name="P:Sandbox.CodeGeneratorAttribute.Type">
            <summary>
            The type of code generation you want to do.
            You will need to specify whether it should apply to instance or static methods and properties using the <see cref="F:Sandbox.CodeGeneratorFlags.Instance"/>
            and <see cref="F:Sandbox.CodeGeneratorFlags.Static"/> flags.
            </summary>
        </member>
        <member name="M:Sandbox.CodeGeneratorAttribute.#ctor(Sandbox.CodeGeneratorFlags,System.String,System.Int32)">
            <summary>
            Perform code generation for a method or property.
            </summary>
            <param name="type">
            The type of code generation you want to do.
            You will need to specify whether it should apply to instance or static methods and properties using the <see cref="F:Sandbox.CodeGeneratorFlags.Instance"/>
            and <see cref="F:Sandbox.CodeGeneratorFlags.Static"/> flags.
            </param>
            <param name="callbackName">
            The name of the callback method. This can be a fully qualified static method callback or a simple callback to invoke
            on the target object if the method or property target is not static.
            </param>
            <param name="priority">
            Attributes with a higher priority will wrap the target first. The default priority is 0.
            </param>
        </member>
        <member name="T:Sandbox.CodeGeneratorFlags">
            <summary>
            Used to specify what type of code generation to perform.
            </summary>
        </member>
        <member name="F:Sandbox.CodeGeneratorFlags.WrapPropertyGet">
            <summary>
            Wrap the get accessor of a property.
            </summary>
        </member>
        <member name="F:Sandbox.CodeGeneratorFlags.WrapPropertySet">
            <summary>
            Wrap the set accessor of a property.
            </summary>
        </member>
        <member name="F:Sandbox.CodeGeneratorFlags.WrapMethod">
            <summary>
            Wrap a method call.
            </summary>
        </member>
        <member name="F:Sandbox.CodeGeneratorFlags.Static">
            <summary>
            Apply this to a static property or method.
            </summary>
        </member>
        <member name="F:Sandbox.CodeGeneratorFlags.Instance">
            <summary>
            Apply this to an instance property or method.
            </summary>
        </member>
        <member name="T:Sandbox.WrappedMethod">
            <summary>
            Provides data about a wrapped method in a <see cref="T:Sandbox.CodeGeneratorAttribute"/> callback.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod.Resume">
            <summary>
            Invoke the original method.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod.Object">
            <summary>
            The object whose method is being wrapped. This will be null if we're wrapping a static method.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod.IsStatic">
            <summary>
            Is this a static method?
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod.TypeName">
            <summary>
            The name of the type that the method belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod.MethodName">
            <summary>
            The name of the original method.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod.MethodIdentity">
            <summary>
            The Identity of the original method. This is an integer that each MethodDescription has to distinguish itself from other methods of the same class.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod.Attributes">
            <summary>
            An array of all attributes decorated with <see cref="T:Sandbox.CodeGeneratorAttribute"/> on the original method.
            </summary>
        </member>
        <member name="T:Sandbox.WrappedMethod`1">
            <summary>
            Provides data about a wrapped method in a <see cref="T:Sandbox.CodeGeneratorAttribute"/> callback.
            </summary>
            <typeparam name="T">The expected return type for the wrapped method.</typeparam>
        </member>
        <member name="P:Sandbox.WrappedMethod`1.Resume">
            <summary>
            Invoke the original method.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod`1.IsStatic">
            <summary>
            Is this a static method?
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod`1.TypeName">
            <summary>
            The name of the type that the method belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod`1.MethodName">
            <summary>
            The name of the original method. If static, will return the full name including the type.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod`1.MethodIdentity">
            <summary>
            The Identity of the original method. This is an integer that each MethodDescription has to distinguish itself from other methods of the same class.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedMethod`1.Attributes">
            <summary>
            An array of all attributes decorated with <see cref="T:Sandbox.CodeGeneratorAttribute"/> on the original method.
            </summary>
        </member>
        <member name="T:Sandbox.WrappedPropertySet`1">
            <summary>
            Provides data about a wrapped property setter in a <see cref="T:Sandbox.CodeGeneratorAttribute"/> callback.
            </summary>
            <typeparam name="T">The expected type of the wrapped property.</typeparam>
        </member>
        <member name="P:Sandbox.WrappedPropertySet`1.Value">
            <summary>
            The value the property wants to be set to.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertySet`1.Object">
            <summary>
            The object whose property is being wrapped. This will be null if we're wrapping a static property.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertySet`1.Setter">
            <summary>
            Invoke the original setter with the provided value.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertySet`1.IsStatic">
            <summary>
            Is this a static property?
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertySet`1.TypeName">
            <summary>
            The name of the type that the property belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertySet`1.PropertyName">
            <summary>
            The name of the original property. If static, will return the full name including the type.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertySet`1.MemberIdent">
            <summary>
            The identity of the original property. Used by TypeLibrary as a unique identifier for the property.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertySet`1.Attributes">
            <summary>
            An array of all attributes decorated with <see cref="T:Sandbox.CodeGeneratorAttribute"/> on the original property.
            </summary>
        </member>
        <member name="T:Sandbox.WrappedPropertyGet`1">
            <summary>
            Provides data about a wrapped property getter in a <see cref="T:Sandbox.CodeGeneratorAttribute"/> callback.
            </summary>
            <typeparam name="T">The expected type of the wrapped property.</typeparam>
        </member>
        <member name="P:Sandbox.WrappedPropertyGet`1.Value">
            <summary>
            The value from the original getter.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertyGet`1.Object">
            <summary>
            The object whose property is being wrapped. This will be null if we're wrapping a static property.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertyGet`1.IsStatic">
            <summary>
            Is this a static property?
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertyGet`1.TypeName">
            <summary>
            The name of the type that the property belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertyGet`1.PropertyName">
            <summary>
            The name of the original property. If static, will return the full name including the type.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertyGet`1.MemberIdent">
            <summary>
            The identity of the original property. Used by TypeLibrary as a unique identifier for the property.
            </summary>
        </member>
        <member name="P:Sandbox.WrappedPropertyGet`1.Attributes">
            <summary>
            An array of all attributes decorated with <see cref="T:Sandbox.CodeGeneratorAttribute"/> on the original property.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.BufferedHashSet`1">
            <summary>
            A HashSet that buffers additions and removals until next enumerated, making it safe to iterate whilst modifying.
            This probably isn't thread safe.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.BufferedHashSet`1.Commit">
            <summary>
            Commit additions and removals to the main hashset
            </summary>
        </member>
        <member name="T:Sandbox.Utility.CircularBuffer`1">
            <summary>
            Circular buffer, push pop and index access is always O(1).
            </summary>
        </member>
        <member name="F:Sandbox.Utility.CircularBuffer`1._start">
            <summary>
            The _start. Index of the first element in buffer.
            </summary>
        </member>
        <member name="F:Sandbox.Utility.CircularBuffer`1._end">
            <summary>
            The _end. Index after the last element in the buffer.
            </summary>
        </member>
        <member name="F:Sandbox.Utility.CircularBuffer`1._size">
            <summary>
            The _size. Buffer size.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Sandbox.Utility.CircularBuffer`1"/> class.
            
            </summary>
            <param name='capacity'>
            Buffer capacity. Must be positive.
            </param>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.#ctor(System.Int32,`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:Sandbox.Utility.CircularBuffer`1"/> class.
            
            </summary>
            <param name='capacity'>
            Buffer capacity. Must be positive.
            </param>
            <param name='items'>
            Items to fill buffer with. Items length must be less than capacity.
            Suggestion: use Skip(x).Take(y).ToArray() to build this argument from
            any enumerable.
            </param>
        </member>
        <member name="P:Sandbox.Utility.CircularBuffer`1.Capacity">
            <summary>
            Maximum capacity of the buffer. Elements pushed into the buffer after
            maximum capacity is reached (IsFull = true), will remove an element.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.CircularBuffer`1.IsFull">
            <summary>
            Boolean indicating if Circular is at full capacity.
            Adding more elements when the buffer is full will
            cause elements to be removed from the other end
            of the buffer.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.CircularBuffer`1.IsEmpty">
            <summary>
            True if has no elements.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.CircularBuffer`1.Size">
            <summary>
            Current buffer size (the number of elements that the buffer has).
            </summary>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.Front">
            <summary>
            Element at the front of the buffer - this[0].
            </summary>
            <returns>The value of the element of type T at the front of the buffer.</returns>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.Back">
            <summary>
            Element at the back of the buffer - this[Size - 1].
            </summary>
            <returns>The value of the element of type T at the back of the buffer.</returns>
        </member>
        <member name="P:Sandbox.Utility.CircularBuffer`1.Item(System.Int32)">
            <summary>
            Index access to elements in buffer.
            Index does not loop around like when adding elements,
            valid interval is [0;Size[
            </summary>
            <param name="index">Index of element to access.</param>
            <exception cref="T:System.IndexOutOfRangeException">Thrown when index is outside of [; Size[ interval.</exception>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.PushBack(`0)">
            <summary>
            Pushes a new element to the back of the buffer. Back()/this[Size-1]
            will now return this element.
            
            When the buffer is full, the element at Front()/this[0] will be 
            popped to allow for this new element to fit.
            </summary>
            <param name="item">Item to push to the back of the buffer</param>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.PushFront(`0)">
            <summary>
            Pushes a new element to the front of the buffer. Front()/this[0]
            will now return this element.
            
            When the buffer is full, the element at Back()/this[Size-1] will be 
            popped to allow for this new element to fit.
            </summary>
            <param name="item">Item to push to the front of the buffer</param>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.PopBack">
            <summary>
            Removes the element at the back of the buffer. Decreasing the 
            Buffer size by 1.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.PopFront">
            <summary>
            Removes the element at the front of the buffer. Decreasing the 
            Buffer size by 1.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.Clear">
            <summary>
            Clears the contents of the array. Size = 0, Capacity is unchanged.
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.ToArray">
            <summary>
            Copies the buffer contents to an array, according to the logical
            contents of the buffer (i.e. independent of the internal 
            order/contents)
            </summary>
            <returns>A new array with a copy of the buffer contents.</returns>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.ToArraySegments">
             <summary>
             Get the contents of the buffer as 2 ArraySegments.
             Respects the logical contents of the buffer, where
             each segment and items in each segment are ordered
             according to insertion.
            
             Fast: does not copy the array elements.
             Useful for methods like <c>Send(IList&lt;ArraySegment&lt;Byte&gt;&gt;)</c>.
             
             <remarks>Segments may be empty.</remarks>
             </summary>
             <returns>An IList with 2 segments corresponding to the buffer content.</returns>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through this buffer.
            </summary>
            <returns>An enumerator that can be used to iterate this collection.</returns>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.Increment(System.Int32@)">
            <summary>
            Increments the provided index variable by one, wrapping
            around if necessary.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.Decrement(System.Int32@)">
            <summary>
            Decrements the provided index variable by one, wrapping
            around if necessary.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Sandbox.Utility.CircularBuffer`1.InternalIndex(System.Int32)">
            <summary>
            Converts the index in the argument to an index in <code>_buffer</code>
            </summary>
            <returns>
            The transformed index.
            </returns>
            <param name='index'>
            External index.
            </param>
        </member>
        <member name="T:Sandbox.Utility.Noise">
             <summary>
             Provides access to coherent noise utilities.
            
             All of these functions should return between -1 and 1.
             </summary>
        </member>
        <member name="M:Sandbox.Utility.Noise.Perlin(System.Single,System.Single)">
            <summary>
            2D <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a> function.
            </summary>
            <param name="x">Input on the X axis.</param>
            <param name="y">Input on the Y axis.</param>
            <returns>Resulting noise at given coordinates, in range of -1 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Noise.Perlin(System.Single,System.Single,System.Single)">
            <summary>
            3D <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a> function.
            </summary>
            <param name="x">Input on the X axis.</param>
            <param name="y">Input on the Y axis.</param>
            <param name="z">Input on the Z axis.</param>
            <returns>Resulting noise at given coordinates, in range of -1 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Noise.Simplex(System.Single,System.Single)">
            <summary>
            2D <a href="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise</a> function.
            </summary>
            <param name="x">Input on the X axis.</param>
            <param name="y">Input on the Y axis.</param>
            <returns>Resulting noise at given coordinates, in range of -1 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Noise.Simplex(System.Single,System.Single,System.Single)">
            <summary>
            3D <a href="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise</a> function.
            </summary>
            <param name="x">Input on the X axis.</param>
            <param name="y">Input on the Y axis.</param>
            <param name="z">Input on the Z axis.</param>
            <returns>Resulting noise at given coordinates, in range of -1 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Noise.Fbm(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion">Fractional Brownian Motion</a> noise, a.k.a. Fractal Perlin noise.
            </summary>
            <param name="octaves">Number of octaves for the noise. Higher values are slower but produce more detailed results. 3 is a good starting point.</param>
            <param name="x">Input on the X axis.</param>
            <param name="y">Input on the Y axis.</param>
            <param name="z">Input on the Z axis.</param>
            <returns>Resulting noise at given coordinates, in range of -1 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Noise.FbmVector(System.Int32,System.Single,System.Single)">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion">Fractional Brownian Motion</a> noise, a.k.a. Fractal Perlin noise.
            </summary>
            <param name="octaves">Number of octaves for the noise. Higher values are slower but produce more detailed results. 3 is a good starting point.</param>
            <param name="x">Input on the X axis.</param>
            <param name="y">Input on the Y axis.</param>
        </member>
        <member name="P:Sandbox.Utility.CommandLine.Full">
            <summary>
            Returns the full command line, reconstructed from System.Environment.GetCommandLineArgs
            </summary>
        </member>
        <member name="M:Sandbox.Utility.CommandLine.HasSwitch(System.String)">
            <summary>
            if ( HasSwitch( "-console" ) ) EnableConsole();
            </summary>
        </member>
        <member name="M:Sandbox.Utility.CommandLine.GetSwitches">
            <summary>
            Returns all command line values
            </summary>
            <returns></returns>
        </member>
        <member name="T:Sandbox.Utility.Crc32">
            <summary>
            Generate 32-bit <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Cyclic Redundancy Check</a> (CRC32) checksums.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Crc32.FromBytes(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Generates a CRC32 checksum from a byte stream.
            </summary>
            <param name="byteStream">The input to generate a checksum for.</param>
            <returns>The generated CRC32.</returns>
        </member>
        <member name="M:Sandbox.Utility.Crc32.FromString(System.String)">
            <summary>
            Generates a CRC32 checksum from a string.
            </summary>
            <param name="str">The input to generate a checksum for.</param>
            <returns>The generated CRC32.</returns>
        </member>
        <member name="M:Sandbox.Utility.Crc32.FromStreamAsync(System.IO.Stream)">
            <summary>
            Generates a CRC32 checksum from a stream asynchronously.
            </summary>
            <param name="stream">The input to generate a checksum for.</param>
            <returns>The generated CRC32.</returns>
        </member>
        <member name="T:Sandbox.Utility.Crc64">
            <summary>
            Generate 64-bit <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Cyclic Redundancy Check</a> (CRC64) checksums.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Crc64.FromBytes(System.Byte[],System.Int32,System.UInt64)">
            <summary>
            Compute the CRC64 of the input data using the Azure Storage CRC64 polynomial.
            </summary>
            <param name="src">The source data on which to compute the CRC64.</param>
            <param name="size"></param>
            <param name="uCrc"></param>
        </member>
        <member name="M:Sandbox.Utility.Crc64.FromString(System.String)">
            <summary>
            Generates a CRC64 checksum from a string.
            </summary>
            <param name="str">The input to generate a checksum for.</param>
            <returns>The generated CRC64.</returns>
        </member>
        <member name="M:Sandbox.Utility.Crc64.FromStreamAsync(System.IO.Stream)">
            <summary>
            Generates a CRC64 checksum from a stream asynchronously.
            </summary>
            <param name="stream">The input to generate a checksum for.</param>
            <returns>The generated CRC64.</returns>
        </member>
        <member name="M:Sandbox.Utility.Crc64.FromStream(System.IO.Stream)">
            <summary>
            Generates a CRC64 checksum from a stream.
            </summary>
            <param name="stream">The input to generate a checksum for.</param>
            <returns>The generated CRC64.</returns>
        </member>
        <member name="M:Sandbox.Utility.Crc64.FromBytes(System.Byte[])">
            <summary>
            Generates a CRC64 checksum from a byte array.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.DataProgress">
            <summary>
            For providing a callback to describe the progress of doing something with some kind of block of data
            </summary>
        </member>
        <member name="T:Sandbox.Utility.DataProgress.HttpContentStream">
            <summary>
            A httpContent stream that produces DataProgress outputs
            </summary>
        </member>
        <member name="T:Sandbox.Utility.DisposeAction">
            <summary>
            Creates an IDisposable that will simply run an action when disposed
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Easing">
            <summary>
            Easing functions used for transitions. See <a href="https://easings.net/">https://easings.net/</a> for examples.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Easing.Function">
            <summary>
            An easing function that transforms the linear input into non linear output.
            </summary>
            <param name="delta">A linear input value from 0 to 1</param>
            <returns>The resulting non linear output value, from 0 to 1</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.EaseInOut(System.Single)">
            <inheritdoc cref="M:Sandbox.Utility.Easing.ExpoInOut(System.Single)"/>
        </member>
        <member name="M:Sandbox.Utility.Easing.EaseIn(System.Single)">
            <inheritdoc cref="M:Sandbox.Utility.Easing.QuadraticIn(System.Single)"/>
        </member>
        <member name="M:Sandbox.Utility.Easing.EaseOut(System.Single)">
            <inheritdoc cref="M:Sandbox.Utility.Easing.QuadraticOut(System.Single)"/>
        </member>
        <member name="M:Sandbox.Utility.Easing.Linear(System.Single)">
            <summary>
            Linear easing function, x=y.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.QuadraticIn(System.Single)">
            <summary>
            Quadratic ease in.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.QuadraticOut(System.Single)">
            <summary>
            Quadratic ease out.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.QuadraticInOut(System.Single)">
            <summary>
            Quadratic ease in and out.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.ExpoIn(System.Single)">
            <summary>
            Exponential ease in.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.ExpoOut(System.Single)">
            <summary>
            Exponential ease out.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.ExpoInOut(System.Single)">
            <summary>
            Exponential ease in and out.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.BounceIn(System.Single)">
            <summary>
            Bouncy ease in.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.BounceOut(System.Single)">
            <summary>
            Bouncy ease out.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.BounceInOut(System.Single)">
            <summary>
            Bouncy ease in and out.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.SineEaseIn(System.Single)">
            <summary>
            Sine ease in.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.SineEaseOut(System.Single)">
            <summary>
            Sine ease out.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.SineEaseInOut(System.Single)">
            <summary>
            Sine ease in and out.
            </summary>
            <param name="f">Input in range of 0 to 1.</param>
            <returns>Output in range 0 to 1.</returns>
        </member>
        <member name="M:Sandbox.Utility.Easing.AddFunction(System.String,Sandbox.Utility.Easing.Function)">
            <summary>
            Add an easing function.
            If the function already exists we silently return.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Easing.GetFunction(System.String)">
            <summary>
            Get an easing function by name (ie, "ease-in").
            If the function doesn't exist we return QuadraticInOut
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Easing.TryGetFunction(System.String,Sandbox.Utility.Easing.Function@)">
            <summary>
            Get an easing function by name (ie, "ease-in").
            If the function exists we return true, otherwise return false.
            </summary>
        </member>
        <member name="T:Sandbox.ConVar">
            <summary>
            Console variable
            </summary>
        </member>
        <member name="P:Sandbox.ConVar.Name">
            <summary>
            If unset the name will be set to the name of the method/property
            </summary>
        </member>
        <member name="P:Sandbox.ConVar.Help">
            <summary>
            Describes why this command exists
            </summary>
        </member>
        <member name="P:Sandbox.ConVar.Min">
            <summary>
            Minimum value for this command
            </summary>
        </member>
        <member name="P:Sandbox.ConVar.Max">
            <summary>
            Maximum value for this command
            </summary>
        </member>
        <member name="P:Sandbox.ConVar.Saved">
            <summary>
            If true this variable is saved
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.InvokeWithWarning(System.Action)">
            <summary>
            Call an action, swallow any exceptions with a warning
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToBase36``1(``0)">
            <summary>
            Encode the given number into a Base36 string
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FromBase36(System.String)">
            <summary>
            Decode the Base36 Encoded string into a number
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.GetEpoch(System.DateTime)">
            <summary>
            Returns the UNIX time stamp - number of seconds since 1st of January, 1970.
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToDateTime(System.Int32)">
            <summary>
            Converts UNIX time stamp to a DateTime object.
            </summary>
            <param name="seconds">UNIX time stamp in seconds.</param>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToDateTime(System.Int64)">
            <inheritdoc cref="M:Sandbox.SandboxSystemExtensions.ToDateTime(System.Int32)"/>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.GetOrCreate``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            If the key doesn't exist it is created and returned
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.GetValueOrDefault``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            Return value at given key, if it doesn't exist, return given default value instead.
            </summary>
            <param name="dict">The dictionary to look in.</param>
            <param name="key">The key to look up.</param>
            <param name="defaultValue">The value to return if given key is not present in the dictionary.</param>
            <returns>The value at given key, or the default value.</returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Clone``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Clones the dictionary. Doesn't clone the values.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ForEachTaskAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Runs each task on this thread but only execute a set amount at a time
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.GetCommonBaseType(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>Finds the first common base type of the given types.</summary>
            <param name="types">The types.</param>
            <returns>The common base type.</returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FormatBytes``1(``0,System.Boolean)">
            <summary>
            Given a number, will format as a memory value, ie 10gb, 4mb
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Clamp``1(``0,``0,``0)">
            <summary>
            Clamp a number between two values.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FormatSeconds(System.Int64)">
            <summary>
            Formats the given value in format "1w2d3h4m5s". Will not display 0 values.
            </summary>
            <param name="secs">Time to format, in seconds.</param>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FormatSeconds(System.UInt64)">
            <inheritdoc cref="M:Sandbox.SandboxSystemExtensions.FormatSeconds(System.Int64)"/>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FormatSecondsLong(System.Int64)">
            <summary>
            Formats the given value in format "4 weeks, 3 days, 2 hours and 1 minutes".
            Will not display 0 values. Will not display seconds if value is more than 1 hour.
            </summary>
            <param name="secs">Time to format, in seconds.</param>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FormatSecondsLong(System.UInt64)">
            <inheritdoc cref="M:Sandbox.SandboxSystemExtensions.FormatSecondsLong(System.Int64)"/>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FormatNumberShort(System.Int64)">
            <summary>
            "1500" becomes "1,500", "15 000" becomes "15K", "15 000 000" becomes "15KK", etc.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FormatNumberShort(System.UInt64)">
            <inheritdoc cref="M:Sandbox.SandboxSystemExtensions.FormatNumberShort(System.Int64)"/>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.UnsignedMod(System.Int32,System.Int32)">
            <summary>
            Does what you expected to happen when you did "a % b", that is, handles negative <paramref name="a"/> values by returning a positive number from the end.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.BitsSet(System.Int32)">
            <summary>
            Returns the number of bits set in an integer. This us usually used for flags to count
            the amount of flags set.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Plural(System.Int32,System.String,System.String)">
            <summary>
            Return single if 1 else plural
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FormatWithSuffix(System.Int32)">
            <summary>
            Change 1 to 1st, 2 to 2nd etc
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.KiloFormat(System.Int32)">
            <summary>
            Format a large number into "1045M", "56K"
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.KiloFormat(System.Int64)">
            <summary>
            Format a large number into "1045M", "56K"
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Double(System.Random,System.Double,System.Double)">
            <summary>
            Returns a double between min and max
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Float(System.Random)">
            <summary>
            Returns a random float between 0 and 1
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Float(System.Random,System.Single,System.Single)">
            <summary>
            Returns a random float between min and max
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Float(System.Random,System.Single)">
            <summary>
            Returns a random float between 0 and max (or 1)
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Double(System.Random,System.Double)">
            <summary>
            Returns a random double between 0 and max (or 1)
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Int(System.Random,System.Int32,System.Int32)">
            <summary>
            Returns a random int between min and max (inclusive)
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Int(System.Random,System.Int32)">
            <summary>
            Returns a random int between 0 and max (inclusive)
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Color(System.Random)">
            <summary>
            Returns a random Color
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Rotation(System.Random)">
            <summary>
            Returns a uniformly random rotation.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Angles(System.Random)">
            <summary>
            Returns the angles of a uniformly random rotation.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Gaussian(System.Random,System.Single,System.Single)">
            <summary>
            Sample from a Gaussian distribution with a given mean and standard deviation.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Gaussian2D(System.Random,System.Nullable{Vector2},System.Nullable{Vector2})">
            <summary>
            Sample from a 2D Gaussian distribution with a given mean and standard deviation.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Gaussian3D(System.Random,System.Nullable{Vector3},System.Nullable{Vector3})">
            <summary>
            Sample from a 3D Gaussian distribution with a given mean and standard deviation.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Gaussian4D(System.Random,System.Nullable{Vector4},System.Nullable{Vector4})">
            <summary>
            Sample from a 4D Gaussian distribution with a given mean and standard deviation.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.VectorInSquare(System.Random,System.Single)">
            <summary>
            Uniformly samples a 2D position from a square with coordinates in the range -<paramref name="extents"/> to +<paramref name="extents"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.VectorInCube(System.Random,System.Single)">
            <summary>
            Uniformly samples a 3D position from a cube with coordinates in the range -<paramref name="extents"/> to +<paramref name="extents"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.VectorInCube(System.Random,BBox@)">
            <summary>
            Uniformly samples a 3D position from a cube
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.VectorInCircle(System.Random,System.Single)">
            <summary>
            Uniformly samples a 2D position from all points with distance at most <paramref name="radius"/> from the origin.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.VectorInSphere(System.Random,System.Single)">
            <summary>
            Uniformly samples a 3D position from all points with distance at most <paramref name="radius"/> from the origin.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FromArray``1(System.Random,``0[],``0)">
            <summary>
            Returns a random value in an array
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FromList``1(System.Random,System.Collections.Generic.List{``0},``0)">
            <summary>
            Returns a random value in a list
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.HasAttribute(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <summary>
            Returns true if this member has this attribute
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.HasBaseType(System.Type,System.String)">
            <summary>
            Returns true if this type derives from a type named name
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.GetAttributeOfType``1(System.Enum)">
            <summary>
            Gets an attribute on an enum field value
            </summary>
            <typeparam name="T">The type of the attribute you want to retrieve</typeparam>
            <param name="enumVal">The enum value</param>
            <returns>The attribute of type T that exists on the enum value</returns>
            <example><![CDATA[string desc = myEnumVariable.GetAttributeOfType<DescriptionAttribute>().Description;]]></example>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.IsBasedOnGenericType(System.Type,System.Type)">
            <summary>
            Returns if this type is based on a given generic type.
            </summary>
            <param name="src">The type to test.</param>
            <param name="test">The type to test against. Typically this will be something like <code>typeof( MyType&lt;&gt; )</code></param>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.CheckValidationAttributes(System.Reflection.PropertyInfo,System.Object,System.String[]@,System.String)">
            <summary>
            Check all <see cref="T:System.ComponentModel.DataAnnotations.ValidationAttribute"/>s on this property, and get the error messages if there are any.
            </summary>
            <param name="prop">The property whose arguments to test.</param>
            <param name="obj">Instance of the object this property is of.</param>
            <param name="errors">If returned false, these will be the error messages to display.</param>
            <param name="name">Override the property name in error messages.</param>
            <returns>Returns true if all checks have passed or there is no attributes to test, false if there were errors.</returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.IsInitOnly(System.Reflection.PropertyInfo)">
            <summary>
            Determine if this property is init-only.
            </summary>
            <param name="property">The property to test.</param>
            <returns>Returns true if the property is init-only, false otherwise.</returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToSimpleString(System.Type,System.Boolean)">
            <summary>
            Returns this type's name, with nicer formatting for generic types.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToSimpleString(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Returns this member's name qualified by its declaring type, with nicer formatting for generics.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToSimpleString(System.Delegate,System.Boolean)">
            <summary>
            Returns a nice name for the given delegate, based on the method that implements it.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ReadNullTerminatedString(System.IO.Stream,System.Int64)">
            <summary>
            Read a null terminated string from the stream, at given offset.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="offset">Offset where to start reading, from the beginning of the stream.</param>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.QuoteSafe(System.String,System.Boolean)">
            <summary>
            Puts quote marks around a string. Internal quotes are backslashed.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.HtmlEncode(System.String)">
            <inheritdoc cref="M:System.Net.WebUtility.HtmlEncode(System.String)"/>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.UrlEncode(System.String)">
            <inheritdoc cref="M:System.Net.WebUtility.UrlEncode(System.String)"/>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.CollapseWhiteSpaceRegex">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match a whitespace character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.CollapseWhiteSpace(System.String)">
            <summary>
            Collapse sequences of whitespace into a single whitespace
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.CollapseSpacesAndTabsRegex">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match a character in the set [\t ] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.RemoveSpacesAroundLineBreaksRegex">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match with 2 alternative expressions, atomically.<br/>
                ○ Match a sequence of expressions.<br/>
                    ○ Zero-width positive lookbehind.<br/>
                        ○ Match a character in the set [\n\u2029] right-to-left.<br/>
                    ○ Match a character in the set [\t ] atomically at least once.<br/>
                ○ Match a sequence of expressions.<br/>
                    ○ Match a character in the set [\t ] atomically at least once.<br/>
                    ○ Zero-width positive lookahead.<br/>
                        ○ Match a character in the set [\n\u2029].<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.CollapseSpacesAndPreserveLines(System.String)">
            <summary>
            Collapse sequences of spaces and tabs into a single space, preserving newlines
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.NormalizeFilename(System.String,System.Boolean)">
            <summary>
            Puts a filename into the format /path/filename.ext (from path\FileName.EXT)
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.NormalizeFilename(System.String,System.Boolean,System.Boolean)">
            <summary>
            Puts a filename into the format /path/filename.ext (from path\FileName.EXT)
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.SimplifyPath(System.String)">
            <summary>
            Gets rid of ../'s (from /path/folder/../file.txt to /path/file.txt)
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.SplitQuotesStrings(System.String)">
            <summary>
            in  : I am "splitting a" string "because it's fun "
            out : ["I", "am", "splitting a", "string", "because it's fun"]
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToDecimal(System.String,System.Decimal)">
            <summary>
            128-bit data type that returns sane results for almost any input.
            All other numeric types can cast from this.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToFloat(System.String,System.Single)">
            <summary>
            Convert to float, if not then return Default
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToFloatEval(System.String,System.Single)">
            <summary>
            Convert to float. Might be a string formula. This is always going to be slower than a call to ToFloat.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToUInt(System.String,System.Int32)">
            <summary>
            Convert to uint, if not then return Default
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToInt(System.String,System.Int32)">
            <summary>
            Convert to int, if not then return Default
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToULong(System.String,System.UInt64)">
            <summary>
            Convert to ulong, if not then return Default
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToLong(System.String,System.Int64)">
            <summary>
            Convert to long, if not then return Default
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToBool(System.String)">
            <summary>
            Try to convert to bool. Inputs can be true, false, yes, no, 0, 1, null (caps insensitive)
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Truncate(System.String,System.Int32,System.String)">
            <summary>
            If the string is longer than this amount of characters then truncate it
            If appendage is defined, it will be appended to the end of truncated strings (ie, "..")
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.TruncateFilename(System.String,System.Int32,System.String)">
            <summary>
            If the string is longer than this amount of characters then truncate it
            If appendage is defined, it will be appended to the end of truncated strings (ie, "..")
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Contains(System.String,System.String,System.StringComparison)">
            <summary>
            An extended Contains which takes a StringComparison.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Snippet(System.String,System.String,System.Int32)">
            <summary>
            Given a large string, find all occurrences of a substring and return them with padding.
            This is useful in situations where you're searching for a word in a hug body of text, and
            want to show how it's used without displaying the whole text.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToTitleCase(System.String)">
            <summary>
            Convert a variable name to something more user friendly.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.RemoveBadCharacters(System.String)">
            <summary>
            Removes bad, invisible characters that are commonly used to exploit.
            https://en.wikipedia.org/wiki/Zero-width_non-joiner
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Base64Encode(System.String)">
            <summary>
            Convert to a base64 encoded string
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Base64Decode(System.String)">
            <summary>
            Convert from a base64 encoded string
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.ToType(System.String,System.Type)">
            <summary>
            Try to politely convert from a string to another type
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.TryToType(System.String,System.Type,System.Object@)">
            <summary>
            Try to politely convert from a string to another type
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.FastHash(System.String)">
            <summary>
            Generate FNV-1a hash from given string.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.MurmurHash2(System.String,System.Boolean,System.UInt32)">
            <summary>
            The seed is what the engine uses for STRINGTOKEN_MURMURHASH_SEED
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Columnize(System.String,System.Int32,System.Boolean)">
            <summary>
            convert "string" into "string       " or "      string"
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.WildcardMatch(System.String,System.String)">
            <summary>
            Returns true if this string matches a wildcard match. Check is case insensitive.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.TrimQuoted(System.String,System.Boolean)">
            <summary>
            The string might start and end in quotes ( ", ' ), remove those if that is the case.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.Distance(System.String,System.String)">
            <summary>
            Return the distance between two strings. Useful for ordering strings by similarity
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.IsValidTag(System.String)">
            <summary>
            Is this string a valid Tag. This is a way to check if a string is a valid tag, project wide. So our logic is always the same.
            
            - not null
            - between 1 and 32 chars
            - a-z
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.GetFilenameSafe(System.String)">
            <summary>
            Make the passed in string filename safe. This replaces any invalid characters with "_".
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.GetManagedSize(System.Type)">
            <summary>
            Get the managed size of a given type. This matches an IL-level sizeof(t), even if it cannot be determined normally in C#.
            Note that <c>sizeof(t) != Marshal.SizeOf(t)</c> when t is char or bool.
            </summary>
            <remarks>
            An IL-level <c>sizeof(t)</c> will return <c>sizeof(IntPtr)</c> for reference types, as it refers to the size on stack or in an object,
            not the size on heap.
            </remarks>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.IsPrivate(System.Uri)">
            <summary>
            Does this Uri resolve to a private range IP address?
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.IsPrivate(System.Net.IPAddress)">
            <summary>
            Returns true if the IP address is in a private range.<br/>
            IPv4: Loopback, link local ("169.254.x.x"), class A ("10.x.x.x"), class B ("172.16.x.x" to "172.31.x.x") and class C ("192.168.x.x").<br/>
            IPv6: Loopback, link local, site local, unique local and private IPv4 mapped to IPv6.<br/>
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.CatmullRomSpline(System.Collections.Generic.IEnumerable{Vector3},System.Int32)">
            <summary>
            Generates a Catmull-Rom spline from a collection of Vector3 points. Needs at least 3 points to create a spline.
            </summary>
            <param name="points">The collection of Vector3 points.</param>
            <param name="interpolation">The number of interpolated points to generate between each pair of input points.</param>
            <returns>An IEnumerable of Vector3 points representing the Catmull-Rom spline.</returns>
        </member>
        <member name="M:Sandbox.SandboxSystemExtensions.IsValid(Sandbox.IValid)">
            <summary>
            Returns false if <see cref="T:Sandbox.IValid"/> object is null or if <see cref="P:Sandbox.IValid.IsValid"/> returns false.
            </summary>
        </member>
        <member name="T:Sandbox.TextFlag">
            <summary>
            Flags dictating position of text (and other elements).
            Default alignment on each axis is Top, Left.
            Values for each axis can be combined into a single value, conflicting values have undefined behavior.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.Left">
            <summary>
            Align to the left on the X axis.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.Right">
            <summary>
            Align to the right on the X axis.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.CenterHorizontally">
            <summary>
            Align in the center on the X axis.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.Top">
            <summary>
            Anchor to the top on the Y axis.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.Bottom">
            <summary>
            Anchor to the bottom on the Y axis.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.CenterVertically">
            <summary>
            Align in the center on the Y axis.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.LeftTop">
            <summary>
            Anchor to the top left corner.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.LeftCenter">
            <summary>
            Anchor to the left side, center vertically.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.LeftBottom">
            <summary>
            Anchor to the bottom left corner.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.CenterTop">
            <summary>
            Anchor to the top side, center horizontally.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.Center">
            <summary>
            Align in the center on both axises.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.CenterBottom">
            <summary>
            Anchor to the bottom side, center horizontally.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.RightTop">
            <summary>
            Anchor to the top right corner.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.RightCenter">
            <summary>
            Anchor to the right side, center vertically.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.RightBottom">
            <summary>
            Anchor to the bottom right corner.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.SingleLine">
            <summary>
            Limit the text to a single line. Used in <c>Graphics.DrawText</c> and <c>Graphics.MeasureText</c>.
            </summary>
        </member>
        <member name="F:Sandbox.TextFlag.DontClip">
            <summary>
            Do not cutoff text beyond its bounds. Used in <c>Graphics.DrawText</c> and <c>Graphics.MeasureText</c>.
            </summary>
        </member>
        <member name="T:Sandbox.Html.Attribute">
            <summary>
            Represents an HTML attribute.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Attribute.Name">
            <summary>
            Gets the qualified name of the attribute.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Attribute.Value">
            <summary>
            Gets or sets the value of the attribute.
            </summary>
        </member>
        <member name="T:Sandbox.Html.Document">
            <summary>
            Represents a complete HTML document.
            </summary>
        </member>
        <member name="F:Sandbox.Html.Document.Text">
            <summary>The HtmlDocument Text. Careful if you modify it.</summary>
        </member>
        <member name="F:Sandbox.Html.Document.BackwardCompatibility">
            <summary>True to stay backward compatible with previous version of HAP. This option does not guarantee 100% compatibility.</summary>
        </member>
        <member name="F:Sandbox.Html.Document.OptionCheckSyntax">
            <summary>
            Defines if non closed nodes will be checked at the end of parsing. Default is true.
            </summary>
        </member>
        <member name="F:Sandbox.Html.Document.OptionExtractErrorSourceTextMaxLength">
            <summary>
            Defines the maximum length of source text or parse errors. Default is 100.
            </summary>
        </member>
        <member name="F:Sandbox.Html.Document.OptionMaxNestedChildNodes">
            <summary>
            The max number of nested child nodes.
            Added to prevent stackoverflow problem when a page has tens of thousands of opening html tags with no closing tags
            </summary>
        </member>
        <member name="M:Sandbox.Html.Document.#ctor">
            <summary>
            Creates an instance of an HTML document.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Document.ParsedText">
            <summary>Gets the parsed text.</summary>
            <value>The parsed text.</value>
        </member>
        <member name="P:Sandbox.Html.Document.MaxDepthLevel">
            <summary>
            Defines the max level we would go deep into the html document. If this depth level is exceeded, and exception is
            thrown.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Document.DocumentNode">
            <summary>
            Gets the root node of the document.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Document.ParseErrors">
            <summary>
            Gets a list of parse errors found in the document.
            </summary>
        </member>
        <member name="M:Sandbox.Html.Document.IsWhiteSpace(System.Int32)">
            <summary>
            Determines if the specified character is considered as a whitespace character.
            </summary>
            <param name="c">The character to check.</param>
            <returns>true if the specified character is considered as a whitespace character.</returns>
        </member>
        <member name="M:Sandbox.Html.Document.Load(System.IO.TextReader)">
            <summary>
            Loads the HTML document from the specified TextReader.
            </summary>
            <param name="reader">The TextReader used to feed the HTML data into the document. May not be null.</param>
        </member>
        <member name="M:Sandbox.Html.Document.LoadHtml(System.String)">
            <summary>
            Loads the HTML document from the specified string.
            </summary>
            <param name="html">String containing the HTML document to load. May not be null.</param>
        </member>
        <member name="T:Sandbox.Html.Node">
            <summary>
            Represents an HTML node.
            </summary>
        </member>
        <member name="F:Sandbox.Html.Node.HtmlNodeTypeNameComment">
            <summary>
            Gets the name of a comment node. It is actually defined as '#comment'.
            </summary>
        </member>
        <member name="F:Sandbox.Html.Node.HtmlNodeTypeNameDocument">
            <summary>
            Gets the name of the document node. It is actually defined as '#document'.
            </summary>
        </member>
        <member name="F:Sandbox.Html.Node.HtmlNodeTypeNameText">
            <summary>
            Gets the name of a text node. It is actually defined as '#text'.
            </summary>
        </member>
        <member name="M:Sandbox.Html.Node.#ctor(Sandbox.Html.NodeType,Sandbox.Html.Document,System.Int32)">
            <summary>
            Initializes HtmlNode, providing type, owner and where it exists in a collection
            </summary>
            <param name="type"></param>
            <param name="ownerdocument"></param>
            <param name="index"></param>
        </member>
        <member name="P:Sandbox.Html.Node.IsElement">
            <summary>
            Returns true if this is a html element (ie, not a comment or text)
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.IsComment">
            <summary>
            Returns true if this is a comment
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.IsText">
            <summary>
            Returns true if this is text
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.Attributes">
            <summary>
            Gets the collection of HTML attributes for this node. May not be null.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.ChildNodes">
            <summary>
            Gets all the children of the node.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.Closed">
            <summary>
            Gets a value indicating if this node has been closed or not.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.HasAttributes">
            <summary>
            Gets a value indicating whether the current node has any attributes.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.HasChildNodes">
            <summary>
            Gets a value indicating whether this node has any child nodes.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.InnerHtml">
            <summary>
            Gets or Sets the HTML between the start and end tags of the object.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.Line">
            <summary>
            Gets the line number of this node in the document.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.LinePosition">
            <summary>
            Gets the column number of this node in the document.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.InnerStartIndex">
            <summary>
            Gets the stream position of the area between the opening and closing tag of the node, relative to the start of the document.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.Name">
            <summary>
            Gets or sets this node's name.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.NodeType">
            <summary>
            Gets the type of this node.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.OuterHtml">
            <summary>
            Gets or Sets the object and its content in HTML.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.OwnerDocument">
            <summary>
            Gets the <see cref="T:Sandbox.Html.Document"/> to which this node belongs.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.ParentNode">
            <summary>
            Gets the parent of this node (for nodes that can have parents).
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.PreviousSibling">
            <summary>
            Gets the node immediately preceding this node.
            </summary>
        </member>
        <member name="P:Sandbox.Html.Node.Depth">
            <summary>
            The depth of the node relative to the opening root html element. This value is used to determine if a document has to many nested html nodes which can cause stack overflows
            </summary>
        </member>
        <member name="M:Sandbox.Html.Node.Ancestors">
            <summary>
            Returns a collection of all ancestor nodes of this element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.Ancestors(System.String)">
            <summary>
            Get Ancestors with matching name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.AncestorsAndSelf">
            <summary>
            Returns a collection of all ancestor nodes of this element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.AncestorsAndSelf(System.String)">
            <summary>
            Gets all ancestor nodes and the current node
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.AppendChild(Sandbox.Html.Node)">
            <summary>
            Adds the specified node to the end of the list of children of this node.
            </summary>
            <param name="newChild">The node to add. May not be null.</param>
            <returns>The node added.</returns>
        </member>
        <member name="M:Sandbox.Html.Node.SetChildNodesId(Sandbox.Html.Node)">
            <summary>Sets child nodes identifier.</summary>
            <param name="childNode">The child node.</param>
        </member>
        <member name="M:Sandbox.Html.Node.Descendants">
            <summary>
            Gets all Descendant nodes in enumerated list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.Descendants(System.Int32)">
            <summary>
            Gets all Descendant nodes in enumerated list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.Descendants(System.String)">
            <summary>
            Get all descendant nodes with matching name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.DescendantsAndSelf">
            <summary>
            Returns a collection of all descendant nodes of this element, in document order
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.DescendantsAndSelf(System.String)">
            <summary>
            Gets all descendant nodes including this node
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.Element(System.String)">
            <summary>
            Gets first generation child node matching name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.Elements(System.String)">
            <summary>
            Gets matching first generation child nodes matching name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Html.Node.GetAttribute(System.String,System.String)">
            <summary>
            Helper method to get the value of an attribute of this node. If the attribute is not found, the default value will be returned.
            </summary>
            <param name="name">The name of the attribute to get. May not be <c>null</c>.</param>
            <param name="def">The default value to return if not found.</param>
            <returns>The value of the attribute if found, the default value if not found.</returns>
        </member>
        <member name="M:Sandbox.Html.Node.RemoveAllIDforNode(Sandbox.Html.Node)">
            <summary>Removes all id for node described by node.</summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Sandbox.Html.Node.RemoveChild(Sandbox.Html.Node)">
            <summary>
            Removes the specified child node.
            </summary>
            <param name="oldChild">The node being removed. May not be <c>null</c>.</param>
            <returns>The node removed.</returns>
        </member>
        <member name="M:Sandbox.Html.Node.SetParent(Sandbox.Html.Node)">
            <summary>
            Sets the parent Html node and properly determines the current node's depth using the parent node's depth.
            </summary>
        </member>
        <member name="T:Sandbox.Html.NodeType">
            <summary>
            Represents the type of a node.
            </summary>
        </member>
        <member name="F:Sandbox.Html.NodeType.Document">
            <summary>
            The root of a document.
            </summary>
        </member>
        <member name="F:Sandbox.Html.NodeType.Element">
            <summary>
            An HTML element.
            </summary>
        </member>
        <member name="F:Sandbox.Html.NodeType.Comment">
            <summary>
            An HTML comment.
            </summary>
        </member>
        <member name="F:Sandbox.Html.NodeType.Text">
            <summary>
            A text node is always the child of an element or a document node.
            </summary>
        </member>
        <member name="T:Sandbox.Html.ParseError">
            <summary>
            Represents a parsing error found during document parsing.
            </summary>
        </member>
        <member name="P:Sandbox.Html.ParseError.Code">
            <summary>
            Gets the type of error.
            </summary>
        </member>
        <member name="P:Sandbox.Html.ParseError.Line">
            <summary>
            Gets the line number of this error in the document.
            </summary>
        </member>
        <member name="P:Sandbox.Html.ParseError.LinePosition">
            <summary>
            Gets the column number of this error in the document.
            </summary>
        </member>
        <member name="P:Sandbox.Html.ParseError.Reason">
            <summary>
            Gets a description for the error.
            </summary>
        </member>
        <member name="P:Sandbox.Html.ParseError.SourceText">
            <summary>
            Gets the full text of the line containing the error.
            </summary>
        </member>
        <member name="P:Sandbox.Html.ParseError.StreamPosition">
            <summary>
            Gets the absolute stream position of this error in the document, relative to the start of the document.
            </summary>
        </member>
        <member name="T:Sandbox.Html.ParseErrorCode">
            <summary>
            Represents the type of parsing error.
            </summary>
        </member>
        <member name="F:Sandbox.Html.ParseErrorCode.TagNotClosed">
            <summary>
            A tag was not closed.
            </summary>
        </member>
        <member name="F:Sandbox.Html.ParseErrorCode.TagNotOpened">
            <summary>
            A tag was not opened.
            </summary>
        </member>
        <member name="F:Sandbox.Html.ParseErrorCode.CharsetMismatch">
            <summary>
            There is a charset mismatch between stream and declared (META) encoding.
            </summary>
        </member>
        <member name="F:Sandbox.Html.ParseErrorCode.EndTagNotRequired">
            <summary>
            An end tag was not required.
            </summary>
        </member>
        <member name="F:Sandbox.Html.ParseErrorCode.EndTagInvalidHere">
            <summary>
            An end tag is invalid at this position.
            </summary>
        </member>
        <member name="T:Sandbox.Html.TextNode">
            <summary>
            Represents an HTML text node.
            </summary>
        </member>
        <member name="P:Sandbox.Html.TextNode.InnerHtml">
            <summary>
            Gets or Sets the HTML between the start and end tags of the object. In the case of a text node, it is equals to OuterHtml.
            </summary>
        </member>
        <member name="P:Sandbox.Html.TextNode.OuterHtml">
            <summary>
            Gets or Sets the object and its content in HTML.
            </summary>
        </member>
        <member name="T:Sandbox.GamepadCode">
            <summary>
            Game controller codes, driven from SDL.
            </summary>
        </member>
        <member name="T:Sandbox.InputAction">
            <summary>
            An input action defined by a game project.
            </summary>
        </member>
        <member name="P:Sandbox.InputAction.Name">
            <summary>
            The name of the input action. Used by Input.Down|Pressed|Released.
            </summary>
        </member>
        <member name="P:Sandbox.InputAction.KeyboardCode">
            <summary>
            The key or key combo we'll be watching for.
            </summary>
        </member>
        <member name="P:Sandbox.InputAction.GamepadCode">
            <summary>
            What gamepad button should this action map to?
            </summary>
        </member>
        <member name="P:Sandbox.InputAction.GroupName">
            <summary>
            A group name for this input when showing in a binding system
            </summary>
        </member>
        <member name="T:Sandbox.MouseButtons">
            <summary>
            State of mouse buttons being pressed or not.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.None">
            <summary>
            No buttons are being pressed.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Left">
            <summary>
            Left mouse button is being pressed.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Right">
            <summary>
            Right mouse button is being pressed.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Middle">
            <summary>
            Middle mouse button (mouse wheel) is being pressed in.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Back">
            <summary>
            The "back" mouse button (mouse4) being pressed in.
            </summary>
        </member>
        <member name="F:Sandbox.MouseButtons.Forward">
            <summary>
            The "forward" mouse button (mouse5) being pressed in.
            </summary>
        </member>
        <member name="T:Sandbox.Localization.Languages">
            <summary>
            A list of supported languages and metadata surrounding them
            </summary>
        </member>
        <member name="P:Sandbox.Localization.Languages.List">
            <summary>
            Enumerate all languages, in no particular order
            </summary>
        </member>
        <member name="M:Sandbox.Localization.Languages.Find(System.String)">
            <summary>
            Find a language by shortname, or full name
            </summary>
        </member>
        <member name="P:Sandbox.Localization.LanguageInformation.Title">
            <summary>
            Title of the localization language.
            </summary>
        </member>
        <member name="P:Sandbox.Localization.LanguageInformation.Abbreviation">
            <summary>
            ISO 639-1 code of the language, with optional ISO 3166-1 alpha-2 country specifiers. (for example "en-GB" for British English)
            </summary>
        </member>
        <member name="P:Sandbox.Localization.LanguageInformation.Parent">
            <summary>
            If set, the <see cref="P:Sandbox.Localization.LanguageInformation.Abbreviation"/> of the parent language. For example, Pirate English is based on English.
            </summary>
        </member>
        <member name="P:Sandbox.Localization.LanguageInformation.RightToLeft">
            <summary>
            Whether the language is typed right to left, such as the Arabic language.
            </summary>
        </member>
        <member name="T:Sandbox.Localization.Phrase">
            <summary>
            A translated string. ie "Hello World".
            It might also have variables, ie "Hello {PlayerName}".
            Todo support for conditionals and plurals
            </summary>
        </member>
        <member name="M:Sandbox.Localization.Phrase.#ctor(System.String)">
            <summary>
            Create a SmartString from a phrase.
            </summary>
        </member>
        <member name="M:Sandbox.Localization.Phrase.Render">
            <summary>
            Render with no data - basically just returns Value
            </summary>
        </member>
        <member name="M:Sandbox.Localization.Phrase.Render(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Render with variables
            </summary>
        </member>
        <member name="T:Sandbox.Localization.PhraseCollection">
            <summary>
            Holds a bunch of localized phrases
            </summary>
        </member>
        <member name="M:Sandbox.Localization.PhraseCollection.Set(System.String,System.String)">
            <summary>
            Add a phrase to the language
            </summary>
        </member>
        <member name="M:Sandbox.Localization.PhraseCollection.GetPhrase(System.String)">
            <summary>
            Get a simple phrase from the language
            </summary>
        </member>
        <member name="M:Sandbox.Localization.PhraseCollection.GetPhrase(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Get a simple phrase from the language
            </summary>
        </member>
        <member name="T:Sandbox.Curve">
            <summary>
            Describes a curve, which can have multiple key frames.
            </summary>
        </member>
        <member name="P:Sandbox.Curve.TimeRange">
            <summary>
            The range of this curve. This affects looping.
            </summary>
        </member>
        <member name="P:Sandbox.Curve.ValueRange">
            <summary>
            The value range. This should affect nothing but what it looks like in the editor.
            </summary>
        </member>
        <member name="M:Sandbox.Curve.op_Implicit(System.Single)~Sandbox.Curve">
            <summary>
            A single float creates a flat curve
            </summary>
        </member>
        <member name="M:Sandbox.Curve.WithFrames(System.Collections.Immutable.ImmutableList{Sandbox.Curve.Frame})">
            <summary>
            Make a copy of this curve with changed keyframes
            </summary>
        </member>
        <member name="M:Sandbox.Curve.WithFrames(System.Collections.Generic.IEnumerable{Sandbox.Curve.Frame})">
            <summary>
            Make a copy of this curve with changed keyframes
            </summary>
        </member>
        <member name="T:Sandbox.Curve.Frame">
            <summary>
            Keyframes times and values should range between 0 and 1
            </summary>
        </member>
        <member name="P:Sandbox.Curve.Frame.Time">
            <summary>
            The delta position on the time line (0-1)
            </summary>
        </member>
        <member name="P:Sandbox.Curve.Frame.Value">
            <summary>
            The delta position on the value line (0-1)
            </summary>
        </member>
        <member name="P:Sandbox.Curve.Frame.In">
            <summary>
            This is the slope of entry, formula is something like tan( angle )
            </summary>
        </member>
        <member name="P:Sandbox.Curve.Frame.Out">
            <summary>
            This is the slope of exit, formula is something like tan( angle )
            </summary>
        </member>
        <member name="P:Sandbox.Curve.Frame.Mode">
            <summary>
            How the line should behave when entering/leaving this frame
            </summary>
        </member>
        <member name="T:Sandbox.Curve.HandleMode">
            <summary>
            Describes how the line should behave when entering/leaving a frame
            </summary>
        </member>
        <member name="F:Sandbox.Curve.HandleMode.Mirrored">
            <summary>
            The In and Out are user set, but are joined (mirrored)
            </summary>
        </member>
        <member name="F:Sandbox.Curve.HandleMode.Split">
            <summary>
            The In and Out are user set and operate independently
            </summary>
        </member>
        <member name="F:Sandbox.Curve.HandleMode.Flat">
            <summary>
            Curves are generated automatically
            </summary>
        </member>
        <member name="F:Sandbox.Curve.HandleMode.Linear">
            <summary>
            No curves, linear interpolation from this handle to the next
            </summary>
        </member>
        <member name="F:Sandbox.Curve.HandleMode.Stepped">
            <summary>
            No interpolation use raw values
            </summary>
        </member>
        <member name="F:Sandbox.Curve.Frames">
            <summary>
            A list of keyframes or points on the curve.
            </summary>
        </member>
        <member name="P:Sandbox.Curve.Length">
            <summary>
            Amount of key frames or points on the curve.
            </summary>
        </member>
        <member name="M:Sandbox.Curve.AddPoint(System.Single,System.Single)">
            <summary>
            Add a new keyframe at given position to this curve.
            </summary>
            <param name="x">Position of the keyframe on the X axis.</param>
            <param name="y">Position of the keyframe on the Y axis.</param>
            <returns>The position of newly added keyframe in the <see cref="F:Sandbox.Curve.Frames"/> list.</returns>
        </member>
        <member name="M:Sandbox.Curve.AddPoint(Sandbox.Curve.Frame@)">
            <summary>
            Add given keyframe to this curve.
            </summary>
            <param name="keyframe">The keyframe to add.</param>
            <returns>The position of newly added keyframe in the <see cref="F:Sandbox.Curve.Frames"/> list.</returns>
        </member>
        <member name="M:Sandbox.Curve.GetSurroundingFrames(System.Single)">
            <summary>
            Given a time, get the keyframes on either side of it, along with the delta of where we are between
            </summary>
        </member>
        <member name="M:Sandbox.Curve.Evaluate(System.Single)">
            <summary>
            Returns the value on the curve at given time position.
            </summary>
            <param name="time">The time point (x axis) at which </param>
            <returns>The absolute value at given time. (y axis)</returns>
        </member>
        <member name="M:Sandbox.Curve.EvaluateDelta(System.Single)">
            <summary>
            Like evaluate but takes a normalized time between 0 and 1 and returns a normalized value between 0 and 1
            </summary>
        </member>
        <member name="M:Sandbox.Curve.Fix">
            <summary>
            If the curve is broken in some way, we can fix it here.
            Ensures correct time and value ranges, and that the curve has at least one point.
            </summary>
        </member>
        <member name="T:Sandbox.CurveRange">
            <summary>
            Two curves
            </summary>
        </member>
        <member name="T:Sandbox.Frustum">
            <summary>
            Represents a <a href="https://en.wikipedia.org/wiki/Frustum">frustum</a>.
            </summary>
        </member>
        <member name="F:Sandbox.Frustum.RightPlane">
            <summary>
            Right plane of the frustum, pointing inwards.
            </summary>
        </member>
        <member name="F:Sandbox.Frustum.LeftPlane">
            <summary>
            Left plane of the frustum, pointing inwards.
            </summary>
        </member>
        <member name="F:Sandbox.Frustum.TopPlane">
            <summary>
            Top plane of the frustum, pointing inwards.
            </summary>
        </member>
        <member name="F:Sandbox.Frustum.BottomPlane">
            <summary>
            Bottom plane of the frustum, pointing inwards.
            </summary>
        </member>
        <member name="F:Sandbox.Frustum.NearPlane">
            <summary>
            Near plane of the frustum, pointing inwards.
            </summary>
        </member>
        <member name="F:Sandbox.Frustum.FarPlane">
            <summary>
            Far plane of the frustum, pointing inwards.
            </summary>
        </member>
        <member name="M:Sandbox.Frustum.GetCorner(System.Int32)">
            <summary>
            Returns the corner point of one of the 8 corners.
            This may return null if i is > 7 or the frustum is invalid.
            </summary>
        </member>
        <member name="M:Sandbox.Frustum.GetBBox">
            <summary>
            Returns the AABB of this frustum.
            </summary>
        </member>
        <member name="M:Sandbox.Frustum.IsInside(Vector3@)">
            <summary>
            Returns whether the given point is inside this frustum.
            </summary>
        </member>
        <member name="M:Sandbox.Frustum.IsInside(BBox@,System.Boolean)">
            <summary>
            Returns whether given AABB is inside this frustum.
            </summary>
            <param name="box">The AABB to test.</param>
            <param name="partially">Whether test for partial intersection, or complete encompassing of the AABB within this frustum.</param>
        </member>
        <member name="M:Sandbox.Frustum.FromCorners(Ray@,Ray@,Ray@,Ray@,System.Single,System.Single)">
            <summary>
            Create a frustum from four corner rays. These rays commonly come from SceneCamera.GetRay.
            </summary>
        </member>
        <member name="T:Sandbox.Gradient">
            <summary>
            Describes a gradient between multiple colors
            </summary>
        </member>
        <member name="P:Sandbox.Gradient.Blending">
            <summary>
            The blend mode
            </summary>
        </member>
        <member name="P:Sandbox.Gradient.Colors">
            <summary>
            A list of color stops, which should be ordered by time
            </summary>
        </member>
        <member name="P:Sandbox.Gradient.Alphas">
            <summary>
            A list of color stops, which should be ordered by time
            </summary>
        </member>
        <member name="M:Sandbox.Gradient.op_Implicit(Color)~Sandbox.Gradient">
            <summary>
            A single float creates a flat color
            </summary>
        </member>
        <member name="M:Sandbox.Gradient.WithFrames(System.Collections.Immutable.ImmutableList{Sandbox.Gradient.ColorFrame})">
            <summary>
            Make a copy of this with changed keyframes
            </summary>
        </member>
        <member name="T:Sandbox.Gradient.ColorFrame">
            <summary>
            Keyframes times and values should range between 0 and 1
            </summary>
        </member>
        <member name="T:Sandbox.Gradient.AlphaFrame">
            <summary>
            Keyframes times and values should range between 0 and 1
            </summary>
        </member>
        <member name="M:Sandbox.Gradient.AddColor(System.Single,Color@)">
            <summary>
            Add a color position
            </summary>
        </member>
        <member name="M:Sandbox.Gradient.AddAlpha(System.Single,System.Single)">
            <summary>
            Add an alpha position
            </summary>
        </member>
        <member name="M:Sandbox.Gradient.FixOrder">
            <summary>
            If the lists aren't in time order for some reason, this will fix them. This should really 
            just be called when serializing, and in every other situation we should assume they're
            okay.
            </summary>
        </member>
        <member name="M:Sandbox.Gradient.IsOrderedIncorrectly">
            <summary>
            Returns true if the lists are not in time order
            </summary>
        </member>
        <member name="M:Sandbox.Gradient.AddColor(Sandbox.Gradient.ColorFrame@)">
            <summary>
            Add given keyframe to this curve.
            </summary>
            <param name="keyframe">The keyframe to add.</param>
            <returns>The position of newly added keyframe in the <see cref="P:Sandbox.Gradient.Colors"/> list.</returns>
        </member>
        <member name="M:Sandbox.Gradient.GetSurroundingColors(System.Single)">
            <summary>
            Given a time, get the keyframes on either side of it, along with the delta of where we are between
            </summary>
        </member>
        <member name="M:Sandbox.Gradient.GetSurroundingAlphas(System.Single)">
            <summary>
            Given a time, get the keyframes on either side of it, along with the delta of where we are between
            </summary>
        </member>
        <member name="T:Sandbox.Gradient.BlendMode">
            <summary>
            Describes how the line should behave when entering/leaving a frame
            </summary>
        </member>
        <member name="F:Sandbox.Gradient.BlendMode.Linear">
            <summary>
            Linear interoplation between
            </summary>
        </member>
        <member name="F:Sandbox.Gradient.BlendMode.Stepped">
            <summary>
            No interpolation use last raw value
            </summary>
        </member>
        <member name="M:Sandbox.Gradient.Evaluate(System.Single)">
            <summary>
            Evaluate the blend using the time, which is generally between 0 and 1
            </summary>
        </member>
        <member name="T:Sandbox.Interpolation.InterpolationBuffer`1">
            <summary>
            Contains information in a buffer for interpolation.
            </summary>
        </member>
        <member name="P:Sandbox.Interpolation.InterpolationBuffer`1.IsEmpty">
            <summary>
            Is the buffer currently empty?
            </summary>
        </member>
        <member name="P:Sandbox.Interpolation.InterpolationBuffer`1.Count">
            <summary>
            How many entries are in the buffer?
            </summary>
        </member>
        <member name="P:Sandbox.Interpolation.InterpolationBuffer`1.First">
            <summary>
            The first entry in the buffer.
            </summary>
        </member>
        <member name="P:Sandbox.Interpolation.InterpolationBuffer`1.Last">
            <summary>
            The last entry in the buffer.
            </summary>
        </member>
        <member name="M:Sandbox.Interpolation.InterpolationBuffer`1.Query(System.Single,System.Single)">
            <summary>
            Query the interpolation buffer for a specific time.
            </summary>
            <param name="now">The time you want to query (usually now.)</param>
            <param name="interpolationTime">The time it should take to interpolate between each state.</param>
            <exception cref="T:System.InvalidOperationException">Throws if there are no snapshots in the interpolation buffer.</exception>
        </member>
        <member name="M:Sandbox.Interpolation.InterpolationBuffer`1.Add(`0,System.Single)">
            <summary>
            Add a new state to the buffer at the specified time.
            </summary>
        </member>
        <member name="M:Sandbox.Interpolation.InterpolationBuffer`1.Clear">
            <summary>
            Clear the interpolation buffer.
            </summary>
        </member>
        <member name="M:Sandbox.Interpolation.InterpolationBuffer`1.CullOlderThan(System.Single)">
            <summary>
            Cull entries in the buffer older than the specified time.
            </summary>
        </member>
        <member name="T:Sandbox.Interpolation.RotationState">
            <summary>
            State information about a <see cref="F:Sandbox.Interpolation.RotationState.Rotation"/>. Used for interpolation buffer.
            </summary>
        </member>
        <member name="T:Sandbox.Interpolation.TransformState">
            <summary>
            State information about a transform. Used for interpolation buffer.
            </summary>
        </member>
        <member name="T:Sandbox.Interpolation.Vector3State">
            <summary>
            State information about a <see cref="T:Vector3"/>. Used for interpolation buffer.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Length">
            <summary>
            A variable unit based length. ie, could be a percentage or a pixel length. This is commonly used to express the size of things in UI space, usually coming from style sheets.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Length.Value">
            <summary>
            The meaning of the value is dependent on <see cref="F:Sandbox.UI.Length.Unit"/>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Length.Unit">
            <summary>
            How to determine the final length. Commonly used with Pixel or Percentage.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Length.RootSize">
            <summary>
            The current root panel size. This is required for vh, vw, vmin and vmax. This is set during PreLayout, Layout and PostLayout.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Length.RootFontSize">
            <summary>
            The current root panel font size. This is required for rem. This is set during PreLayout, Layout and PostLayout.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Length.CurrentFontSize">
            <summary>
            The current panel font size. This is required for em. This is set during PreLayout.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Length._expression">
            <summary>
            If the length unit is Expression, this will represent the calc() expression parsed
            </summary>
        </member>
        <member name="M:Sandbox.UI.Length.GetPixels(System.Single)">
            <summary>
            Convert to a pixel value. Use the dimension to work out percentage values.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Length.GetPixels(System.Single,System.Single)">
            <summary>
            Get the pixel size but also evaluate content size to support use Start, End, Center
            </summary>
        </member>
        <member name="M:Sandbox.UI.Length.Lerp(Sandbox.UI.Length,Sandbox.UI.Length,System.Single,System.Single)">
            <summary>
            Lerp from one length to another.
            </summary>
            <param name="a">Length at delta 0</param>
            <param name="b">Length at delta 1</param>
            <param name="delta">The interpolation stage</param>
            <param name="dimension">The width or height of the parent to use when working out percentage lengths</param>
            <returns>The interpolated Length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.Lerp(Sandbox.UI.Length,Sandbox.UI.Length,System.Single,System.Single,System.Single)">
            <summary>
            Lerp from one length to another.
            </summary>
            <param name="a">Length at delta 0</param>
            <param name="b">Length at delta 1</param>
            <param name="delta">The interpolation stage</param>
            <param name="dimension">The width or height of the parent to use when working out percentage lengths</param>
            <param name="contentSize">Evaluate content size to support use Start, End, Center</param>
            <returns>The interpolated Length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.Lerp(Sandbox.UI.Length,Sandbox.UI.Length,System.Single)">
            <summary>
            Lerp from one length to another.
            </summary>
            <param name="a">Length at delta 0</param>
            <param name="b">Length at delta 1</param>
            <param name="delta">The interpolation stage</param>
            <returns>The interpolated Length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.Pixels(System.Single)">
            <summary>
            Create a length in pixels
            </summary>
            <param name="pixels">The amount of pixels for this length</param>
            <returns>A new length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.Percent(System.Single)">
            <summary>
            Create a length in percents
            </summary>
            <param name="percent">The amount of percent for this (0-100)</param>
            <returns>A new length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.ViewHeight(System.Single)">
            <summary>
            Create a length based on the view height
            </summary>
            <param name="percentage">The amount of percent for this (0-100)</param>
            <returns>A new length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.ViewWidth(System.Single)">
            <summary>
            Create a length based on the view width
            </summary>
            <param name="percentage">The amount of percent for this (0-100)</param>
            <returns>A new length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.ViewMax(System.Single)">
            <summary>
            Create a length based on the longest edge of the screen size
            </summary>
            <param name="percentage">The amount of percent for this (0-100)</param>
            <returns>A new length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.ViewMin(System.Single)">
            <summary>
            Create a length based on the shortest edge of the screen size
            </summary>
            <param name="percentage">The amount of percent for this (0-100)</param>
            <returns>A new length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.Fraction(System.Single)">
            <summary>
            Create a length in percents
            </summary>
            <param name="fraction">The fraction of a percent (0 = 0%, 1 = 100%)</param>
            <returns>A new length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.Calc(System.String)">
            <summary>
            Create a length based on a css calc expression
            </summary>
        </member>
        <member name="M:Sandbox.UI.Length.Rem(System.Single)">
            <summary>
            Create a length based on the font size of the root element.
            </summary>
            <param name="value">Value in rem</param>
            <returns>A new length</returns>
        </member>
        <member name="M:Sandbox.UI.Length.Em(System.Single)">
            <summary>
            Create a length based on the font size of the current element.
            </summary>
            <param name="value">Value in em</param>
            <returns>A new length</returns>
        </member>
        <member name="P:Sandbox.UI.Length.Auto">
            <summary>
            Quickly create a Length with Unit set to LengthUnit.Auto
            </summary>
        </member>
        <member name="P:Sandbox.UI.Length.Contain">
            <summary>
            Quickly create a Length with Unit set to LengthUnit.Contain
            </summary>
        </member>
        <member name="P:Sandbox.UI.Length.Cover">
            <summary>
            Quickly create a Length with Unit set to LengthUnit.Cover
            </summary>
        </member>
        <member name="M:Sandbox.UI.Length.Parse(System.String)">
            <summary>
            Parse a length. This is used by the stylesheet parsing system.
            </summary>
            <param name="value">A length represented by a string</param>
            <example>Length.Parse( "100px" )</example>
            <example>Length.Parse( "56%" )</example>
            <returns></returns>
        </member>
        <member name="M:Sandbox.UI.Length.GetFraction(System.Single)">
            <summary>
            If it's a %, will return 0-1. If not it'll return its value.
            </summary>
        </member>
        <member name="T:Sandbox.UI.LengthUnit">
            <summary>
            Possible units for various CSS properties that require length, used by <see cref="T:Sandbox.UI.Length"/> struct.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Auto">
            <summary>
            The layout engine will calculate and select a width for the specified element.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Pixels">
            <summary>
            The length is in pixels.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Percentage">
            <summary>
            The length is a percentage (0-100) of the parent's length. (typically)
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.ViewHeight">
            <summary>
            The length is a percentage (0-100) of the viewport's height.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.ViewWidth">
            <summary>
            The length is a percentage (0-100) of the viewport's width.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.ViewMin">
            <summary>
            The length is a percentage (0-100) of the viewport's smallest side/edge.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.ViewMax">
            <summary>
            The length is a percentage (0-100) of the viewport's largest side/edge.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Start">
            <summary>
            Start of the parent at the appropriate axis.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Cover">
            <summary>
            For background images, cover the entire element with the image, stretcing and cropping as necessary.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Contain">
            <summary>
            For background images, contain the image within the element bounds.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.End">
            <summary>
            End of the parent at the appropriate axis.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Center">
            <summary>
            In the middle of the parent at the appropriate axis.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Undefined">
            <summary>
            Similar to CSS 'unset', basically means we don't have a value; should only really be used under certain
            circumstances (e.g. to handle background sizing properly).
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Expression">
            <summary>
            Represents a calc( ... ) expression
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.RootEm">
            <summary>
            Font size of the root element.
            </summary>
        </member>
        <member name="F:Sandbox.UI.LengthUnit.Em">
            <summary>
            Font size of the current element.
            </summary>
        </member>
        <member name="M:Sandbox.UI.LengthUnitExtension.IsDynamic(Sandbox.UI.LengthUnit)">
            <summary>
            Determine whether this unit type is dynamic (ie. should be updated regularly) or whether it's constant
            </summary>
        </member>
        <member name="T:Sandbox.UI.Margin">
            <summary>
            Represents a <see cref="T:Sandbox.Rect">Rect</see> where each side is the thickness of an edge/padding/margin/border, rather than positions.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Margin.Width">
            <summary>
            Width of the inner square contained within the margin.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Margin.Height">
            <summary>
            Height of the inner square contained within the margin.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Margin.Left">
            <summary>
            Thickness of the left side margin.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Margin.Top">
            <summary>
            Thickness of the top margin.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Margin.Right">
            <summary>
            Thickness of the right side margin.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Margin.Bottom">
            <summary>
            Thickness of the bottom margin.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Margin.Position">
            <summary>
            Position of the inner top left corder of the margin/border.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Margin.Size">
            <summary>
            Size of the inner square contained within the margin.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Margin.GetEdges(Vector2@,System.Nullable{Sandbox.UI.Length}@,System.Nullable{Sandbox.UI.Length}@,System.Nullable{Sandbox.UI.Length}@,System.Nullable{Sandbox.UI.Length}@)">
            <summary>
            Returns a Rect where left right top bottom describe the size of an edge.
            This is used for things like margin, padding, border size.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Margin.EdgeSize">
            <summary>
            When the Rect describes edges, this returns the total size of the edges in each direction
            </summary>
        </member>
        <member name="M:Sandbox.UI.Margin.EdgeAdd(Sandbox.UI.Margin)">
            <summary>
            Where padding is an edge type rect, will return this rect expanded with those edges.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Margin.EdgeSubtract(Sandbox.UI.Margin)">
            <summary>
            Where padding is an edge type rect, will return this rect expanded with those edges.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Calc.HasHigherPrecedence(Sandbox.UI.Calc.TokenType,Sandbox.UI.Calc.TokenType)">
            <summary>
            Determine which token has higher precedence over another
            </summary>
        </member>
        <member name="M:Sandbox.UI.Calc.ProcessOperation(System.Collections.Generic.Stack{Sandbox.UI.Calc.TreeNode},Sandbox.UI.Calc.TokenType,System.Single)">
            <summary>
            Process a bunch of tree nodes
            </summary>
        </member>
        <member name="M:Sandbox.UI.Calc.Evaluate(System.String,System.Single)">
            <summary>
            Evaluate a full CSS calc expression and return the calculated value.
            </summary>
        </member>
        <member name="T:Sandbox.UI.CascadingParameterAttribute">
            <summary>
            A panel's property will be inherited from its parent.
            </summary>
        </member>
        <member name="T:Sandbox.UI.IStyleBlock">
            <summary>
            A CSS rule - ie ".chin { width: 100%; height: 100%; }"
            </summary>
        </member>
        <member name="P:Sandbox.UI.IStyleBlock.FileName">
            <summary>
            The filename of the file containing this style block (or null if none)
            </summary>
        </member>
        <member name="P:Sandbox.UI.IStyleBlock.AbsolutePath">
            <summary>
            The absolute on disk filename for this style block (or null if not on disk)
            </summary>
        </member>
        <member name="P:Sandbox.UI.IStyleBlock.FileLine">
            <summary>
            The line in the file containing this style block
            </summary>
        </member>
        <member name="P:Sandbox.UI.IStyleBlock.SelectorStrings">
            <summary>
            A list of selectors
            </summary>
        </member>
        <member name="M:Sandbox.UI.IStyleBlock.GetRawValues">
            <summary>
            Get the list of raw style values
            </summary>
        </member>
        <member name="M:Sandbox.UI.IStyleBlock.SetRawValue(System.String,System.String,System.String)">
            <summary>
            Update a raw style value
            </summary>
        </member>
        <member name="P:Sandbox.UI.IStyleBlock.StyleProperty.Name">
            <summary>
            Name of the property, ie "color" or "width"
            </summary>
        </member>
        <member name="P:Sandbox.UI.IStyleBlock.StyleProperty.Value">
            <summary>
            Current value of the property (which is being rendered)
            </summary>
        </member>
        <member name="P:Sandbox.UI.IStyleBlock.StyleProperty.OriginalValue">
            <summary>
            The value that was loaded from the .scss file
            </summary>
        </member>
        <member name="P:Sandbox.UI.IStyleBlock.StyleProperty.Line">
            <summary>
            The line in the file containing this value
            </summary>
        </member>
        <member name="T:Sandbox.UI.PseudoClass">
            <summary>
            List of CSS pseudo-classes used by the styling system for hover, active, etc.
            This acts as a bit-flag.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.None">
            <summary>
            No pseudo-class.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.Unknown">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.Hover">
            <summary>
            <c>:hover</c> - Any element with the mouse cursor hovering over it.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.Active">
            <summary>
            <c>:active</c> - A button that is being pressed down.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.Focus">
            <summary>
            <c>:focus</c> - An element with input focus.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.Intro">
            <summary>
            <c>:intro</c> - Present on all elements for their first frame. Useful to start CSS transitions on creation.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.Outro">
            <summary>
            <c>:outro</c> - The element has been marked for deletion, and will be deleted once all CSS transitions on it has stopped.<br/>
            Transitions can be started here to gracefully remove the element visually.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.Empty">
            <summary>
            <c>:empty</c> - Any element that has no children.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.FirstChild">
            <summary>
            <c>:first-child</c> - The element is the first element among a group of sibling elements.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.LastChild">
            <summary>
            <c>:last-child</c> - The element is the last element among a group of sibling elements.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PseudoClass.OnlyChild">
            <summary>
            <c>:only-child</c> - The element is the only child of their parent element.
            </summary>
        </member>
        <member name="T:Sandbox.UI.RenderState">
            <summary>
            Describes panel's position and size for rendering operations.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RenderState.X">
            <summary>
            Position of the panel on the X axis. This can be a negative value!
            </summary>
        </member>
        <member name="P:Sandbox.UI.RenderState.Y">
            <summary>
            Position of the panel on the Y axis. This can be a negative value!
            </summary>
        </member>
        <member name="P:Sandbox.UI.RenderState.Width">
            <summary>
            Width of the panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RenderState.Height">
            <summary>
            Height of the panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RenderState.RenderOpacity">
            <summary>
            Render Opacity Overrides
            </summary>
        </member>
        <member name="M:Sandbox.UI.RenderState.op_Implicit(Sandbox.UI.RenderState)~Sandbox.Rect">
            <summary>
            Allows easy cast to a <see cref="T:Sandbox.Rect"/> for usage in rendering functions.
            </summary>
        </member>
        <member name="T:Sandbox.UI.StyleSheetAttribute">
            <summary>
            Will automatically apply the named stylesheet to the Panel.
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleSheetAttribute.Name">
            <summary>
            File name of the style sheet file.
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelTransform.IsEmpty">
            <summary>
            Returns true if this is empty.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Shadow">
            <summary>
            Shadow style settings
            </summary>
        </member>
        <member name="F:Sandbox.UI.Shadow.OffsetX">
            <summary>
            Shadow offset on the X axis.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Shadow.OffsetY">
            <summary>
            Shadow offset on the Y axis.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Shadow.Blur">
            <summary>
            Amount of blurring for the shadow.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Shadow.Spread">
            <summary>
            Increases the box size by this much before starting shadow blur.
            Box shadows only.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Shadow.Inset">
            <summary>
            Whether or not this shadow is inset.
            Box shadows only.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Shadow.Color">
            <summary>
            Color of the shadow.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Shadow.Scale(System.Single)">
            <summary>
            Scale all variables by given scalar.
            </summary>
            <param name="f">How much to scale the shadow parameters by. 1 is no change, 2 is double the sizes, etc.</param>
            <returns>The scaled shadow.</returns>
        </member>
        <member name="M:Sandbox.UI.Shadow.LerpTo(Sandbox.UI.Shadow,System.Single)">
            <summary>
            Perform linear interpolation between 2 shadows.
            </summary>
            <param name="shadow">The target shadow to morph into.</param>
            <param name="delta">Progress of the transformation. 0 = original shadow, 1 = fully target shadow.</param>
            <returns>The interpolated shadow.</returns>
        </member>
        <member name="T:Sandbox.UI.ShadowList">
            <summary>
            A list of shadows 
            </summary>
        </member>
        <member name="F:Sandbox.UI.ShadowList.IsNone">
            <summary>
            Whether there are no shadows at all.
            </summary>
        </member>
        <member name="M:Sandbox.UI.ShadowList.AddFrom(Sandbox.UI.ShadowList)">
            <summary>
            Copy shadows from another list of shadows.
            </summary>
        </member>
        <member name="M:Sandbox.UI.ShadowList.SetFromLerp(Sandbox.UI.ShadowList,Sandbox.UI.ShadowList,System.Single)">
            <summary>
            Given 2 lists of shadows, perform linear interpolation on both lists and store the result in this list.
            Will work with mismatched shadow counts.
            </summary>
            <param name="a">The first list of shadows.</param>
            <param name="b">The second list of shadows.</param>
            <param name="frac">Fraction for the linear interpolation, in range of [0,1]</param>
            <exception cref="T:System.ArgumentException">Thrown when both inputs are equal.</exception>
        </member>
        <member name="T:Sandbox.UI.OverflowMode">
            <summary>
            Possible values for the "overflow" CSS rule, dictating what to do with content that is outside of a panels bounds.
            </summary>
        </member>
        <member name="F:Sandbox.UI.OverflowMode.Visible">
            <summary>
            Overflowing content is visible at all times.
            </summary>
        </member>
        <member name="F:Sandbox.UI.OverflowMode.Hidden">
            <summary>
            Overflowing contents are hidden at all times.
            </summary>
        </member>
        <member name="F:Sandbox.UI.OverflowMode.Scroll">
            <summary>
            Overflowing contents are hidden, but can be scrolled to.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Align">
            <summary>
            Possible values for <c>align-items</c> CSS property.
            </summary>
        </member>
        <member name="T:Sandbox.UI.PositionMode">
            <summary>
            Possible values for <c>position</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PositionMode.Static">
            <summary>
            Default, the <c>top</c>, <c>right</c>, <c>bottom</c>, <c>left</c>, and <c>z-index</c> properties have no effect.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PositionMode.Relative">
            <summary>
            Enables <c>top</c>, <c>right</c>, <c>bottom</c>, <c>left</c>, and <c>z-index</c> to offset the element from its
            would-be position with <see cref="F:Sandbox.UI.PositionMode.Static"/>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PositionMode.Absolute">
            <summary>
            Same as <see cref="F:Sandbox.UI.PositionMode.Relative"/>, but the elements size does not affect other elements at all.
            </summary>
        </member>
        <member name="T:Sandbox.UI.FlexDirection">
            <summary>
            Possible values for <c>flex-direction</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.FlexDirection.Column">
            <summary>
            A column, align items from top to bottom.
            </summary>
        </member>
        <member name="F:Sandbox.UI.FlexDirection.ColumnReverse">
            <summary>
            A reverse column, align items from bottom to top.
            </summary>
        </member>
        <member name="F:Sandbox.UI.FlexDirection.Row">
            <summary>
            A row, align items from left to right.
            </summary>
        </member>
        <member name="F:Sandbox.UI.FlexDirection.RowReverse">
            <summary>
            A reverse row, align items from right to left.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Justify">
            <summary>
            Possible values for <c>justify-content</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.FlexStart">
            <summary>
            [OOOO            ]
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.Center">
            <summary>
            [      OOOO      ]
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.FlexEnd">
            <summary>
            [            OOOO]
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.SpaceBetween">
            <summary>
            [O    O    O    O]
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.SpaceAround">
            <summary>
            [ O   O   O   O ]
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.SpaceEvenly">
            <summary>
            [  O  O  O  O  ]
            </summary>
        </member>
        <member name="T:Sandbox.UI.DisplayMode">
            <summary>
            Possible values for <c>display</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.DisplayMode.Flex">
            <summary>
            Display via CSS flexbox.
            </summary>
        </member>
        <member name="F:Sandbox.UI.DisplayMode.None">
            <summary>
            Do not display at all.
            </summary>
        </member>
        <member name="T:Sandbox.UI.PointerEvents">
            <summary>
            Possible values for <c>pointer-events</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PointerEvents.All">
            <summary>
            Accept all events in all cases.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PointerEvents.None">
            <summary>
            Do not accept any pointer events.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Wrap">
            <summary>
            Possible values for <c>flex-wrap</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Wrap.NoWrap">
            <summary>
            Elements will be laid out in a single line.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Wrap.Wrap">
            <summary>
            Elements will be moved to subsequent lines on overflow.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Wrap.WrapReverse">
            <summary>
            Same as <see cref="F:Sandbox.UI.Wrap.Wrap"/>, but the line order will be reversed, i.e. if one item overflows the width,
            it will be placed on the first line, and the others will be placed on the second line.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TextAlign">
            <summary>
            Possible values for <c>text-align</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextAlign.Auto">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextAlign.Left">
            <summary>
            Align the text to the left.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextAlign.Center">
            <summary>
            Align the text to the horizontal center.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextAlign.Right">
            <summary>
            Align the text to the right.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TextOverflow">
            <summary>
            Possible values for <c>text-overflow</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextOverflow.None">
            <summary>
            Display overflown text.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextOverflow.Ellipsis">
            <summary>
            Replace part of the text near the overflow point with ellipsis, and cut off the rest.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextOverflow.Clip">
            <summary>
            Visually cut off the overflowing text.
            </summary>
        </member>
        <member name="T:Sandbox.UI.WordBreak">
            <summary>
            Possible values for <c>word-break</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.WordBreak.Normal">
            <summary>
            Break overflowing lines at the closest word.
            </summary>
        </member>
        <member name="F:Sandbox.UI.WordBreak.BreakAll">
            <summary>
            Break overflowing lines at the closest character.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TextTransform">
            <summary>
            Possible values for <c>text-transform</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextTransform.None">
            <summary>
            No change, default.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextTransform.Capitalize">
            <summary>
            Capitalize each word.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextTransform.Uppercase">
            <summary>
            Make every character capital.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextTransform.Lowercase">
            <summary>
            Make every character lowercase.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TextSkipInk">
            <summary>
            Possible values for <c>text-decoration-skip-ink</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextSkipInk.All">
            <summary>
            Don't overlap any glyphs.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextSkipInk.None">
            <summary>
            Overlap all glyphs.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TextDecorationStyle">
            <summary>
            Possible values for <c>text-decoration-style</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Solid">
            <summary>
            Draw a single solid line.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Double">
            <summary>
            Draw two solid lines.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Dotted">
            <summary>
            Draw a dotted line.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Dashed">
            <summary>
            Draw a dashed line.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Wavy">
            <summary>
            Draw a wavy/squiggly line.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TextDecoration">
            <summary>
            Possible values for <c>text-decoration</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecoration.None">
            <summary>
            No decoration, default.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecoration.Underline">
            <summary>
            Underline the text.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecoration.LineThrough">
            <summary>
            Strike through, a line in the middle of the text.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecoration.Overline">
            <summary>
            A line above the text.
            </summary>
        </member>
        <member name="T:Sandbox.UI.WhiteSpace">
            <summary>
            Possible values for <c>white-space</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.WhiteSpace.Normal">
            <summary>
            Sequences of white spaces are collapsed, text will wrap when necessary.  Default.
            </summary>
        </member>
        <member name="F:Sandbox.UI.WhiteSpace.NoWrap">
            <summary>
            Sequences of white spaces are collapsed and linebreaks are suppressed.
            </summary>
        </member>
        <member name="F:Sandbox.UI.WhiteSpace.PreLine">
            <summary>
            Sequences of white spaces are collapsed, text will wrap when necessary, linebreaks are preserved.
            </summary>
        </member>
        <member name="F:Sandbox.UI.WhiteSpace.Pre">
            <summary>
            Sequences of white space are preserved, lines are only broken at newline characters in the source.
            </summary>
        </member>
        <member name="T:Sandbox.UI.FontStyle">
            <summary>
            Possible values for <c>font-style</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.FontStyle.None">
            <summary>
            No font styling, default.
            </summary>
        </member>
        <member name="F:Sandbox.UI.FontStyle.Italic">
            <summary>
            Italic/cursive slanted text.
            </summary>
        </member>
        <member name="F:Sandbox.UI.FontStyle.Oblique">
            <summary>
            Non cursive slanted text, if the font supports it, italic otherwise.
            </summary>
        </member>
        <member name="T:Sandbox.UI.ImageRendering">
            <summary>
            Possible values for <c>image-rendering</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.ImageRendering.Anisotropic">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Anisotropic_filtering">Anisotropic</a> filtering.
            </summary>
        </member>
        <member name="F:Sandbox.UI.ImageRendering.Bilinear">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Bilinear_interpolation">Anisotropic</a> interpolation/filtering.
            </summary>
        </member>
        <member name="F:Sandbox.UI.ImageRendering.Trilinear">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Trilinear_filtering">Trilinear</a> filtering.
            </summary>
        </member>
        <member name="F:Sandbox.UI.ImageRendering.Point">
            <summary>
            No filtering.
            </summary>
        </member>
        <member name="T:Sandbox.UI.BorderImageFill">
            <summary>
            State of <c>fill</c> setting of <c>border-image-slice</c> (<c>border-image</c>) CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.BorderImageFill.Unfilled">
            <summary>
            Do not fill the middle of the container with the border's background image.
            </summary>
        </member>
        <member name="F:Sandbox.UI.BorderImageFill.Filled">
            <summary>
            Do fill the middle of the container with the border's background image.
            </summary>
        </member>
        <member name="T:Sandbox.UI.BorderImageRepeat">
            <summary>
            Possible values for <c>border-image-repeat</c> (<c>border-image</c>) CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.BorderImageRepeat.Stretch">
            <summary>
            The source image's edge regions are stretched to fill the gap between each border.
            </summary>
        </member>
        <member name="F:Sandbox.UI.BorderImageRepeat.Round">
            <summary>
            The source image's edge regions are tiled (repeated) to fill the gap between each border. Tiles may be stretched to achieve the proper fit.
            </summary>
        </member>
        <member name="T:Sandbox.UI.BackgroundRepeat">
            <summary>
            Possible values for <c>background-repeat</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.BackgroundRepeat.Repeat">
            <summary>
            Repeat the background image on X and Y axises.
            </summary>
        </member>
        <member name="F:Sandbox.UI.BackgroundRepeat.RepeatX">
            <summary>
            Repeat the background image on X axis.
            </summary>
        </member>
        <member name="F:Sandbox.UI.BackgroundRepeat.RepeatY">
            <summary>
            Repeat the background image on Y axis.
            </summary>
        </member>
        <member name="F:Sandbox.UI.BackgroundRepeat.NoRepeat">
            <summary>
            Do not repeat the background image.
            </summary>
        </member>
        <member name="F:Sandbox.UI.BackgroundRepeat.Clamp">
            <summary>
            Stretch the edges of the image to fill empty space.
            </summary>
        </member>
        <member name="T:Sandbox.UI.MaskMode">
            <summary>
            Possible values for <c>mask-mode</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.MaskMode.MatchSource">
            <summary>
            If the mask-image property is of type 'mask-source', the luminance values of the mask layer image should be used as the mask values.
            If it is of type 'image', the alpha values of the mask layer image should be used as the mask values.
            </summary>
        </member>
        <member name="F:Sandbox.UI.MaskMode.Alpha">
            <summary>
            The alpha channel values of the mask layer image should be used as the mask values.
            </summary>
        </member>
        <member name="F:Sandbox.UI.MaskMode.Luminance">
            <summary>
            The luminance values of the mask layer image should be used as the mask values.
            </summary>
        </member>
        <member name="T:Sandbox.UI.MaskScope">
            <summary>
            Possible values for <c>mask-scope</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.MaskScope.Default">
            <summary>
            Standard mask.
            </summary>
        </member>
        <member name="F:Sandbox.UI.MaskScope.Filter">
            <summary>
            Mask used for filters.
            </summary>
        </member>
        <member name="T:Sandbox.UI.FontSmooth">
            <summary>
            Possible values for <c>font-smooth</c> CSS property.
            </summary>
        </member>
        <member name="F:Sandbox.UI.FontSmooth.Auto">
            <summary>
            Let us decide (we'll anti-alias where available)
            </summary>
        </member>
        <member name="F:Sandbox.UI.FontSmooth.Never">
            <summary>
            Turn font smoothing off
            </summary>
        </member>
        <member name="F:Sandbox.UI.FontSmooth.Always">
            <summary>
            Always anti-alias
            </summary>
        </member>
        <member name="M:Sandbox.Line2D.Clip(Sandbox.Rect)">
            <summary>
            Returns this line, clamped within a rectangle. Null if line is fully
            outside the rectangle.
            </summary>
        </member>
        <member name="M:Sandbox.Line2D.Clip(Vector2,System.Single)">
            <summary>
            Returns this line, clamped on the positive side of a half-plane. Null if
            line is fully clipped.
            </summary>
        </member>
        <member name="M:Sandbox.Line2D.Remap(Sandbox.Rect,Sandbox.Rect)">
            <summary>
            Remaps from one range to another.
            </summary>
        </member>
        <member name="M:Sandbox.Line2D.RemapClip(Sandbox.Rect,Sandbox.Rect)">
            <summary>
            Remaps from one range to another, clipping along the way.
            </summary>
        </member>
        <member name="M:Sandbox.Line2D.ClosestPoint(Vector2)">
            <summary>
            Returns closest point on this line to the given point.
            </summary>
        </member>
        <member name="M:Sandbox.Line2D.Distance(Vector2)">
            <summary>
            Returns closest distance from this line to given point.
            </summary>
        </member>
        <member name="M:Sandbox.Line2D.Distance(Vector2,Vector2@)">
            <summary>
            Returns closest distance from this line to given point.
            </summary>
        </member>
        <member name="M:Sandbox.Line2D.WithLength(System.Single,System.Single)">
            <summary>
            Returns a line along the same tangent with the given length.
            </summary>
        </member>
        <member name="T:Sandbox.Plane">
            <summary>
            Represents a plane.
            </summary>
        </member>
        <member name="F:Sandbox.Plane.Normal">
            <summary>
            The direction of the plane.
            </summary>
        </member>
        <member name="F:Sandbox.Plane.Distance">
            <summary>
            Distance of the plane from world origin in the direction given by <see cref="F:Sandbox.Plane.Normal"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Plane.#ctor(Vector3@,Vector3@,Vector3@)">
            <summary>
            Creates a new plane from 3 given positions.
            </summary>
            <param name="origin">Origin of the plane.</param>
            <param name="posA">A position to calculate a normal with.</param>
            <param name="posB">Another position to calculate a normal with.</param>
        </member>
        <member name="P:Sandbox.Plane.Origin">
            <summary>
            Origin position of the plane, basically a vector <see cref="F:Sandbox.Plane.Distance"/> away from world origin in the direction given by <see cref="F:Sandbox.Plane.Normal"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Plane.Position">
            <summary>
            Origin position of the plane, basically a vector <see cref="F:Sandbox.Plane.Distance"/> away from world origin in the direction given by <see cref="F:Sandbox.Plane.Normal"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Plane.GetDistance(Vector3@)">
            <summary>
            Returns the distance from this plane to given point.
            </summary>
        </member>
        <member name="M:Sandbox.Plane.IsInFront(Vector3)">
            <summary>
            Returns true if given point is on the side of the plane where its normal is pointing.
            </summary>
        </member>
        <member name="M:Sandbox.Plane.IsInFront(BBox,System.Boolean)">
            <summary>
            Returns true if given bounding box is on the side of the plane where its normal is pointing.
            </summary>
        </member>
        <member name="M:Sandbox.Plane.SnapToPlane(Vector3@)">
            <summary>
            Returns closest point on the plane to given point.
            </summary>
        </member>
        <member name="M:Sandbox.Plane.TryTrace(Ray@,Vector3@,System.Boolean,System.Double)">
            <summary>
            Trace a Ray against this plane
            </summary>
        </member>
        <member name="M:Sandbox.Plane.Trace(Ray@,System.Boolean,System.Double)">
            <summary>
            Trace a Ray against this plane
            </summary>
            <param name="ray">The origin and direction to trace from</param>
            <param name="twosided">If true we'll trace against the underside of the plane too.</param>
            <param name="maxDistance">The maximum distance from the ray origin to trace</param>
            <returns>The hit position on the ray. Or null if we didn't hit.</returns>
        </member>
        <member name="M:Sandbox.Plane.GetIntersection(Sandbox.Plane@,Sandbox.Plane@,Sandbox.Plane@)">
            <summary>
            Gets the intersecting point of the three planes if it exists.
            If the planes don't all intersect will return null.
            </summary>
        </member>
        <member name="T:Sandbox.Rect">
            <summary>
            Represents a rectangle.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.#ctor(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Initialize a Rect at given position and with given size.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.#ctor(Vector2@,Vector2@)">
            <summary>
            Initialize a Rect at given position and with given size.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.Width">
            <summary>
            Width of the rect.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.Height">
            <summary>
            Height of the rect.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.Left">
            <summary>
            Position of rect's left edge relative to its parent, can also be interpreted as its position on the X axis.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.Top">
            <summary>
            Position of rect's top edge relative to its parent, can also be interpreted as its position on the Y axis.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.Right">
            <summary>
            Position of rect's right edge relative to its parent.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.Bottom">
            <summary>
            Position of rect's bottom edge relative to its parent.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.Position">
            <summary>
            Position of this rect.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.Center">
            <summary>
            Center of this rect.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.Size">
            <summary>
            Size of this rect.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.WithoutPosition">
            <summary>
            Returns this rect with position set to 0 on both axes.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.IsInside(Sandbox.Rect@,System.Boolean)">
            <summary>
            Return true if the passed rect is partially or fully inside this rect.
            </summary>
            <param name="rect">The passed rect to test.</param>
            <param name="fullyInside"><see langword="true"/> to test if the given rect is completely inside this rect. <see langword="false"/> to test for an intersection.</param>
        </member>
        <member name="M:Sandbox.Rect.IsInside(Vector2@)">
            <summary>
            Return true if the passed point is inside this rect.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Shrink(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Returns a Rect shrunk in every direction by given values.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Shrink(Sandbox.UI.Margin@)">
            <summary>
            Returns a Rect shrunk in every direction by <see cref="T:Sandbox.UI.Margin">Margin</see>'s values.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Shrink(System.Single@,System.Single@)">
            <summary>
            Returns a Rect shrunk in every direction by given values on each axis.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Shrink(System.Single@)">
            <summary>
            Returns a Rect shrunk in every direction by given amount.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Grow(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Returns a Rect grown in every direction by given amounts.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Grow(Sandbox.UI.Margin)">
            <summary>
            Returns a Rect grown in every direction by <see cref="T:Sandbox.UI.Margin">Margin</see>'s values.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Grow(System.Single@,System.Single@)">
            <summary>
            Returns a Rect grown in every direction by given values on each axis.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Grow(System.Single@)">
            <summary>
            Returns a Rect grown in every direction by given amount.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Floor">
            <summary>
            Returns a Rect with position and size rounded down.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Round">
            <summary>
            Returns a Rect with position and size rounded to closest integer values.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Ceiling">
            <summary>
            Returns a Rect with position and size rounded up.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.FromPoints(Vector2@,Vector2@)">
            <summary>
            Create a rect between two points. The order of the points doesn't matter.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.ToVector4">
            <summary>
            Returns this rect as a Vector4, where X/Y/Z/W are Left/Top/Right/Bottom respectively.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Rect.Add(Sandbox.Rect)">
            <summary>
            Expand this Rect to contain the other rect
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Add(Vector2)">
            <summary>
            Expand this Rect to contain the point
            </summary>
        </member>
        <member name="M:Sandbox.Rect.AddPoint(Vector2)">
            <summary>
            Returns this rect expanded to include this point
            </summary>
        </member>
        <member name="P:Sandbox.Rect.BottomLeft">
            <summary>
            Position of the bottom left edge of this rect.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.BottomRight">
            <summary>
            Position of the bottom right edge of this rect.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.TopRight">
            <summary>
            Position of the top right edge of this rect.
            </summary>
        </member>
        <member name="P:Sandbox.Rect.TopLeft">
            <summary>
            Position of the top left edge of this rect.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Align(Vector2@,Sandbox.TextFlag)">
            <summary>
            Align the smaller rect inside this rect.
            Default alignment on each axis is Top, Left.
            </summary>
        </member>
        <member name="M:Sandbox.Rect.Contain(Vector2@,Sandbox.TextFlag,System.Boolean)">
            <summary>
            Contain a given rectangle (image) within this rectangle (frame), preserving aspect ratio.
            </summary>
            <param name="size">Size of the rectagle (image) to try to contain within this frame rectangle.</param>
            <param name="align">Where to align the given box within this rectangle.</param>
            <param name="stretch">Whether to stretch the given rectagle (image) should its size be smaller than largest rectagle (image) size possible within this rectangle (frame).</param>
            <returns>A rectangle with correct position and size to fit within the "parent" rectangle.</returns>
        </member>
        <member name="T:Sandbox.Sphere">
            <summary>
            Represents a sphere.
            </summary>
        </member>
        <member name="P:Sandbox.Sphere.Unit">
            <summary>
            A sphere centered at the origin, with radius 1.
            </summary>
        </member>
        <member name="F:Sandbox.Sphere.Center">
            <summary>
            Center of the sphere.
            </summary>
        </member>
        <member name="F:Sandbox.Sphere.Radius">
            <summary>
            Radius of the sphere.
            </summary>
        </member>
        <member name="M:Sandbox.Sphere.Trace(Ray,System.Single,System.Single@)">
            <summary>
            Performs an intersection test between this sphere and given ray.
            </summary>
        </member>
        <member name="M:Sandbox.Sphere.Trace(Ray,System.Single)">
            <summary>
            Performs an intersection test between this sphere and given ray.
            </summary>
        </member>
        <member name="M:Sandbox.Sphere.Contains(Vector3@)">
            <summary>
            Returns true if sphere contains point. False if the point falls outside the sphere.
            </summary>
        </member>
        <member name="M:Sandbox.Sphere.GetVolume">
            <summary>
            Get the volume of this sphere
            </summary>
        </member>
        <member name="P:Sandbox.Sphere.RandomPointInside">
            <summary>
            Returns a random point within this sphere.
            </summary>
        </member>
        <member name="P:Sandbox.Sphere.RandomPointOnEdge">
            <summary>
            Returns a random point on the edge of this sphere.
            </summary>
        </member>
        <member name="T:Sandbox.SandboxSystem">
            <summary>
            Hidden random class. This is secretly used by Game.Random, but being here 
            allows all of our system functions to use the same Random instance.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxSystem.SetRandomSeed(System.Int32)">
            <summary>
            Sets the seed for these static classes
            </summary>
        </member>
        <member name="T:Sandbox.MultiSerializedObject">
            <summary>
            An object (or data) that can be accessed as an object
            </summary>
        </member>
        <member name="M:Sandbox.MultiSerializedObject.Add(Sandbox.SerializedObject)">
            <summary>
            Add an object. Don't forget to rebuild after editing!
            </summary>
        </member>
        <member name="M:Sandbox.MultiSerializedObject.Rebuild">
            <summary>
            Rebuild the object after modifying. This updates PropertyList.
            </summary>
        </member>
        <member name="P:Sandbox.MultiSerializedObject.IsMultipleTargets">
            <summary>
            True if the target is multiple objects
            </summary>
        </member>
        <member name="P:Sandbox.MultiSerializedObject.Targets">
            <summary>
            A list of actual target objects - if applicable
            </summary>
        </member>
        <member name="M:Sandbox.SerializedCollection.Create(System.Type)">
            <summary>
            Get a SerializedObject version of this object
            </summary>
        </member>
        <member name="M:Sandbox.SerializedCollection.NewKeyProperty">
            <summary>
            If this is a dictionary, this will create a property to easily create a key
            </summary>
        </member>
        <member name="M:Sandbox.SerializedDictionary.TryChangeKey(System.Object,System.Object)">
            <summary>
            Called when changing the key
            </summary>
        </member>
        <member name="M:Sandbox.SerializedDictionary.NewKeyProperty">
            <summary>
            If this is a dictionary, this will create a property to easily create a key
            </summary>
        </member>
        <member name="T:Sandbox.SerializedObject">
            <summary>
            An object (or data) that can be accessed as an object
            </summary>
        </member>
        <member name="M:Sandbox.SerializedObject.NoteChanged(Sandbox.SerializedProperty)">
            <summary>
            It's good manners for a changed SerializedProperty to tell its parent
            on set. That way the parent can cascade changes up the tree. This is 
            particularly important if the tree includes struct types - because those
            values will need to be re-set on any ParentProperty's.
            </summary>
        </member>
        <member name="M:Sandbox.SerializedObject.PrepareEnumerator">
            <summary>
            Called right before enumeration, to allow derivitives react to changes
            </summary>
        </member>
        <member name="P:Sandbox.SerializedObject.IsMultipleTargets">
            <summary>
            True if the target is multiple objects
            </summary>
        </member>
        <member name="P:Sandbox.SerializedObject.Targets">
            <summary>
            A list of actual target objects - if applicable
            </summary>
        </member>
        <member name="P:Sandbox.SerializedProperty.SourceFile">
            <summary>
            The source filename, if available
            </summary>
        </member>
        <member name="P:Sandbox.SerializedProperty.SourceLine">
            <summary>
            The line in the source file, if available
            </summary>
        </member>
        <member name="P:Sandbox.SerializedProperty.HasChanges">
            <summary>
            Returns true if the current set value differs from the actual value
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.GetDefault">
            <summary>
            Get the default value of a specific property type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SerializedProperty.HasAttribute``1">
            <summary>
            Return true if the property has this attribute
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.HasAttribute(System.Type)">
            <summary>
            Return true if the property has this attribute
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.TryGetAttribute``1(``0@)">
            <summary>
            Try to get this attribute from the property. Return false on fail.
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.GetAttributes``1">
            <summary>
            Get all of these attributes from the property.
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.GetAttributes(System.Type)">
            <summary>
            Get all of these attributes from the property.
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.GetAttributes">
            <summary>
            Get all attributes from the property.
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.TryGetAsObject(Sandbox.SerializedObject@)">
            <summary>
            Try to convert this property into a serialized object for further editing and exploration
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Sandbox.SerializedProperty.IsMultipleValues">
            <summary>
            True if this holds multiple values. Thet might all be the same.
            </summary>
        </member>
        <member name="P:Sandbox.SerializedProperty.IsMultipleDifferentValues">
            <summary>
            True if this holds multiple values, and they're all different.
            </summary>
        </member>
        <member name="P:Sandbox.SerializedProperty.MultipleProperties">
            <summary>
            Get all properties if this holds multiple values
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.NoteChanged">
            <summary>
            Our value has changed, maybe our parent would like to know
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.ValueToType``1(System.Object,``0)">
            <summary>
            Convert an object value to a T type 
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.GetKey">
            <summary>
            If this entry is a dictionary, we can get the key for it here
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.ShouldShow">
            <summary>
            Returns true if this property should be shown in the inspector
            </summary>
        </member>
        <member name="P:Sandbox.SerializedProperty.IsNullable">
            <summary>
            Return true if this is a nullable value type
            </summary>
        </member>
        <member name="P:Sandbox.SerializedProperty.NullableType">
            <summary>
            If this is a nullable type, this will return the nullable target type
            </summary>
        </member>
        <member name="P:Sandbox.SerializedProperty.IsNull">
            <summary>
            True if the value is null
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.SetNullState(System.Boolean)">
            <summary>
            If this is a nullable type, you can use this to toggle between it being null or the default value type
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.Invoke">
            <summary>
            If is method
            </summary>
        </member>
        <member name="T:Sandbox.SerializedProperty.Proxy">
            <summary>
            Allows easily creating SerializedProperty classes that wrap other properties.
            </summary>
        </member>
        <member name="M:Sandbox.SerializedProperty.Create``1(System.String,System.Func{``0},System.Action{``0})">
            <summary>
            Create a serialized property that uses a getter and setter
            </summary>
        </member>
        <member name="T:Sandbox.InspectorVisibilityAttribute">
            <summary>
            Hide a property if a condition matches.
            </summary>
        </member>
        <member name="T:Sandbox.RealTime">
            <summary>
            Access to time.
            </summary>
        </member>
        <member name="P:Sandbox.RealTime.Now">
            <summary>
            The time since game startup, in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.RealTime.GlobalNow">
            <summary>
            The number of a seconds since a set point in time. This value should match between servers and clients. If they have their timezone set correctly.
            </summary>
        </member>
        <member name="P:Sandbox.RealTime.Delta">
            <summary>
            The time delta (in seconds) between the last frame and the current (for all intents and purposes)
            </summary>
        </member>
        <member name="P:Sandbox.RealTime.SmoothDelta">
            <summary>
            Like Delta but smoothed to avoid large disparities between deltas
            </summary>
        </member>
        <member name="T:Sandbox.RealTimeSince">
            <summary>
            A convenience struct to easily measure time since an event last happened, based on <see cref="P:Sandbox.RealTime.GlobalNow"/>.<br/>
            <br/>
            Typical usage would see you assigning 0 to a variable of this type to reset the timer.
            Then the struct would return time since the last reset. i.e.:
            <code>
            RealTimeSince lastUsed = 0;
            if ( lastUsed > 10 ) { /*Do something*/ }
            </code>
            </summary>
        </member>
        <member name="P:Sandbox.RealTimeSince.Absolute">
            <summary>
            Time at which the timer reset happened, based on <see cref="P:Sandbox.RealTime.GlobalNow"/>.
            </summary>
        </member>
        <member name="P:Sandbox.RealTimeSince.Relative">
            <summary>
            Time passed since last reset, in seconds.
            </summary>
        </member>
        <member name="T:Sandbox.RealTimeUntil">
            <summary>
            A convenience struct to easily manage a time countdown, based on <see cref="P:Sandbox.RealTime.GlobalNow"/>.<br/>
            <br/>
            Typical usage would see you assigning to a variable of this type a necessary amount of seconds.
            Then the struct would return the time countdown, or can be used as a bool i.e.:
            <code>
            RealTimeUntil nextAttack = 10;
            if ( nextAttack ) { /*Do something*/ }
            </code>
            </summary>
        </member>
        <member name="P:Sandbox.RealTimeUntil.Absolute">
            <summary>
            Time to which we are counting down to, based on <see cref="P:Sandbox.RealTime.GlobalNow"/>.
            </summary>
        </member>
        <member name="P:Sandbox.RealTimeUntil.Relative">
            <summary>
            The actual countdown, in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.RealTimeUntil.Passed">
            <summary>
            Amount of seconds passed since the countdown started.
            </summary>
        </member>
        <member name="P:Sandbox.RealTimeUntil.Fraction">
            <summary>
            The countdown, but as a fraction, i.e. a value from 0 (start of countdown) to 1 (end of countdown)
            </summary>
        </member>
        <member name="T:Sandbox.Translation">
            <summary>
            This isn't ideal, but it does what we want it to do. Kind of.
            </summary>
        </member>
        <member name="T:Sandbox.BytePack">
             <summary>
             A class that can serialize and deserialize whole objects to and from byte streams, 
             without needing to know the type beforehand.
             
             https://docs.facepunch.com/doc/bytepack-FdTR6ZUoOa
            
             </summary>
        </member>
        <member name="T:Sandbox.BytePack.ISerializer">
            <summary>
            Allows classes to specify how they are to be serialized and deserialized through BytePack.
            </summary>
        </member>
        <member name="M:Sandbox.BytePack.ISerializer.BytePackRead(Sandbox.ByteStream@,System.Type)">
            <summary>
            Read from a <see cref="T:Sandbox.ByteStream"/> and return an object.
            </summary>
            <param name="bs">The incoming byte stream.</param>
            <param name="targetType">The expected type.</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.BytePack.ISerializer.BytePackWrite(System.Object,Sandbox.ByteStream@)">
            <summary>
            Write a value to an outgoing <see cref="T:Sandbox.ByteStream"/>.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="bs">The outgoing byte stream.</param>
        </member>
        <member name="T:Sandbox.BytePack.Identifier">
            <summary>
            A header before each variable
            </summary>
        </member>
        <member name="T:Sandbox.BytePack.PodPacker`1">
            <summary>
            Plain old data types. It's faster to have these as identifier types than
            have them each being a TypeLibrary lookup dynamic type, so anything quite
            common should be included here.
            </summary>
        </member>
        <member name="T:Sandbox.BytePack.ObjectArrayPacker">
            <summary>
            An object[] array. More expensive than a Value array because each type has to write its type
            </summary>
        </member>
        <member name="T:Sandbox.BytePack.ObjectPacker">
            <summary>
            Writes a type header and then the value
            </summary>
        </member>
        <member name="T:Sandbox.BytePack.ValueArrayPacker">
            <summary>
            A value array is useful because we only have to write the header once, and it's a single
            block of memory to read. Useful.
            </summary>
        </member>
        <member name="T:Sandbox.ByteStream">
            <summary>
            A result of SpeedTest.MemoryAlloc - to make it easy to use this instead of AllocHGlobal
            </summary>
        </member>
        <member name="P:Sandbox.ByteStream.Position">
            <summary>
            The current read or write position
            </summary>
        </member>
        <member name="P:Sandbox.ByteStream.Length">
            <summary>
            The total size of the data
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.Create(System.Int32)">
            <summary>
            Create a writable byte stream
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.CreateReader(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create a writable byte stream
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.CreateReader(System.Void*,System.Int32)">
            <summary>
            Create a writable byte stream
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.WriteArray``1(System.ReadOnlySpan{``0})">
            <summary>
            Writing an array of unmanaged types
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.WriteArray``1(``0[])">
            <summary>
            Writing an array of unmanaged types
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.Write(System.String)">
            <summary>
            Writing a string
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.ToArray">
            <summary>
            Get the data as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.ByteStream.ToSpan">
            <summary>
            Get the data as a span
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.Base">
            <summary>
            Returns a pointer to the base of the data
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.Base(System.Int32)">
            <summary>
            Returns a pointer to the base of the data
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.Write``1(``0)">
            <summary>
            Writing an unmanaged type
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.TryRead``1(``0@)">
            <summary>
            Try to read variable, return false if not enough data
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.ReadByteStream(System.Int32)">
            <summary>
            Read a block of data
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.WriteValueArray(System.Array)">
            <summary>
            Write an Array, that we know is a Value array. We definitely know it's a value array.
            We're not exposing this to the public api because they don't know whether it's a value array.
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.ReadValueArray(System.Array)">
            <summary>
            Write an Array, that we know is a Value array. We definitely know it's a value array.
            We're not exposing this to the public api because they don't know whether it's a value array.
            </summary>
        </member>
        <member name="M:Sandbox.ByteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sandbox.ByteStream.Read(System.Span{System.Byte})">
            <inheritdoc cref="M:System.IO.Stream.Read(System.Span{System.Byte})"/>
        </member>
        <member name="T:Sandbox.IValid">
            <summary>
            This object can become invalid
            </summary>
        </member>
        <member name="P:Sandbox.IValid.IsValid">
            <summary>
            Whether this object is valid or not.
            </summary>
        </member>
        <member name="T:Sandbox.MathX">
            <summary>
            A class to add functionality to the math library that System.Math and System.MathF don't provide.
            A lot of these methods are also extensions, so you can use for example `int i = 1.0f.FloorToInt();`
            </summary>
        </member>
        <member name="M:Sandbox.MathX.DegreeToRadian(System.Single)">
             <summary>
             Convert degrees to radians.
            
             <para>180 degrees is <see cref="F:System.Math.PI"/> (roughly 3.14) radians, etc.</para>
             </summary>
             <param name="deg">A value in degrees to convert.</param>
             <returns>The given value converted to radians.</returns>
        </member>
        <member name="M:Sandbox.MathX.RadianToDegree(System.Single)">
             <summary>
             Convert radians to degrees.
            
             <para>180 degrees is <see cref="F:System.Math.PI"/> (roughly 3.14) radians, etc.</para>
             </summary>
             <param name="rad">A value in radians to convert.</param>
             <returns>The given value converted to degrees.</returns>
        </member>
        <member name="M:Sandbox.MathX.GradiansToDegrees(System.Single)">
             <summary>
             Convert gradians to degrees.
            
             <para>100 gradian is 90 degrees, 200 gradian is 180 degrees, etc.</para>
             </summary>
             <param name="grad">A value in gradians to convert.</param>
             <returns>The given value converted to degrees.</returns>
        </member>
        <member name="M:Sandbox.MathX.GradiansToRadians(System.Single)">
             <summary>
             Convert gradians to radians.
            
             <para>200 gradian is <see cref="F:System.Math.PI"/> (roughly 3.14) radians, etc.</para>
             </summary>
             <param name="grad">A value in gradians to convert.</param>
             <returns>The given value converted to radians.</returns>
        </member>
        <member name="M:Sandbox.MathX.MeterToInch(System.Single)">
            <summary>
            Convert meters to inches.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.InchToMeter(System.Single)">
            <summary>
            Convert inches to meters.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.InchToMillimeter(System.Single)">
            <summary>
            Convert inches to millimeters.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.MillimeterToInch(System.Single)">
            <summary>
            Convert millimeters to inches.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.SnapToGrid(System.Single,System.Single)">
            <summary>
            Snap number to grid
            </summary>
        </member>
        <member name="M:Sandbox.MathX.SnapToGrid(System.Int32,System.Int32)">
            <summary>
            Snap number to grid
            </summary>
        </member>
        <member name="M:Sandbox.MathX.FloorToInt(System.Single)">
            <summary>
            Remove the fractional part and return the float as an integer.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.Floor(System.Single)">
            <summary>
            Remove the fractional part of given floating point number
            </summary>
        </member>
        <member name="M:Sandbox.MathX.CeilToInt(System.Single)">
            <summary>
            Rounds up given float to next integer value.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.Order(System.Single@,System.Single@)">
            <summary>
            Orders the two given numbers so that a is less than b.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamp a float between 2 given extremes.
            If given value is lower than the given minimum value, returns the minimum value, etc.
            </summary>
            <param name="v">The value to clamp.</param>
            <param name="min">Minimum return value.</param>
            <param name="max">Maximum return value.</param>
            <returns>The clamped float.</returns>
        </member>
        <member name="M:Sandbox.MathX.Lerp(System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Performs linear interpolation on floating point numbers.
            </summary>
            <param name="from">The "starting value" of the interpolation.</param>
            <param name="to">The "final value" of the interpolation.</param>
            <param name="frac">The fraction in range of 0 (will return value of <paramref name="from"/>) to 1 (will return value of <paramref name="to"/>).</param>
            <param name="clamp">Whether to clamp the fraction between 0 and 1, and therefore the output value between <paramref name="from"/> and <paramref name="to"/>.</param>
            <returns>The result of linear interpolation.</returns>
        </member>
        <member name="M:Sandbox.MathX.LerpTo(System.Single,System.Single,System.Single,System.Boolean)">
            <inheritdoc cref="M:Sandbox.MathX.Lerp(System.Single,System.Single,System.Single,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.MathX.LerpTo(System.Single[],System.Single[],System.Single,System.Boolean)">
            <summary>
            Performs multiple linear interpolations at the same time.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.LerpDegrees(System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Linearly interpolates between two angles in degrees, taking the shortest arc.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.LerpDegreesTo(System.Single,System.Single,System.Single,System.Boolean)">
            <inheritdoc cref="M:Sandbox.MathX.LerpDegrees(System.Single,System.Single,System.Single,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.MathX.LerpRadians(System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Linearly interpolates between two angles in radians, taking the shortest arc.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.LerpRadiansTo(System.Single,System.Single,System.Single,System.Boolean)">
            <inheritdoc cref="M:Sandbox.MathX.LerpRadians(System.Single,System.Single,System.Single,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.MathX.LerpInverse(System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Performs inverse of a linear interpolation, that is, the return value is the fraction of a linear interpolation.
            </summary>
            <param name="value">The value relative to <paramref name="from"/> and <paramref name="to"/>.</param>
            <param name="from">The "starting value" of the interpolation. If <paramref name="value"/> is at this value or less, the function will return 0 or less.</param>
            <param name="to">The "final value" of the interpolation. If <paramref name="value"/> is at this value or greater, the function will return 1 or greater.</param>
            <param name="clamp">Whether the return value is allowed to exceed range of 0 - 1.</param>
            <returns>The resulting fraction.</returns>
        </member>
        <member name="M:Sandbox.MathX.Approach(System.Single,System.Single,System.Single)">
            <summary>
            Adds or subtracts given amount based on whether the input is smaller of bigger than the target.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.AlmostEqual(System.Single,System.Single,System.Single)">
            <summary>
            Returns true if given value is close to given value within given tolerance.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.UnsignedMod(System.Single,System.Single)">
            <summary>
            Does what you expected to happen when you did "a % b"
            </summary>
        </member>
        <member name="M:Sandbox.MathX.NormalizeDegrees(System.Single)">
            <summary>
            Convert angle to between 0 - 360
            </summary>
        </member>
        <member name="M:Sandbox.MathX.DeltaDegrees(System.Single,System.Single)">
            <summary>
            Difference between two angles in degrees. Will always be between -180 and +180.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.DeltaRadians(System.Single,System.Single)">
            <summary>
            Difference between two angles in radians. Will always be between -PI and +PI.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.Remap(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Remap a float value from a one range to another. Clamps value between newLow and newHigh.
            </summary>
        </member>
        <member name="M:Sandbox.MathX.Remap(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Remap a float value from a one range to another
            </summary>
        </member>
        <member name="M:Sandbox.MathX.Remap(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Remap an integer value from a one range to another
            </summary>
        </member>
        <member name="M:Sandbox.MathX.SphereCameraDistance(System.Single,System.Single)">
            <summary>
            Given a sphere and a field of view, how far from the camera should we be to fully see the sphere?
            </summary>
            <param name="radius">The radius of the sphere</param>
            <param name="fieldOfView">The field of view in degrees</param>
            <returns>The optimal distance from the center of the sphere</returns>
        </member>
        <member name="M:Sandbox.MathX.SmoothDamp(System.Single,System.Single,System.Single@,System.Single,System.Single)">
            <summary>
            Smoothly move towards the target
            </summary>
        </member>
        <member name="T:Sandbox.NativeMemoryBlock">
            <summary>
            A growable block of native memory - which will be handled and free'd safely
            </summary>
        </member>
        <member name="P:Sandbox.NativeMemoryBlock.Pointer">
            <summary>
            Pointer to the allocated data
            </summary>
        </member>
        <member name="P:Sandbox.NativeMemoryBlock.Size">
            <summary>
            The size of the allocated buffer
            </summary>
        </member>
        <member name="F:Sandbox.NativeMemoryBlock.InPool">
            <summary>
            True if this is currently in the shared pool
            </summary>
        </member>
        <member name="M:Sandbox.NativeMemoryBlock.Grow(System.Int32)">
            <summary>
            Grow the allocated buffer to this size. If we're already this size then do nothing.
            </summary>
        </member>
        <member name="M:Sandbox.Parse.ReadSentence">
            <summary>
            Reads a sentence until the next statement divided by ,
            Returns the sentence
            </summary>
        </member>
        <member name="M:Sandbox.Parse.TryReadPositionAndSize(Sandbox.UI.Length@,Sandbox.UI.Length@,Sandbox.UI.Length@,Sandbox.UI.Length@)">
            <summary>
            <para>
            Typically used to parse shorthand position &amp; size combinations, like those seen inside
            mask and background shorthands.
            <code>&lt;position&gt; [ / &lt;size&gt; ]</code>
            </para>
            </summary>
        </member>
        <member name="M:Sandbox.Parse.Is(System.String,System.Int32,System.Boolean)">
            <summary>
            Return true if the string at the pointer is this
            </summary>
        </member>
        <member name="M:Sandbox.Parse.TrySkip(System.String,System.Int32,System.Boolean)">
            <summary>
            Skip this string if it exists
            </summary>
        </member>
        <member name="M:Sandbox.Parse.TrySkipCommaSeparation">
            <summary>
            Skip comma and then possible whitespace
            </summary>
        </member>
        <member name="M:Sandbox.Parse.Is(System.Char,System.Int32,System.Boolean)">
            <summary>
            Return true if the char at the pointer is this
            </summary>
        </member>
        <member name="P:Sandbox.Parse.CurrentLine">
            <summary>
            Get the line we're currently on
            </summary>
        </member>
        <member name="T:Sandbox.PooledArrayBuffer`1">
            <summary>
            A result of SpeedTest.MemoryAlloc - to make it easy to use this instead of AllocHGlobal
            </summary>
        </member>
        <member name="T:Sandbox.StringToken">
            <summary>
            Strings are commonly converted to tokens in engine, to save space and speed up things like comparisons.
            We wrap this functionality up in the StringToken struct, because we can apply a bunch of compile time 
            optimizations to speed up the conversion.
            </summary>
        </member>
        <member name="M:Sandbox.StringToken.FindOrCreate(System.String)">
            <summary>
            called by interop
            </summary>
        </member>
        <member name="M:Sandbox.StringToken.Literal(System.String,System.UInt32)">
            <summary>
            This is used by codegen. String literals are replaced by this function call, which
            avoids having to create or lookup the string token.
            </summary>
        </member>
        <member name="F:Sandbox.StringToken.defaults">
            <summary>
            A bunch of values we want to exist in the reverse lookup. 
            I don't know if this is still strictly needed, but we used to need these to deserialize entities propertly.
            </summary>
        </member>
        <member name="T:Sandbox.StringToken.ConvertAttribute">
            <summary>
            To allow redirecting in the case where a class has both a string and StringToken version of a method.
            We should be able to remove this when we're compiling on demand instead of keeping the string versions around for compatibility.
            </summary>
        </member>
        <member name="T:Sandbox.ThreadSafe">
            <summary>
            MainThread related functions.
            </summary>
        </member>
        <member name="P:Sandbox.ThreadSafe.CurrentThreadId">
            <summary>
            Return the current thread's Id (CurrentThread.ManagedThreadId)
            </summary>
        </member>
        <member name="P:Sandbox.ThreadSafe.CurrentThreadName">
            <summary>
            Return the current thread's name (CurrentThread.Name)
            </summary>
        </member>
        <member name="P:Sandbox.ThreadSafe.IsMainThread">
            <summary>
            Returns true if we're executing under the main thread
            </summary>
        </member>
        <member name="M:Sandbox.ThreadSafe.AssertIsMainThread(System.String)">
            <summary>
            Throws an exception if this is not called under the main thread
            </summary>
        </member>
        <member name="M:Sandbox.ThreadSafe.AssertIsNotMainThread">
            <summary>
            Throws an exception if this is the main thread
            </summary>
        </member>
        <member name="T:PlaceholderAttribute">
            <summary>
            Add placeholder text, typically displayed for string properties when the text entry field is empty.
            This info can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:PlaceholderAttribute.Value">
            <inheritdoc cref="P:Sandbox.Internal.IPlaceholderProvider.Value"/>
        </member>
        <member name="T:ClassNameAttribute">
            <summary>
            Set the class name for this type or member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:ClassNameAttribute.Value">
            <inheritdoc cref="P:Sandbox.Internal.IClassNameProvider.Value"/>
        </member>
        <member name="T:TitleAttribute">
            <summary>
            Sets the title or a "nice name" of a type or a type member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:TitleAttribute.Value">
            <inheritdoc cref="P:Sandbox.Internal.ITitleProvider.Value"/>
        </member>
        <member name="T:DescriptionAttribute">
            <summary>
            Sets the description of a type or a type member. This attribute is usually applied automatically by codegen based on the XML comment of the type or member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:DescriptionAttribute.Value">
            <inheritdoc cref="P:Sandbox.Internal.IDescriptionProvider.Value"/>
        </member>
        <member name="T:CategoryAttribute">
            <summary>
            Sets the category or the group of a type or a type member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:CategoryAttribute.Value">
            <inheritdoc cref="P:Sandbox.Internal.ICategoryProvider.Value"/>
        </member>
        <member name="T:GroupAttribute">
            <summary>
            Sets the category or the group of a type or a type member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:GroupAttribute.Value">
            <inheritdoc cref="P:Sandbox.Internal.ICategoryProvider.Value"/>
        </member>
        <member name="T:ToggleGroupAttribute">
            <summary>
            Very much like a GroupAttribute, except we're indicating that the group can be toggle on and off using the named property
            </summary>
        </member>
        <member name="T:IconAttribute">
            <summary>
            Sets the icon of a type or a type member. Colors are expected in HTML formats, like "rgb(255,255,255)" or "#FFFFFF".
            This info can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:IconAttribute.Value">
            <inheritdoc cref="P:Sandbox.Internal.IIconProvider.Value"/>
        </member>
        <member name="P:IconAttribute.BackgroundColor">
            <summary>
            The preferred background color for the icon.
            </summary>
        </member>
        <member name="P:IconAttribute.ForegroundColor">
            <summary>
            The preferred color of the icon itself.
            </summary>
        </member>
        <member name="T:OrderAttribute">
            <summary>
            Visual order of this member for UI purposes.
            This info can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:OrderAttribute.Value">
            <summary>
            The visual order.
            </summary>
        </member>
        <member name="T:IUninheritable">
            <summary>
            If applied to an attribute on a class, it won't be inherited from its base classes.
            </summary>
        </member>
        <member name="T:TimeRangeAttribute">
            <summary>
            For use with Curves, allows you to define a custom range for the time
            </summary>
        </member>
        <member name="T:ValueRangeAttribute">
            <summary>
            For use with Curves, allows you to define a custom range for the value
            </summary>
        </member>
        <member name="T:TagAttribute">
            <summary>
            Adds a single or multiple tags for this type or member. Tags can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:TagAttribute.Value">
            <summary>
            The tags to add for this type or member.
            </summary>
        </member>
        <member name="M:TagAttribute.EnumerateValues">
            <summary>
            Returns all the tags as an enumerable.
            </summary>
            <returns></returns>
        </member>
        <member name="T:AliasAttribute">
            <summary>
            Alternate class name(s) for this type to the one specified via LibraryAttribute. This info can then be retrieved via DisplayInfo library.
            </summary>
        </member>
        <member name="P:AliasAttribute.Value">
            <summary>
            The aliases for this class.
            </summary>
        </member>
        <member name="T:EditorAttribute">
            <summary>
            Tell the tools or gameui property editor which editor we should be using for this property or type.
            </summary>
        </member>
        <member name="P:EditorAttribute.Value">
            <summary>
            The editor to use.
            </summary>
        </member>
        <member name="T:SpawnableAttribute">
            <summary>
            This entity is expected to be spawnable in-game, like from Sandbox's spawnmenu.
            </summary>
        </member>
        <member name="T:HideInEditorAttribute">
            <summary>
            Hide this in tools/editors.
            </summary>
        </member>
        <member name="T:MinMaxAttribute">
            <summary>
            Mark property as having a minimum and maximum value.
            </summary>
        </member>
        <member name="P:MinMaxAttribute.MinValue">
            <summary>
            The minimum value for this property.
            </summary>
        </member>
        <member name="P:MinMaxAttribute.MaxValue">
            <summary>
            The maximum value for this property.
            </summary>
        </member>
        <member name="T:EditorModelAttribute">
            <summary>
            Declare a model to represent this entity in editor. This is a common attribute so it's leaked out of the Editor namespace.
            </summary>
        </member>
        <member name="P:EditorModelAttribute.Model">
            <summary>
            The model to display in the editor.
            </summary>
        </member>
        <member name="P:EditorModelAttribute.CastShadows">
            <summary>
            Whether the model should cast shadows in the editor.
            </summary>
        </member>
        <member name="P:EditorModelAttribute.FixedBounds">
            <summary>
            Don't reorient bounds. This is used for things that have fixed bounds in the game, like info_player_start.
            </summary>
        </member>
        <member name="P:EditorModelAttribute.StaticColor">
            <summary>
            Tint color for this editor model instance when the entity it represents is static.
            </summary>
        </member>
        <member name="P:EditorModelAttribute.DynamicColor">
            <summary>
            Tint color for this editor model instance when the entity it represents is dynamic.
            </summary>
        </member>
        <member name="T:DefaultValueAttribute">
            <summary>
            Sometimes with CodeGen we want reflection to be able to get the original initial value
            of a property (which is set with {get;set;} = initialvalue;). For this reason sometimes
            we'll drop this attribute on that property.
            You might want to use this manually for instances where codegen can't define the default
            value. This will usually happen for structs like vector and color.. if the default value isn't
            defined as a number or string.
            </summary>
        </member>
        <member name="P:DefaultValueAttribute.Value">
            <summary>
            The default value.
            </summary>
        </member>
        <member name="T:TasksPersistOnContextResetAttribute">
            <summary>
            Allows any task defined in this assembly to continue after a sync context expires.
            Other tasks that await tasks in this assembly will still be cancelled if their assembly
            isn't also marked with this attribute.
            </summary>
        </member>
        <member name="T:System.Collections.ObjectModel.ObservableDictionary`2">
            <summary>
            A dictionary with callbacks for when changes occur.
            </summary>
        </member>
        <member name="P:System.Collections.ObjectModel.ObservableDictionary`2.Dictionary">
            <summary>
            The dictionary being observed.
            </summary>
        </member>
        <member name="E:System.Collections.ObjectModel.ObservableDictionary`2.CollectionChanged">
            <summary>
            Called when the dictionary's key-value pairs have changed.
            </summary>
        </member>
        <member name="E:System.Collections.ObjectModel.ObservableDictionary`2.PropertyChanged">
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.OnPropertyChanged(System.String)"/>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableDictionary`2.AddRange(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Merge given dictionary into this one.
            </summary>
            <param name="items">The items to add into this dictionary.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the input dictionary is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when this dictionary already has an element with same key as the input dictionary.</exception>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableDictionary`2.OnPropertyChanged(System.String)">
            <summary>
            Called when a property (such as element count) of the dictionary has changed.
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the CollapseWhiteSpaceRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the CollapseSpacesAndTabsRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the RemoveSpacesAroundLineBreaksRegex method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Utilities">
            <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex"/>-derived implementations.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
            <summary>Default timeout value set in <see cref="T:System.AppContext"/>, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
            <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout"/> is non-infinite.</summary>
        </member>
        <member name="T:Color">
            <summary>
            Represents a color using 4 floats (rgba), with 0-1 range.
            </summary>
        </member>
        <member name="F:Color.r">
            <summary>
            The red color component, in range of 0-1, which <b>can be exceeded</b>.
            </summary>
        </member>
        <member name="F:Color.g">
            <summary>
            The green color component, in range of 0-1, which <b>can be exceeded</b>.
            </summary>
        </member>
        <member name="F:Color.b">
            <summary>
            The blue color component, in range of 0-1, which <b>can be exceeded</b>.
            </summary>
        </member>
        <member name="F:Color.a">
            <summary>
            The alpha/transparency color component, in range of 0 (fully transparent) to 1 (fully opaque), which <b>can be exceeded</b>.
            </summary>
        </member>
        <member name="M:Color.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initialize a color with each component set to given values, in range [0,1]
            </summary>
        </member>
        <member name="M:Color.#ctor(System.Single@,System.Single@)">
            <summary>
            Initialize a color with the same value for each color, but a different value for alpha
            </summary>
        </member>
        <member name="M:Color.#ctor(System.Single)">
            <summary>
            Initialize a color with each component set to given value, even alpha.
            </summary>
            <param name="all">A number in range [0-1]</param>
        </member>
        <member name="M:Color.#ctor(System.UInt32)">
            <summary>
            Initialize from an integer of the form 0xAABBGGRR.
            </summary>
            <param name="raw">Packed integer of the form 0xAABBGGRR.</param>
        </member>
        <member name="M:Color.#ctor(System.Int32)">
            <summary>
            Initialize from an integer of the form 0xAABBGGRR.
            </summary>
            <param name="raw">Packed integer of the form 0xAABBGGRR.</param>
        </member>
        <member name="M:Color.WithAlpha(System.Single)">
            <summary>
            Returns this color with its alpha value changed
            </summary>
            <param name="alpha">The required alpha value, usually between 0-1</param>
        </member>
        <member name="M:Color.WithAlphaMultiplied(System.Single)">
            <summary>
            Similar to <see cref="M:Color.WithAlpha(System.Single)"/> but multiplies the alpha instead of replacing.
            </summary>
        </member>
        <member name="M:Color.WithRed(System.Single)">
            <summary>
            Returns this color with its red value changed
            </summary>
        </member>
        <member name="M:Color.WithGreen(System.Single)">
            <summary>
            Returns this color with its green value changed
            </summary>
        </member>
        <member name="M:Color.WithBlue(System.Single)">
            <summary>
            Returns this color with its blue value changed
            </summary>
        </member>
        <member name="M:Color.ToHsv">
            <summary>
            Converts this color to a HSV format.
            </summary>
            <returns>The HSV color.</returns>
        </member>
        <member name="M:Color.ToColor32(System.Boolean)">
            <summary>
            Convert to a Color32 (a 32 bit color value)
            </summary>
            <param name="srgb">If true we'll convert to the srgb color space</param>
        </member>
        <member name="M:Color.Min(Color@,Color@)">
            <summary>
            Returns a new color with each component being the minimum of the 2 given colors.
            </summary>
            <param name="a">Color A</param>
            <param name="b">Color B</param>
            <returns>The new color with minimum values.</returns>
        </member>
        <member name="M:Color.Max(Color@,Color@)">
            <summary>
            Returns a new color with each component being the maximum of the 2 given colors.
            </summary>
            <param name="a">Color A</param>
            <param name="b">Color B</param>
            <returns>The new color with maximum values.</returns>
        </member>
        <member name="P:Color.Luminance">
            <summary>
            Returns the luminance of the color, basically it's grayscale value or "black and white version".
            </summary>
        </member>
        <member name="P:Color.IsRepresentableInHex">
            <summary>
            Returns true if this color can be represented in hexadecimal format (#RRGGBB[AA]).
            This may not be the case if the color components are outside of [0,1] range.
            </summary>
        </member>
        <member name="P:Color.IsSdr">
            <summary>
            Returns true if all components are between 0 and 1
            </summary>
        </member>
        <member name="P:Color.IsHdr">
            <summary>
            Returns true if any component exceeds 1
            </summary>
        </member>
        <member name="F:Color.White">
            <summary>
            Fully opaque white color.
            </summary>
        </member>
        <member name="F:Color.Gray">
            <summary>
            Fully opaque gray color, right between white and black.
            </summary>
        </member>
        <member name="F:Color.Black">
            <summary>
            Fully opaque black color.
            </summary>
        </member>
        <member name="F:Color.Red">
            <summary>
            Fully opaque pure red color.
            </summary>
        </member>
        <member name="F:Color.Green">
            <summary>
            Fully opaque pure green color.
            </summary>
        </member>
        <member name="F:Color.Blue">
            <summary>
            Fully opaque pure blue color.
            </summary>
        </member>
        <member name="F:Color.Yellow">
            <summary>
            Fully opaque yellow color.
            </summary>
        </member>
        <member name="F:Color.Orange">
            <summary>
            Fully opaque orange color.
            </summary>
        </member>
        <member name="F:Color.Cyan">
            <summary>
            Fully opaque cyan color.
            </summary>
        </member>
        <member name="F:Color.Magenta">
            <summary>
            Fully opaque magenta color.
            </summary>
        </member>
        <member name="F:Color.Transparent">
            <summary>
            Fully transparent color.
            </summary>
        </member>
        <member name="P:Color.Hex">
            <summary>
            String representation of the form "#RRGGBB[AA]".
            </summary>
        </member>
        <member name="P:Color.Rgba">
            <summary>
            String representation in the form of <see href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgba">rgba</see>( r, g, b, a )
            css function notation.
            </summary>
        </member>
        <member name="P:Color.Rgb">
            <summary>
            String representation in the form of <see href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb">rgb</see>( r, g, b )
            css function notation.
            </summary>
        </member>
        <member name="P:Color.RgbaInt">
            <summary>
            Integer representation of the form 0xRRGGBBAA.
            </summary>
        </member>
        <member name="P:Color.RgbInt">
            <summary>
            Integer representation of the form 0xRRGGBB.
            </summary>
        </member>
        <member name="P:Color.RawInt">
            <summary>
            Integer representation of the form 0xAABBGGRR as used by native code.
            </summary>
        </member>
        <member name="P:Color.Random">
            <summary>
            Returns a random color out of 8 preset colors.
            </summary>
        </member>
        <member name="M:Color.ToString(System.Boolean,System.Boolean)">
            <summary>
            Converts the color to a string with given parameters.
            </summary>
            <param name="hex">Convert to Hex string if possible.</param>
            <param name="rgba">Convert to CSS rgba function</param>
            <returns>The string representation of this color.</returns>
        </member>
        <member name="M:Color.Average(Color[])">
            <summary>
            Returns a color whose components are averaged of all given colors.
            </summary>
            <param name="values">The colors to get average of.</param>
            <returns>The average color.</returns>
        </member>
        <member name="M:Color.Lerp(Color,Color,System.Single,System.Boolean)">
            <summary>
            Performs linear interpolation between two colors.
            </summary>
            <param name="a">The source color.</param>
            <param name="b">The target color.</param>
            <param name="frac">Fraction to the target color. 0 will return source color, 1 will return target color, 0.5 will "mix" the 2 colors equally.</param>
            <param name="clamped">Clamp fraction to range of [0,1]. If not clamped, the color will be extrapolated.</param>
            <returns>The interpolated color.</returns>
        </member>
        <member name="M:Color.FromBytes(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a color from 0-255 range inputs, converting them to 0-1 range.
            </summary>
            <param name="r">The red component.</param>
            <param name="g">The green component.</param>
            <param name="b">The blue component.</param>
            <param name="a">The alpha/transparency component.</param>
            <returns></returns>
        </member>
        <member name="M:Color.FromRgb(System.UInt32)">
            <summary>
            Converts an integer of the form 0xRRGGBB into the color #RRGGBB with 100% alpha.
            </summary>
            <param name="rgb">Integer between 0x000000 and 0xffffff representing a color.</param>
        </member>
        <member name="M:Color.FromRgba(System.UInt32)">
            <summary>
            Converts an integer of the form 0xRRGGBBAA into the color #RRGGBBAA.
            </summary>
            <param name="rgba">Integer between 0x00000000 and 0xffffffff representing a color with alpha.</param>
        </member>
        <member name="M:Color.AdjustHue(System.Single)">
            <summary>
            Increases or decreases this color's hue
            </summary>
            <param name="amount">A number between -360 and 360 to add to the color's hue</param>
            <returns>The adjusted color</returns>
        </member>
        <member name="M:Color.Darken(System.Single)">
            <summary>
            Darkens the color by given amount.
            </summary>
            <param name="fraction">How much to darken the color by, in range of 0 (not at all) to 1 (fully black). Negative values will lighten the color.</param>
            <returns>The darkened color.</returns>
        </member>
        <member name="M:Color.Lighten(System.Single)">
            <summary>
            Lightens the color by given amount.
            </summary>
            <param name="fraction">How much to lighten the color by, in range of 0 (not at all) to 1 (double the color). Negative values will darken the color.</param>
            <returns>The lightened color.</returns>
        </member>
        <member name="M:Color.Invert">
            <summary>
            Returns inverted color. Alpha is unchanged.
            </summary>
            <returns>The inverted color.</returns>
        </member>
        <member name="M:Color.Desaturate(System.Single)">
            <summary>
            Desaturates the color by given amount.
            </summary>
            <param name="fraction">How much to desaturate the color by, in range of 0 (not at all) to 1 (no saturation, i.e. fully white). Negative values will saturate the color.</param>
            <returns>The desaturated color.</returns>
        </member>
        <member name="M:Color.Saturate(System.Single)">
            <summary>
            Saturates the color by given amount.
            </summary>
            <param name="fraction">How much to saturate the color by, in range of 0 (not at all) to 1 (double the saturation). Negative values will desaturate the color.</param>
            <returns>The saturated color.</returns>
        </member>
        <member name="M:Color.ComponentCountChangedBetweenColors(Color)">
            <summary>
            Returns how many color components would be changed between this color and another color
            </summary>
        </member>
        <member name="F:Color.WebColours">
            <summary>
            All the web colors by name that can be used in style sheets.
            </summary>
        </member>
        <member name="M:Color.Parse(System.String)">
            <summary>
            Parse the color from a string. Many common formats are supported.
            </summary>
            <param name="value">The string to parse.</param>
            <returns>The parsed color if operation completed successfully.</returns>
        </member>
        <member name="M:Color.TryParse(System.String,Color@)">
            <summary>
            Try to parse the color. Returns true on success
            </summary>
        </member>
        <member name="M:Color.op_Multiply(Color,System.Single)">
            <summary>
            Multiply each component of this color by given value.
            </summary>
            <param name="c1">Color to multiply.</param>
            <param name="f">Scalar value to multiply each color component by.</param>
            <returns>The multiplication result.</returns>
        </member>
        <member name="P:Color.Item(System.Int32)">
            <summary>
            Get color components by numerical index.
            </summary>
            <param name="index">Index of the color component to request, 0-3 being RGBA</param>
            <returns>The requested color component</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown when requested index is out of range of [0,3]</exception>
        </member>
        <member name="T:Color32">
             <summary>
             A 32bit color, commonly used by things like vertex buffers.
            
             The functionality on this is purposely left minimal so we're encouraged to use the regular <see cref="T:Color"/> struct.
             </summary>
        </member>
        <member name="F:Color32.r">
            <summary>
            The red color component, in range of 0-255.
            </summary>
        </member>
        <member name="F:Color32.g">
            <summary>
            The green color component, in range of 0-255.
            </summary>
        </member>
        <member name="F:Color32.b">
            <summary>
            The blue color component, in range of 0-255.
            </summary>
        </member>
        <member name="F:Color32.a">
            <summary>
            The alpha/transparency color component, in range of 0 (fully transparent) to 255 (fully opaque).
            </summary>
        </member>
        <member name="M:Color32.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initialize a color with each component set to given values, in range [0,255]
            </summary>
        </member>
        <member name="M:Color32.#ctor(System.Byte)">
            <summary>
            Initialize a color with each component set to given value, even alpha.
            </summary>
            <param name="all">A number in range [0-255]</param>
        </member>
        <member name="M:Color32.#ctor(System.UInt32)">
            <summary>
            Initialize from an integer of the form 0xAABBGGRR.
            </summary>
            <param name="raw">Packed integer of the form 0xAABBGGRR.</param>
        </member>
        <member name="M:Color32.#ctor(System.Int32)">
            <summary>
            Initialize from an integer of the form 0xAABBGGRR.
            </summary>
            <param name="raw">Packed integer of the form 0xAABBGGRR.</param>
        </member>
        <member name="P:Color32.White">
            <summary>
            A constant representing a fully opaque color white.
            </summary>
        </member>
        <member name="P:Color32.Black">
            <summary>
            A constant representing a fully opaque color black.
            </summary>
        </member>
        <member name="P:Color32.Transparent">
            <summary>
            A constant representing a fully transparent color.
            </summary>
        </member>
        <member name="M:Color32.FromRgb(System.UInt32)">
            <summary>
            Converts an integer of the form 0xRRGGBB into the color #RRGGBB with 100% alpha.
            </summary>
            <param name="rgb">Integer between 0x000000 and 0xffffff representing a color.</param>
        </member>
        <member name="M:Color32.FromRgba(System.UInt32)">
            <summary>
            Converts an integer of the form 0xRRGGBBAA into the color #RRGGBBAA.
            </summary>
            <param name="rgba">Integer between 0x00000000 and 0xffffffff representing a color with alpha.</param>
        </member>
        <member name="M:Color32.ToColor">
            <summary>
            Convert this object to <see cref="T:Color"/>.
            </summary>
            <returns>The converted color struct.</returns>
        </member>
        <member name="M:Color32.ToColor(System.Boolean)">
            <summary>
            Convert this object to <see cref="T:Color"/>.
            </summary>
            <param name="srgb">If true we'll convert from the srgb color space to linear</param>
            <returns>The converted color struct.</returns>
        </member>
        <member name="M:Color32.Min(Color32,Color32)">
            <summary>
            Returns a new color with each component being the minimum of the 2 given colors.
            </summary>
            <param name="a">Color A</param>
            <param name="b">Color B</param>
            <returns>The new color with minimum values.</returns>
        </member>
        <member name="M:Color32.Max(Color32,Color32)">
            <summary>
            Returns a new color with each component being the maximum of the 2 given colors.
            </summary>
            <param name="a">Color A</param>
            <param name="b">Color B</param>
            <returns>The new color with maximum values.</returns>
        </member>
        <member name="P:Color32.Hex">
            <summary>
            String representation of the form "#RRGGBB[AA]".
            </summary>
        </member>
        <member name="P:Color32.Rgba">
            <summary>
            String representation in the form of <see href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgba">rgba</see>( r, g, b, a )
            css function notation.
            </summary>
        </member>
        <member name="P:Color32.Rgb">
            <summary>
            String representation in the form of <see href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb">rgb</see>( r, g, b )
            css function notation.
            </summary>
        </member>
        <member name="P:Color32.RgbaInt">
            <summary>
            Integer representation of the form 0xRRGGBBAA.
            </summary>
        </member>
        <member name="P:Color32.RgbInt">
            <summary>
            Integer representation of the form 0xRRGGBB.
            </summary>
        </member>
        <member name="P:Color32.RawInt">
            <summary>
            Integer representation of the form 0xAABBGGRR as used by native code.
            </summary>
        </member>
        <member name="M:Color32.Write(System.IO.BinaryWriter)">
            <summary>
            Write this color to a binary writer.
            </summary>
            <param name="writer">Writer to write to.</param>
        </member>
        <member name="M:Color32.Read(System.IO.BinaryReader)">
            <summary>
            Read a color from binary reader.
            </summary>
            <param name="reader">Reader to read from.</param>
            <returns>The read color.</returns>
        </member>
        <member name="M:Color32.Parse(System.String)">
            <summary>
            Parse a string to a color, in format "255 255 255 255" or "255,255,255". Alpha is optional.
            </summary>
            <param name="value">The value to parse.</param>
            <returns>The color parsed from the string, or null if we failed to do so.</returns>
        </member>
        <member name="T:ColorHsv">
            <summary>
            A color in <a href="https://upload.wikimedia.org/wikipedia/commons/a/a0/Hsl-hsv_models.svg">Hue-Saturation-Value/Brightness</a> format.
            </summary>
        </member>
        <member name="P:ColorHsv.Hue">
            <summary>
            Hue component of this color in range 0 to 360.
            </summary>
        </member>
        <member name="P:ColorHsv.Saturation">
            <summary>
            Saturation of this color in range 0 (white) to 1 (full color).
            </summary>
        </member>
        <member name="P:ColorHsv.Value">
            <summary>
            Brightness of this color in range 0 (black) to 1 (full color).
            </summary>
        </member>
        <member name="P:ColorHsv.Alpha">
            <summary>
            Transparency of this color in range 0 (fully transparent) to 1 (fully opaque).
            </summary>
        </member>
        <member name="M:ColorHsv.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new HSV/HSB color. Hue is in the range of [0-360] and all other values are in range [0,1]
            </summary>
            <param name="h">The hue color component.</param>
            <param name="s">Saturation of the color.</param>
            <param name="v">Brightness of the color.</param>
            <param name="a">Alpha of the color.</param>
        </member>
        <member name="M:ColorHsv.ToColor">
            <summary>
            Convert this object to <see cref="T:Color"/>.
            </summary>
            <returns>The converted color struct.</returns>
        </member>
        <member name="M:ColorHsv.WithHue(System.Single)">
            <summary>
            Returns a copy of this color with given Hue value.
            </summary>
            <param name="hue">The Hue override.</param>
            <returns>The new color.</returns>
        </member>
        <member name="M:ColorHsv.WithSaturation(System.Single)">
            <summary>
            Returns a copy of this color with given Saturation value.
            </summary>
            <param name="saturation">The Saturation override.</param>
            <returns>The new color.</returns>
        </member>
        <member name="M:ColorHsv.WithValue(System.Single)">
            <summary>
            Returns a copy of this color with given Brightness value.
            </summary>
            <param name="value">The Brightness override.</param>
            <returns>The new color.</returns>
        </member>
        <member name="M:ColorHsv.WithAlpha(System.Single)">
            <summary>
            Returns a copy of this color with given alpha value.
            </summary>
            <param name="alpha">The alpha override.</param>
            <returns>The new color.</returns>
        </member>
        <member name="T:Angles">
            <summary>
            Euler angles. Unlike a <see cref="T:Rotation">Rotation</see>, Euler angles can represent multiple revolutions (rotations) around an axis,
            but suffer from issues like gimbal lock and lack of a defined "up" vector. Use <see cref="T:Rotation">Rotation</see> for most cases.
            </summary>
        </member>
        <member name="F:Angles.pitch">
            <summary>
            The pitch component, typically up/down.
            </summary>
        </member>
        <member name="F:Angles.yaw">
            <summary>
            The yaw component, typically left/right.
            </summary>
        </member>
        <member name="F:Angles.roll">
            <summary>
            The roll component, basically rotation around the axis.
            </summary>
        </member>
        <member name="M:Angles.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes the angles object with given components.
            </summary>
            <param name="pitch">The Pitch component.</param>
            <param name="yaw">The Yaw component.</param>
            <param name="roll">The roll component.</param>
        </member>
        <member name="M:Angles.#ctor(Angles)">
            <summary>
            Copies values of given angles object.
            </summary>
        </member>
        <member name="M:Angles.#ctor(Vector3)">
            <summary>
            Where x, y and z represent the pitch, yaw and roll respectively.
            </summary>
        </member>
        <member name="M:Angles.#ctor(System.Single)">
            <summary>
            Initializes the angles object with all components set to given value.
            </summary>
        </member>
        <member name="M:Angles.ToRotation">
            <summary>
            Converts these Euler angles to a rotation. The angles will be normalized.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Angles.AsVector3">
            <summary>
            Return as a Vector3, where x = pitch etc
            </summary>
        </member>
        <member name="F:Angles.Zero">
            <summary>
            An angle constant that has all its values set to 0. Use this instead of making a static 0,0,0 object yourself.
            </summary>
        </member>
        <member name="P:Angles.Random">
            <summary>
            Returns the angles of a uniformly random rotation.
            </summary>
        </member>
        <member name="M:Angles.IsNearlyZero(System.Double)">
            <summary>
            Returns true if this angles object's components are all nearly zero with given tolerance.
            </summary>
        </member>
        <member name="M:Angles.WithPitch(System.Single)">
            <summary>
            Returns this angles object with given pitch component.
            </summary>
        </member>
        <member name="M:Angles.WithYaw(System.Single)">
            <summary>
            Returns this angles object with given yaw component.
            </summary>
        </member>
        <member name="M:Angles.WithRoll(System.Single)">
            <summary>
            Returns this angles object with given roll component.
            </summary>
        </member>
        <member name="M:Angles.Parse(System.String)">
            <summary>
            Given a string, try to convert this into an angles object. The format is "p,y,r".
            </summary>
        </member>
        <member name="M:Angles.Parse(System.String,System.IFormatProvider)">
            <inheritdoc cref="M:Angles.Parse(System.String)" />
        </member>
        <member name="M:Angles.TryParse(System.String,Angles@)">
            <inheritdoc cref="M:Angles.Parse(System.String)" />
        </member>
        <member name="M:Angles.TryParse(System.String,System.IFormatProvider,Angles@)">
            <inheritdoc cref="M:Angles.Parse(System.String)" />
        </member>
        <member name="M:Angles.Clamped">
            <summary>
            Returns clamped version of this object, meaning the angle on each axis is transformed to range of [0,360).
            </summary>
        </member>
        <member name="P:Angles.Normal">
            <summary>
            Returns normalized version of this object, meaning the angle on each axis is normalized to range of (-180,180].
            </summary>
        </member>
        <member name="M:Angles.ClampAngle(System.Single)">
            <summary>
            Clamps the angle to range of [0, 360)
            </summary>
        </member>
        <member name="M:Angles.NormalizeAngle(System.Single)">
            <summary>
            Normalizes the angle to range of (-180, 180]
            </summary>
        </member>
        <member name="M:Angles.Lerp(Angles@,Angles@,System.Single)">
            <summary>
            Performs linear interpolation on the two given angle objects.
            </summary>
            <param name="source">Angle A</param>
            <param name="target">Angle B</param>
            <param name="frac">Fraction in range [0,1] between the 2 angle objects to use for interpolation.</param>
        </member>
        <member name="M:Angles.LerpTo(Angles,System.Single)">
            <summary>
            Performs linear interpolation on the two given angle objects.
            </summary>
            <param name="target">Angle B</param>
            <param name="frac">Fraction in range [0,1] between the 2 angle objects to use for interpolation.</param>
        </member>
        <member name="M:Angles.AngleVector(Angles)">
            <summary>
            Converts an angle to a forward vector.
            </summary>
        </member>
        <member name="P:Angles.Forward">
            <summary>
            The forward direction vector for this angle.
            </summary>
        </member>
        <member name="M:Angles.SnapToGrid(System.Single,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Snap to grid
            </summary>
        </member>
        <member name="T:BBox">
            <summary>
            An <a href="https://en.wikipedia.org/wiki/Minimum_bounding_box">Axis Aligned Bounding Box</a>.
            </summary>
        </member>
        <member name="F:BBox.Mins">
            <summary>
            The minimum corner extents of the AABB. Values on each axis should be mathematically smaller than values on the same axis of <see cref="F:BBox.Maxs"/>. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)"/>
            </summary>
        </member>
        <member name="F:BBox.Maxs">
            <summary>
            The maximum corner extents of the AABB. Values on each axis should be mathematically larger than values on the same axis of <see cref="F:BBox.Mins"/>. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)"/>
            </summary>
        </member>
        <member name="M:BBox.#ctor(Vector3,Vector3)">
            <summary>
            Initialize an AABB with given mins and maxs corners. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)"/>.
            </summary>
        </member>
        <member name="M:BBox.#ctor(Vector3,System.Single)">
            <summary>
            Initializes a zero sized BBox with given center. This is useful if you intend to use AddPoint to expand the box later.
            </summary>
        </member>
        <member name="P:BBox.Corners">
            <summary>
            An enumerable that contains all corners of this AABB.
            </summary>
        </member>
        <member name="P:BBox.Center">
            <summary>
            Calculated center of the AABB.
            </summary>
        </member>
        <member name="P:BBox.Size">
            <summary>
            Calculated size of the AABB on each axis.
            </summary>
        </member>
        <member name="P:BBox.Extents">
            <summary>
            The extents of the bbox. This is half the size.
            </summary>
        </member>
        <member name="M:BBox.Translate(Vector3@)">
            <summary>
            Move this box by this amount and return
            </summary>
        </member>
        <member name="M:BBox.Rotate(Rotation@)">
            <summary>
            Rotate this box by this amount and return
            </summary>
        </member>
        <member name="M:BBox.Transform(Transform@)">
            <summary>
            Transform this box by this amount and return
            </summary>
        </member>
        <member name="P:BBox.RandomPointInside">
            <summary>
            Returns a random point within this AABB.
            </summary>
        </member>
        <member name="P:BBox.RandomPointOnEdge">
            <summary>
            Returns a random point within this AABB.
            </summary>
        </member>
        <member name="P:BBox.Volume">
            <summary>
            Returns the physical volume of this AABB.
            </summary>
        </member>
        <member name="M:BBox.Contains(BBox@)">
            <summary>
            Returns true if this AABB completely contains given AABB
            </summary>
        </member>
        <member name="M:BBox.Contains(Vector3@)">
            <summary>
            Returns true if this AABB contains given point
            </summary>
        </member>
        <member name="M:BBox.Overlaps(BBox@)">
            <summary>
            Returns true if this AABB somewhat overlaps given AABB
            </summary>
        </member>
        <member name="M:BBox.AddPoint(Vector3@)">
            <summary>
            Returns this bbox but stretched to include given point
            </summary>
        </member>
        <member name="M:BBox.AddBBox(BBox@)">
            <summary>
            Returns this bbox but stretched to include given bbox
            </summary>
        </member>
        <member name="M:BBox.Grow(System.Single@)">
            <summary>
            Return a slightly bigger box
            </summary>
        </member>
        <member name="M:BBox.ClosestPoint(Vector3@)">
            <summary>
            Returns the closest point on this AABB to another point
            </summary>
        </member>
        <member name="M:BBox.FromHeightAndRadius(System.Single,System.Single)">
            <summary>
            Creates an AABB of <paramref name="radius"/> length and depth, and given <paramref name="height"/>
            </summary>
        </member>
        <member name="M:BBox.FromPositionAndSize(Vector3@,System.Single)">
            <summary>
            Creates an AABB at given position <paramref name="center"/> and given <paramref name="size"/> which acts as a <b>diameter</b> of a sphere contained within the AABB.
            </summary>
        </member>
        <member name="M:BBox.FromPositionAndSize(Vector3,Vector3)">
            <summary>
            Creates an AABB at given position <paramref name="center"/> and given <paramref name="size"/> a.k.a. "extents".
            </summary>
        </member>
        <member name="M:BBox.FromBoxes(System.Collections.Generic.IEnumerable{BBox})">
            <summary>
            Create a bounding box from an arbituary number of other boxes
            </summary>
        </member>
        <member name="M:BBox.FromPoints(System.Collections.Generic.IEnumerable{Vector3},System.Single)">
            <summary>
            Create a bounding box from an arbituary number of points
            </summary>
        </member>
        <member name="M:BBox.Trace(Ray@,System.Single,System.Single@)">
            <summary>
            Trace a ray against this box. If hit then return the distance.
            </summary>
        </member>
        <member name="M:BBox.ToString">
            <summary>
            Formats this AABB into a string "mins x,y,z, maxs x,y,z"
            </summary>
        </member>
        <member name="M:BBox.GetVolume">
            <summary>
            Get the volume of this AABB
            </summary>
        </member>
        <member name="M:BBox.Snap(System.Single)">
            <summary>
            Snap this AABB to a grid
            </summary>
        </member>
        <member name="T:Capsule">
            <summary>
            A capsule object, defined by 2 points and a radius. A capsule is a cylinder with round ends (inset half spheres on each end).
            </summary>
        </member>
        <member name="F:Capsule.CenterA">
            <summary>
            Position of point A.
            </summary>
        </member>
        <member name="F:Capsule.CenterB">
            <summary>
            Position of point B.
            </summary>
        </member>
        <member name="F:Capsule.Radius">
            <summary>
            Radius of a capsule.
            </summary>
        </member>
        <member name="M:Capsule.FromHeightAndRadius(System.Single,System.Single)">
            <summary>
            Creates a capsule where Point A is radius units above the ground and Point B is height minus radius units above the ground.
            </summary>
        </member>
        <member name="P:Capsule.RandomPointInside">
            <summary>
            Returns a random point within this capsule.
            </summary>
        </member>
        <member name="P:Capsule.RandomPointOnEdge">
            <summary>
            Returns a random point on the edge of this capsule.
            </summary>
        </member>
        <member name="T:Line">
            <summary>
            Represents a line in 3D space.
            </summary>
        </member>
        <member name="P:Line.Start">
            <summary>
            Start position of the line.
            </summary>
        </member>
        <member name="P:Line.End">
            <summary>
            End position of the line.
            </summary>
        </member>
        <member name="P:Line.Delta">
            <summary>
            Returns the result of b - a
            </summary>
        </member>
        <member name="P:Line.Center">
            <summary>
            Returns the midpoint between a and b
            </summary>
        </member>
        <member name="M:Line.Trace(Ray@,System.Single,System.Single)">
            <summary>
            Perform a "trace" between this line and given ray. If the 2 lines intersect, returns true.
            </summary>
            <param name="ray">The ray to test against.</param>
            <param name="radius">Radius of this line, which essentially makes this a capsule, since direct line-to-line intersections are very improbable. Must be above 0.</param>
            <param name="maxDistance">Maximum allowed distance from the origin of the ray to the intersection.</param>
            <returns>Whether there was an intersection or not.</returns>
        </member>
        <member name="M:Line.ClosestPoint(Vector3@)">
            <summary>
            Returns closest point on this line to the given point.
            </summary>
        </member>
        <member name="M:Line.ClosestPoint(Ray@,Vector3@)">
            <summary>
            Returns closest point on this line to the given ray.
            </summary>
        </member>
        <member name="M:Line.ClosestPoint(Ray@,Vector3@,Vector3@)">
            <summary>
            Returns closest point on this line to the given ray.
            </summary>
        </member>
        <member name="M:Line.Distance(Vector3)">
            <summary>
            Returns closest distance from this line to given point.
            </summary>
        </member>
        <member name="M:Line.Distance(Vector3,Vector3@)">
            <summary>
            Returns closest distance from this line to given point.
            </summary>
        </member>
        <member name="M:Line.Clip(Sandbox.Plane)">
            <summary>
            Returns this line, clamped on the positive side of a plane. Null if
            line is fully clipped.
            </summary>
        </member>
        <member name="M:Line.SqrDistance(Vector3)">
            <summary>
            Returns closest squared distance from this line to given point.
            </summary>
        </member>
        <member name="T:Matrix">
            <summary>
            Represents a 4x4 matrix.
            </summary>
        </member>
        <member name="P:Matrix.Identity">
            <summary>
            Returns the multiplicative identity matrix.
            </summary>
        </member>
        <member name="P:Matrix.Inverted">
            <summary>
            Returns inverse of this matrix.
            </summary>
        </member>
        <member name="M:Matrix.Lerp(Matrix,Matrix,System.Single)">
            <summary>
            Performs linear interpolation from one matrix to another.
            </summary>
        </member>
        <member name="M:Matrix.Slerp(Matrix,Matrix,System.Single)">
            <summary>
            Performs spherical interpolation from one matrix to another.
            </summary>
        </member>
        <member name="M:Matrix.ToString">
            <summary>
            Formats the matrix and returns it as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Matrix.Transpose">
            <summary>
            Returns transposed version of this matrix, meaning columns in this matrix become rows in the returned matrix and rows in this matrix become columns in the returned one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Matrix.Transform(Vector3)">
            <summary>
            Transforms a vector by a 4x4 matrix
            </summary>
        </member>
        <member name="M:Matrix.TransformNormal(Vector3)">
            <summary>
            Transforms a normal vector by a specified 4x4 matrix
            </summary>
        </member>
        <member name="P:Matrix.ToSteamVrCoordinateSystem">
            <summary>
            Converts a <see cref="T:Matrix"/> from Source to SteamVr coordinate system and scale
            </summary>
            <remarks>
            Source: X=forwards, Y=left, Z=up, scale = inches.
            SteamVr: X=right, Y=up, Z=backwards, scale = meters.
            </remarks>
        </member>
        <member name="T:QRectF">
            <summary>
            You're not seeing things, QT uses fucking doubles
            </summary>
        </member>
        <member name="T:RangedFloat">
            <summary>
            A float between two values, which can be randomized or fixed.
            </summary>
        </member>
        <member name="F:RangedFloat.x">
            <summary>
            The minimum value of the float range.
            </summary>
        </member>
        <member name="F:RangedFloat.y">
            <summary>
            The maximum value of the float range.
            </summary>
        </member>
        <member name="P:RangedFloat.FixedValue">
            <summary>
            The fixed value. Setting this will convert us to a fixed value
            </summary>
        </member>
        <member name="P:RangedFloat.RangeValue">
            <summary>
            The range value. Setting this will convert us to a range value
            </summary>
        </member>
        <member name="T:RangedFloat.RangeType">
            <summary>
            Range type of <see cref="T:RangedFloat"/>.
            </summary>
        </member>
        <member name="F:RangedFloat.RangeType.Fixed">
            <summary>
            Single value, both minimum and maximum value.
            </summary>
        </member>
        <member name="F:RangedFloat.RangeType.Between">
            <summary>
            Random value between given minimum and maximum.
            </summary>
        </member>
        <member name="P:RangedFloat.Range">
            <summary>
            Range type of this float.
            </summary>
        </member>
        <member name="M:RangedFloat.#ctor(System.Single)">
            <summary>
            Initialize the float as a fixed value.
            </summary>
        </member>
        <member name="M:RangedFloat.#ctor(System.Single,System.Single)">
            <summary>
            Initialize the float as a random value between given min and max.
            </summary>
            <param name="min">The minimum possible value for this float.</param>
            <param name="max">The maximum possible value for this float.</param>
        </member>
        <member name="M:RangedFloat.GetValue">
            <summary>
            Returns the final value of this ranged float, randomizing between min and max values.
            </summary>
        </member>
        <member name="M:RangedFloat.Parse(System.String)">
            <summary>
            Parse a ranged float from a string. Format is <c>"min max rangetype"</c>.
            </summary>
        </member>
        <member name="T:Ray">
            <summary>
            A struct describing an origin and direction
            </summary>
        </member>
        <member name="P:Ray.Position">
            <summary>
            Origin of the ray.
            </summary>
        </member>
        <member name="P:Ray.Forward">
            <summary>
            Direction of the ray.
            </summary>
        </member>
        <member name="M:Ray.ToLocal(Transform@)">
            <summary>
            Convert a ray to be local to this transform
            </summary>
        </member>
        <member name="M:Ray.ToWorld(Transform@)">
            <summary>
            Convert a ray from being local to this transform
            </summary>
        </member>
        <member name="M:Ray.Project(System.Single)">
            <summary>
            Returns a point on the ray at given distance.
            </summary>
            <param name="distance">How far from the <see cref="P:Ray.Position"/> the point should be.</param>
            <returns>The point at given distance.</returns>
        </member>
        <member name="T:Rect3D">
            <summary>
            Generally used to describe the size of textures
            </summary>
        </member>
        <member name="T:Rotation">
            <summary>
            Represents a Quaternion rotation. Can be interpreted as a direction unit vector (x,y,z) + rotation around the direction vector (w) which represents the up direction.
            Unlike <see cref="T:Angles"/>, this cannot store multiple revolutions around an axis.
            </summary>
        </member>
        <member name="P:Rotation.x">
            <summary>
            The X component of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.y">
            <summary>
            The Y component of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.z">
            <summary>
            The Z component of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.w">
            <summary>
            The W component of this rotation (rotation around the normal defined by X,Y,Z components).
            </summary>
        </member>
        <member name="M:Rotation.#ctor">
            <summary>
            Initializes this rotation with all components set to zero.
            </summary>
        </member>
        <member name="M:Rotation.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes the rotation from given components.
            </summary>
            <param name="x">The X component.</param>
            <param name="y">The Y component.</param>
            <param name="z">The Z component.</param>
            <param name="w">The W component.</param>
        </member>
        <member name="M:Rotation.#ctor(Vector3,System.Single)">
            <summary>
            Initializes the rotation from a normal vector + rotation around it.
            </summary>
            <param name="v">The normal vector.</param>
            <param name="w">The W component, aka rotation around the normal vector.</param>
        </member>
        <member name="P:Rotation.Forward">
            <summary>
            The forwards direction of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.Backward">
            <summary>
            The backwards direction of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.Right">
            <summary>
            The right hand direction of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.Left">
            <summary>
            The left hand direction of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.Up">
            <summary>
            The upwards direction of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.Down">
            <summary>
            The downwards direction of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.Inverse">
            <summary>
            Returns the inverse of this rotation.
            </summary>
        </member>
        <member name="P:Rotation.Normal">
            <summary>
            Divides each component of the rotation by its length, normalizing the rotation.
            </summary>
        </member>
        <member name="P:Rotation.Conjugate">
            <summary>
            Returns conjugate of this rotation, meaning the X Y and Z components are negated.
            </summary>
        </member>
        <member name="P:Rotation.Random">
            <summary>
            Returns a uniformly random rotation.
            </summary>
        </member>
        <member name="M:Rotation.FromAxis(Vector3,System.Single)">
            <summary>
            Create from angle and an axis
            </summary>
            <remarks><paramref name="axis" /> vector must be normalized before calling this method or the resulting <see cref="T:Rotation" /> will be incorrect.</remarks>
        </member>
        <member name="M:Rotation.From(Angles)">
            <summary>
            Create a Rotation (quaternion) from Angles
            </summary>
        </member>
        <member name="M:Rotation.From(System.Single,System.Single,System.Single)">
            <summary>
            Create a Rotation (quaternion) from pitch yaw roll (degrees)
            </summary>
        </member>
        <member name="M:Rotation.FromPitch(System.Single)">
            <summary>
            Create a Rotation (quaternion) from pitch (degrees)
            </summary>
        </member>
        <member name="M:Rotation.FromYaw(System.Single)">
            <summary>
            Create a Rotation (quaternion) from yaw (degrees)
            </summary>
        </member>
        <member name="M:Rotation.FromRoll(System.Single)">
            <summary>
            Create a Rotation (quaternion) from roll (degrees)
            </summary>
        </member>
        <member name="M:Rotation.LookAt(Vector3,Vector3)">
            <summary>
            Create a Rotation (quaternion) from a forward and up vector
            </summary>
        </member>
        <member name="M:Rotation.LookAt(Vector3)">
            <summary>
            Create a Rotation (quaternion) from a forward vector, using <see cref="F:Vector3.Up"/> as
            an up vector. This won't give nice results if <paramref name="forward"/> is very close to straight
            up or down, if that can happen you should use <see cref="M:Rotation.LookAt(Vector3,Vector3)"/>.
            </summary>
        </member>
        <member name="F:Rotation.Identity">
            <summary>
            A rotation that represents no rotation.
            </summary>
        </member>
        <member name="M:Rotation.Difference(Rotation,Rotation)">
            <summary>
            Returns the difference between two rotations, as a rotation
            </summary>
        </member>
        <member name="M:Rotation.Distance(Rotation)">
            <summary>
            The degree angular distance between this rotation and the target
            </summary>
        </member>
        <member name="M:Rotation.Angle">
            <summary>
            Returns the turn length of this rotation (from identity) in degrees
            </summary>
        </member>
        <member name="M:Rotation.Angles">
            <summary>
            Return this Rotation as pitch, yaw, roll angles
            </summary>
        </member>
        <member name="M:Rotation.Pitch">
            <summary>
            Return this Rotation pitch
            </summary>
        </member>
        <member name="M:Rotation.Yaw">
            <summary>
            Return this Rotation yaw
            </summary>
        </member>
        <member name="M:Rotation.Roll">
            <summary>
            Return this Rotation roll
            </summary>
        </member>
        <member name="M:Rotation.Lerp(Rotation,Rotation,System.Single,System.Boolean)">
            <summary>
            Perform a linear interpolation from a to b by given amount.
            </summary>
        </member>
        <member name="M:Rotation.Slerp(Rotation,Rotation,System.Single,System.Boolean)">
            <summary>
            Perform a spherical interpolation from a to b by given amount.
            </summary>
        </member>
        <member name="M:Rotation.Clamp(Rotation,System.Single)">
            <summary>
            Clamp to within degrees of passed rotation
            </summary>
        </member>
        <member name="M:Rotation.Clamp(Rotation,System.Single,System.Single@)">
            <summary>
            Clamp to within degrees of passed rotation. Also pases out the change in degrees, if any.
            </summary>
        </member>
        <member name="M:Rotation.RotateAroundAxis(Vector3,System.Single)">
            <summary>
            A convenience function that rotates this rotation around a given axis given amount of degrees
            </summary>
            <remarks><paramref name="axis" /> vector must be normalized before calling this method or the resulting <see cref="T:Rotation" /> will be incorrect.</remarks>
        </member>
        <member name="M:Rotation.SmoothDamp(Rotation,Rotation@,Vector3@,System.Single,System.Single)">
            <summary>
            Smoothly move towards the target rotation
            </summary>
        </member>
        <member name="M:Rotation.ClosestAxis(Vector3)">
            <summary>
            Will give you the axis most aligned with the given normal
            </summary>
        </member>
        <member name="M:Rotation.FromToRotation(Vector3@,Vector3@)">
            <summary>
            Returns a Rotation that rotates from one direction to another.
            </summary>
        </member>
        <member name="M:Rotation.Parse(System.String)">
            <summary>
            Given a string, try to convert this into a quaternion rotation. The format is "x,y,z,w"
            </summary>
        </member>
        <member name="M:Rotation.Parse(System.String,System.IFormatProvider)">
            <inheritdoc cref="M:Rotation.Parse(System.String)" />
        </member>
        <member name="M:Rotation.TryParse(System.String,Rotation@)">
            <inheritdoc cref="M:Rotation.Parse(System.String)" />
        </member>
        <member name="M:Rotation.TryParse(System.String,System.IFormatProvider,Rotation@)">
            <inheritdoc cref="M:Rotation.Parse(System.String)" />
        </member>
        <member name="T:Transform">
            <summary>
            A struct containing a position, rotation and scale. This is commonly used in engine to describe
            entity position, bone position and scene object position.
            </summary>
        </member>
        <member name="F:Transform.Zero">
            <summary>
            Represents a zero transform, that being, a transform with scale of 1, position of <see cref="F:Vector3.Zero"/> and rotation of <see cref="F:Rotation.Identity"/>.
            </summary>
        </member>
        <member name="F:Transform.Position">
            <summary>
            Position of the transform.
            </summary>
        </member>
        <member name="F:Transform.Scale">
            <summary>
            Scale of the transform. Does not itself scale <see cref="F:Transform.Position"/> or <see cref="F:Transform.Rotation"/>.
            </summary>
        </member>
        <member name="P:Transform.UniformScale">
            <summary>
            A uniform scale component. Generally the scale is uniform, and we'll just access the .x component.
            </summary>
        </member>
        <member name="F:Transform.Rotation">
            <summary>
            Rotation of this transform.
            </summary>
        </member>
        <member name="P:Transform.IsValid">
            <summary>
            Returns true if position, scale and rotation are valid
            </summary>
        </member>
        <member name="M:Transform.PointToLocal(Vector3)">
            <summary>
            Convert a point in world space to a point in this transform's local space
            </summary>
        </member>
        <member name="M:Transform.NormalToLocal(Vector3)">
            <summary>
            Convert a world normal to a local normal
            </summary>
        </member>
        <member name="M:Transform.RotationToLocal(Rotation)">
            <summary>
            Convert a world rotation to a local rotation
            </summary>
        </member>
        <member name="M:Transform.PointToWorld(Vector3)">
            <summary>
            Convert a point in this transform's local space to a point in world space
            </summary>
        </member>
        <member name="M:Transform.NormalToWorld(Vector3)">
            <summary>
            Convert a local normal to a world normal
            </summary>
        </member>
        <member name="M:Transform.RotationToWorld(Rotation)">
            <summary>
            Convert a local rotation to a world rotation
            </summary>
        </member>
        <member name="M:Transform.ToLocal(Transform)">
            <summary>
            Convert child transform from the world to a local transform
            </summary>
        </member>
        <member name="M:Transform.ToWorld(Transform)">
            <summary>
            Convert child transform from local to the world
            </summary>
        </member>
        <member name="M:Transform.Lerp(Transform,Transform,System.Single,System.Boolean)">
            <summary>
            Perform linear interpolation from one transform to another.
            </summary>
        </member>
        <member name="M:Transform.Add(Vector3,System.Boolean)">
            <summary>
            Add a position to this transform and return the result.
            </summary>
        </member>
        <member name="M:Transform.WithPosition(Vector3)">
            <summary>
            Return this transform with a new position.
            </summary>
        </member>
        <member name="M:Transform.WithPosition(Vector3,Rotation)">
            <summary>
            Return this transform with a new position and rotation
            </summary>
        </member>
        <member name="M:Transform.WithRotation(Rotation)">
            <summary>
            Return this transform with a new rotation.
            </summary>
        </member>
        <member name="M:Transform.WithScale(System.Single)">
            <summary>
            Return this transform with a new scale.
            </summary>
        </member>
        <member name="M:Transform.WithScale(Vector3)">
            <summary>
            Return this transform with a new scale.
            </summary>
        </member>
        <member name="P:Transform.ForwardRay">
            <summary>
            Return a ray from this transform, which goes from the center along the Forward
            </summary>
        </member>
        <member name="M:Transform.RotateAround(Vector3,Rotation)">
            <summary>
            Rotate this transform around given point by given rotation and return the result.
            </summary>
            <param name="center">Point to rotate around.</param>
            <param name="rot">How much to rotate by. <see cref="M:Rotation.FromAxis(Vector3,System.Single)"/> can be useful.</param>
            <returns>The rotated transform.</returns>
        </member>
        <member name="M:Transform.Concat(Transform,Transform)">
            <summary>
            Concatenate (add together) the 2 given transforms and return a new resulting transform.
            </summary>
        </member>
        <member name="M:Transform.Parse(System.String)">
            <summary>
            Given a string, try to convert this into a transform. The format is <c>"px,py,pz,rx,ry,rz,rw"</c>.
            </summary>
        </member>
        <member name="M:Transform.ToString">
            <summary>
            Formats the Transform into a string "pos, rot, scale"
            </summary>
        </member>
        <member name="T:Vector2">
            <summary>
            A 2-dimensional vector. Typically represents a position or size in 2D space.
            </summary>
        </member>
        <member name="P:Vector2.x">
            <summary>
            X component of this Vector.
            </summary>
        </member>
        <member name="P:Vector2.y">
            <summary>
            Y component of this Vector.
            </summary>
        </member>
        <member name="M:Vector2.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a 2D vector with given components.
            </summary>
            <param name="x">The X component.</param>
            <param name="y">The Y component.</param>
        </member>
        <member name="M:Vector2.#ctor(System.Single)">
            <summary>
            Initializes the vector with all components set to the given value.
            </summary>
        </member>
        <member name="M:Vector2.#ctor(Vector3)">
            <summary>
            Initializes the 2D vector with components from given 3D vector, discarding the Z component.
            </summary>
        </member>
        <member name="P:Vector2.One">
            <summary>
            Returns a 2D vector with every component set to 1
            </summary>
        </member>
        <member name="P:Vector2.Zero">
            <summary>
            Returns a 2D vector with every component set to 0
            </summary>
        </member>
        <member name="P:Vector2.Up">
            <summary>
            Returns a 2D vector with Y set to 1. This represents the upwards direction in 2D space.
            </summary>
        </member>
        <member name="P:Vector2.Down">
            <summary>
            Returns a 2D vector with Y set to -1. This represents the downwards direction in 2D space.
            </summary>
        </member>
        <member name="P:Vector2.Left">
            <summary>
            Returns a 2D vector with X set to 1. This represents the left hand direction in 2D space.
            </summary>
        </member>
        <member name="P:Vector2.Right">
            <summary>
            Returns a 2D vector with X set to -1. This represents the right hand direction in 2D space.
            </summary>
        </member>
        <member name="P:Vector2.Random">
            <summary>
            Uniformly samples a 2D position from all points with distance at most 1 from the origin.
            </summary>
        </member>
        <member name="P:Vector2.Length">
            <summary>
            Returns the magnitude of the vector
            </summary>
        </member>
        <member name="P:Vector2.LengthSquared">
            <summary>
            This is faster than Length, so is better to use in certain circumstances
            </summary>
        </member>
        <member name="P:Vector2.Perpendicular">
            <summary>
            Returns a vector that runs perpendicular to this one
            </summary>
        </member>
        <member name="P:Vector2.IsNearZeroLength">
            <summary>
            Returns true if the squared length is less than 1e-8 (which is really near zero)
            </summary>
        </member>
        <member name="P:Vector2.Normal">
            <summary>
            Return the same vector but with a length of one
            </summary>
        </member>
        <member name="P:Vector2.Degrees">
            <summary>
            Return the angle of this vector in degrees, always between 0 and 360
            </summary>
        </member>
        <member name="M:Vector2.FromRadians(System.Single)">
            <summary>
            Returns a point on a circle at given rotation from X axis, counter clockwise.
            </summary>
        </member>
        <member name="M:Vector2.FromDegrees(System.Single)">
            <summary>
            Returns a point on a circle at given rotation from X axis, counter clockwise.
            </summary>
        </member>
        <member name="M:Vector2.DistanceBetween(Vector2,Vector2)">
            <summary>
            Returns distance between the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector2.Distance(Vector2@,Vector2@)">
            <summary>
            Returns distance between the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector2.Distance(Vector2)">
            <summary>
            Returns distance between this and given vectors.
            </summary>
        </member>
        <member name="M:Vector2.DistanceBetweenSquared(Vector2,Vector2)">
            <summary>
            Returns squared distance between the 2 given vectors. This is faster than <see cref="M:Vector2.DistanceBetween(Vector2,Vector2)">DistanceBetween</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
        </member>
        <member name="M:Vector2.DistanceSquared(Vector2@,Vector2@)">
            <summary>
            Returns squared distance between the 2 given vectors. This is faster than <see cref="M:Vector2.DistanceBetween(Vector2,Vector2)">DistanceBetween</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
        </member>
        <member name="M:Vector2.DistanceSquared(Vector2)">
            <summary>
            Returns squared distance between the 2 given vectors. This is faster than <see cref="M:Vector2.Distance(Vector2)">Distance</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
        </member>
        <member name="M:Vector2.Dot(Vector2,Vector2)">
            <summary>
            Returns dot product between the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector2.AlmostEqual(Vector2,System.Single)">
            <summary>
            Returns true if we're nearly equal to the passed vector.
            </summary>
            <param name="v">The value to compare with</param>
            <param name="delta">The max difference between component values</param>
            <returns>True if nearly equal</returns>
        </member>
        <member name="M:Vector2.SnapToGrid(System.Single,System.Boolean,System.Boolean)">
            <summary>
            Snap to grid along all 3 axes.
            </summary>
        </member>
        <member name="M:Vector2.WithX(System.Single)">
            <summary>
            Return this vector with given X.
            </summary>
        </member>
        <member name="M:Vector2.WithY(System.Single)">
            <summary>
            Return this vector with given Y.
            </summary>
        </member>
        <member name="M:Vector2.Lerp(Vector2,Vector2,System.Single,System.Boolean)">
            <summary>
            Linearly interpolate from point a to point b.
            </summary>
        </member>
        <member name="M:Vector2.LerpTo(Vector2,System.Single,System.Boolean)">
            <summary>
            Linearly interpolate from this vector to given vector.
            </summary>
        </member>
        <member name="M:Vector2.Lerp(Vector2,Vector2,Vector2,System.Boolean)">
            <summary>
            Linearly interpolate from point a to point b with separate fraction for each axis.
            </summary>
        </member>
        <member name="M:Vector2.LerpTo(Vector2,Vector2,System.Boolean)">
            <summary>
            Linearly interpolate from this vector to given vector with separate fraction for each axis.
            </summary>
        </member>
        <member name="M:Vector2.Clamp(Vector2,Vector2)">
            <summary>
            Returns a vector each axis of which is clamped to between the 2 given vectors. Basically clamps a point to a square.
            </summary>
            <param name="otherMin">The mins vector. Values on each axis should be smaller than those of the maxs vector.</param>
            <param name="otherMax">The maxs vector. Values on each axis should be bigger than those of the mins vector.</param>
        </member>
        <member name="M:Vector2.Clamp(System.Single,System.Single)">
            <summary>
            Returns a vector each axis of which is clamped to given min and max values.
            </summary>
            <param name="min">Minimum value for each axis.</param>
            <param name="max">Maximum value for each axis.</param>
        </member>
        <member name="M:Vector2.Remap(Sandbox.Rect,Sandbox.Rect,System.Boolean)">
            <summary>
            Remaps from one range to another.
            </summary>
        </member>
        <member name="M:Vector2.ComponentMin(Vector2)">
            <summary>
            Returns a vector that has the minimum values on each axis between this vector and given vector.
            </summary>
        </member>
        <member name="M:Vector2.Min(Vector2,Vector2)">
            <summary>
            Returns a vector that has the minimum values on each axis between the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector2.ComponentMax(Vector2)">
            <summary>
            Returns a vector that has the maximum values on each axis between this vector and given vector.
            </summary>
        </member>
        <member name="M:Vector2.Max(Vector2,Vector2)">
            <summary>
            Returns a vector that has the maximum values on each axis between the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector2.Abs">
            <summary>
            Returns a new vector with all values positive. -5 becomes 5, etc.
            </summary>
        </member>
        <member name="M:Vector2.Parse(System.String)">
            <summary>
            Given a string, try to convert this into a Vector2. Example formatting is "x,y", "[x,y]", "x y", etc.
            </summary>
        </member>
        <member name="M:Vector2.TryParse(System.String,Vector2@)">
            <inheritdoc cref="M:Vector2.Parse(System.String)" />
        </member>
        <member name="M:Vector2.Parse(System.String,System.IFormatProvider)">
            <inheritdoc cref="M:Vector2.Parse(System.String)" />
        </member>
        <member name="M:Vector2.TryParse(System.String,System.IFormatProvider,Vector2@)">
            <inheritdoc cref="M:Vector2.Parse(System.String)" />
        </member>
        <member name="F:Vector2Int.x">
            <summary>
            The X component of this integer vector.
            </summary>
        </member>
        <member name="F:Vector2Int.y">
            <summary>
            The Y component of this integer vector.
            </summary>
        </member>
        <member name="M:Vector2Int.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes an integer vector with given components.
            </summary>
            <param name="x">The X component.</param>
            <param name="y">The Y component.</param>
        </member>
        <member name="M:Vector2Int.#ctor(System.Int32)">
            <summary>
            Initializes an integer vector with all components set to the same value.
            </summary>
            <param name="all">The value of the X and Y components.</param>
        </member>
        <member name="M:Vector2Int.#ctor(Vector2Int)">
            <summary>
            Initializes an integer vector with given components from another integer vector.
            </summary>
        </member>
        <member name="M:Vector2Int.#ctor(Vector3Int)">
            <summary>
            Initializes an integer vector with given components from another integer vector, discarding the Z component.
            </summary>
        </member>
        <member name="F:Vector2Int.One">
            <summary>
            An integer vector with all components set to 1.
            </summary>
        </member>
        <member name="F:Vector2Int.Zero">
            <summary>
            An integer vector with all components set to 0.
            </summary>
        </member>
        <member name="F:Vector2Int.Right">
            <summary>
            An integer vector with X set to 1. This represents the right direction.
            </summary>
        </member>
        <member name="F:Vector2Int.Left">
            <summary>
            An integer vector with X set to -1. This represents the left direction.
            </summary>
        </member>
        <member name="F:Vector2Int.Up">
            <summary>
            An integer vector with Y set to 1. This represents the up direction.
            </summary>
        </member>
        <member name="F:Vector2Int.Down">
            <summary>
            An integer vector with Y set to -1. This represents the down direction.
            </summary>
        </member>
        <member name="M:Vector2Int.ToString">
            <summary>
            Formats the integer vector as a string "x,y".
            </summary>
            <returns></returns>
        </member>
        <member name="P:Vector2Int.Normal">
            <summary>
             Returns a unit version of this vector. Keep in mind this returns a Vector2 and not a Vector2Int.
            </summary>
        </member>
        <member name="P:Vector2Int.Degrees">
            <summary>
            Return the angle of this vector in degrees, always between 0 and 360.
            </summary>
        </member>
        <member name="P:Vector2Int.Length">
            <summary>
            Length (or magnitude) of the integer vector (Distance from 0,0)
            </summary>
        </member>
        <member name="P:Vector2Int.LengthSquared">
            <summary>
            Squared length of the integer vector. This is faster than <see cref="P:Vector2Int.Length">Length</see>, and can be used for things like comparing distances, as long as only squared values are used."/>
            </summary>
        </member>
        <member name="P:Vector2Int.Perpendicular">
            <summary>
            Returns an integer vector that runs perpendicular to this one.
            </summary>
        </member>
        <member name="P:Vector2Int.IsZeroLength">
            <summary>
            Whether the length of this vector is zero or not.
            </summary>
        </member>
        <member name="M:Vector2Int.IsNearlyZero(System.Int32)">
            <summary>
            Returns true if value on every axis is less than or equal to tolerance
            </summary>
        </member>
        <member name="M:Vector2Int.ComponentMin(Vector2Int)">
            <summary>
            Returns an integer vector that has the minimum values on each axis of the two input vectors.
            </summary>
        </member>
        <member name="M:Vector2Int.ComponentMax(Vector2Int)">
            <summary>
            Returns an integer vector that has the maximum values on each axis of the two input vectors.
            </summary>
        </member>
        <member name="M:Vector2Int.Distance(Vector2Int)">
            <summary>
            Returns the distance between this vector and another.
            </summary>
        </member>
        <member name="M:Vector2Int.Distance(Vector2)">
            <summary>
            Returns the distance between this vector and another.
            </summary>
        </member>
        <member name="M:Vector2Int.SnapToGrid(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Snap to grid along any of the 2 axes.
            </summary>
        </member>
        <member name="M:Vector2Int.Min(Vector2Int,Vector2Int)">
            <summary>
            Returns an integer vector that has the minimum values on each axis between 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector2Int.Max(Vector2Int,Vector2Int)">
            <summary>
            Returns an integer vector that has the maximum values on each axis between 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector2Int.Abs">
            <summary>
            Returns a new integer vector with all values positive. -5 becomes 5, ect.
            </summary>
        </member>
        <member name="M:Vector2Int.WithX(System.Int32)">
            <summary>
            Returns this integer vector with given X component.
            </summary>
        </member>
        <member name="M:Vector2Int.WithY(System.Int32)">
            <summary>
            Returns this integer vector with given Y component.
            </summary>
        </member>
        <member name="M:Vector2Int.Parse(System.String)">
            <summary>
            Given a string, try to convert this into a Vector2Int. Example formatting is "x,y", "[x,y]", "x y", etc.
            </summary>
        </member>
        <member name="M:Vector2Int.Parse(System.String,System.IFormatProvider)">
            <inheritdoc cref="M:Vector2Int.Parse(System.String)" />
        </member>
        <member name="M:Vector2Int.TryParse(System.String,System.IFormatProvider,Vector2Int@)">
            <inheritdoc cref="M:Vector2Int.Parse(System.String)" />
        </member>
        <member name="T:Vector3">
            <summary>
            A point in 3D space.
            </summary>
        </member>
        <member name="P:Vector3.x">
            <summary>
            The X component of this Vector.
            </summary>
        </member>
        <member name="P:Vector3.y">
            <summary>
            The Y component of this Vector.
            </summary>
        </member>
        <member name="P:Vector3.z">
            <summary>
            The Z component of this Vector.
            </summary>
        </member>
        <member name="M:Vector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a vector with given components.
            </summary>
            <param name="x">The X component.</param>
            <param name="y">The Y component.</param>
            <param name="z">The Z component.</param>
        </member>
        <member name="M:Vector3.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a vector with given components and Z set to 0.
            </summary>
            <param name="x">The X component.</param>
            <param name="y">The Y component.</param>
        </member>
        <member name="M:Vector3.#ctor(Vector3@)">
            <summary>
            Initializes a vector3 from a given vector3, i.e. a copy.
            </summary>
        </member>
        <member name="M:Vector3.#ctor(Vector2@,System.Single)">
            <summary>
            Initializes a vector3 from given vector2 and the given Z component.
            </summary>
        </member>
        <member name="M:Vector3.#ctor(System.Single)">
            <summary>
            Initializes the vector with all components set to given value.
            </summary>
        </member>
        <member name="F:Vector3.One">
            <summary>
            A vector with all components set to 1.
            </summary>
        </member>
        <member name="F:Vector3.Zero">
            <summary>
            A vector with all components set to 0.
            </summary>
        </member>
        <member name="F:Vector3.Forward">
            <summary>
            A vector with X set to 1. This represents the forwards direction.
            </summary>
        </member>
        <member name="F:Vector3.Backward">
            <summary>
            A vector with X set to -1. This represents the backwards direction.
            </summary>
        </member>
        <member name="F:Vector3.Up">
            <summary>
            A vector with Z set to 1. This represents the upwards direction.
            </summary>
        </member>
        <member name="F:Vector3.Down">
            <summary>
            A vector with Z set to -1. This represents the downwards direction.
            </summary>
        </member>
        <member name="F:Vector3.Right">
            <summary>
            A vector with Y set to -1. This represents the right hand direction.
            </summary>
        </member>
        <member name="F:Vector3.Left">
            <summary>
            A vector with Y set to 1. This represents the left hand direction.
            </summary>
        </member>
        <member name="M:Vector3.ToString">
            <summary>
            Formats the Vector into a string "x,y,z"
            </summary>
            <returns></returns>
        </member>
        <member name="P:Vector3.Normal">
            <summary>
            Returns a unit version of this vector. A unit vector has length of 1.
            </summary>
        </member>
        <member name="P:Vector3.Random">
            <summary>
            Uniformly samples a 3D position from all points with distance at most 1 from the origin.
            </summary>
        </member>
        <member name="P:Vector3.IsNaN">
            <summary>
            Returns true if x, y or z are NaN
            </summary>
        </member>
        <member name="M:Vector3.WithX(System.Single)">
            <summary>
            Returns this vector with given X component.
            </summary>
            <param name="x">The override for X component.</param>
            <returns>The new vector.</returns>
        </member>
        <member name="M:Vector3.WithY(System.Single)">
            <summary>
            Returns this vector with given Y component.
            </summary>
            <param name="y">The override for Y component.</param>
            <returns>The new vector.</returns>
        </member>
        <member name="M:Vector3.WithZ(System.Single)">
            <summary>
            Returns this vector with given Z component.
            </summary>
            <param name="z">The override for Z component.</param>
            <returns>The new vector.</returns>
        </member>
        <member name="P:Vector3.Length">
            <summary>
            Length (or magnitude) of the vector (Distance from 0,0,0).
            </summary>
        </member>
        <member name="P:Vector3.LengthSquared">
            <summary>
            Squared length of the vector. This is faster than <see cref="P:Vector3.Length">Length</see>, and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
        </member>
        <member name="P:Vector3.IsNearZeroLength">
            <summary>
            Whether length of this vector is nearly zero.
            </summary>
        </member>
        <member name="M:Vector3.IsNearlyZero(System.Single)">
            <summary>
            Returns true if value on every axis is less than tolerance away from zero
            </summary>
        </member>
        <member name="M:Vector3.ClampLength(System.Single)">
            <summary>
            Returns a vector whose length is limited to given maximum.
            </summary>
        </member>
        <member name="M:Vector3.ClampLength(System.Single,System.Single)">
            <summary>
            Returns a vector whose length is limited between given minimum and maximum.
            </summary>
        </member>
        <member name="M:Vector3.Clamp(Vector3,Vector3)">
            <summary>
            Returns a vector each axis of which is clamped to between the 2 given vectors. Basically clamps a point to an Axis Aligned Bounding Box (AABB).
            </summary>
            <param name="otherMin">The mins vector. Values on each axis should be smaller than those of the maxs vector. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)">Vector3.Sort</see>.</param>
            <param name="otherMax">The maxs vector. Values on each axis should be bigger than those of the mins vector. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)">Vector3.Sort</see>.</param>
        </member>
        <member name="M:Vector3.Clamp(System.Single,System.Single)">
            <summary>
            Returns a vector each axis of which is clamped to given min and max values.
            </summary>
            <param name="min">Minimum value for each axis.</param>
            <param name="max">Maximum value for each axis.</param>
        </member>
        <member name="M:Vector3.ComponentMin(Vector3@)">
            <summary>
            Returns a vector that has the minimum values on each axis between this vector and given vector.
            </summary>
        </member>
        <member name="M:Vector3.Min(Vector3@,Vector3@)">
            <summary>
            Returns a vector that has the minimum values on each axis between the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector3.ComponentMax(Vector3@)">
            <summary>
            Returns a vector that has the maximum values on each axis between this vector and given vector.
            </summary>
        </member>
        <member name="M:Vector3.Max(Vector3@,Vector3@)">
            <summary>
            Returns a vector that has the maximum values on each axis between the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector3.Lerp(Vector3,Vector3,System.Single,System.Boolean)">
            <summary>
            Performs linear interpolation between 2 given vectors.
            </summary>
            <param name="a">Vector A</param>
            <param name="b">Vector B</param>
            <param name="frac">Fraction, where 0 would return Vector A, 0.5 would return a point between the 2 vectors, and 1 would return Vector B.</param>
            <param name="clamp">Whether to clamp the fraction argument between [0,1]</param>
            <returns></returns>
        </member>
        <member name="M:Vector3.LerpTo(Vector3@,System.Single,System.Boolean)">
            <summary>
            Performs linear interpolation between this and given vectors.
            </summary>
            <param name="target">Vector B</param>
            <param name="frac">Fraction, where 0 would return this, 0.5 would return a point between this and given vectors, and 1 would return the given vector.</param>
            <param name="clamp">Whether to clamp the fraction argument between [0,1]</param>
            <returns></returns>
        </member>
        <member name="M:Vector3.Lerp(Vector3@,Vector3@,Vector3,System.Boolean)">
            <summary>
            Performs linear interpolation between 2 given vectors, with separate fraction for each vector component.
            </summary>
            <param name="a">Vector A</param>
            <param name="b">Vector B</param>
            <param name="frac">Fraction for each axis, where 0 would return Vector A, 0.5 would return a point between the 2 vectors, and 1 would return Vector B.</param>
            <param name="clamp">Whether to clamp the fraction argument between [0,1] on each axis</param>
            <returns></returns>
        </member>
        <member name="M:Vector3.LerpTo(Vector3@,Vector3@,System.Boolean)">
            <summary>
            Performs linear interpolation between this and given vectors, with separate fraction for each vector component.
            </summary>
            <param name="target">Vector B</param>
            <param name="frac">Fraction for each axis, where 0 would return this, 0.5 would return a point between this and given vectors, and 1 would return the given vector.</param>
            <param name="clamp">Whether to clamp the fraction argument between [0,1] on each axis</param>
            <returns></returns>
        </member>
        <member name="M:Vector3.Cross(Vector3@,Vector3@)">
            <summary>
            Returns the cross product of the 2 given vectors.
            If the given vectors are linearly independent, the resulting vector is perpendicular to them both, also known as a normal of a plane.
            </summary>
        </member>
        <member name="M:Vector3.Cross(Vector3@)">
            <summary>
            Returns the cross product of this and the given vector.
            If this and the given vectors are linearly independent, the resulting vector is perpendicular to them both, also known as a normal of a plane.
            </summary>
        </member>
        <member name="M:Vector3.Dot(Vector3@,Vector3@)">
            <summary>
            Returns the scalar/dot product of the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector3.Dot(Vector3@)">
            <summary>
            Returns the scalar/dot product of this and the given vectors.
            </summary>
        </member>
        <member name="M:Vector3.DistanceBetween(Vector3@,Vector3@)">
            <summary>
            Returns distance between the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector3.Distance(Vector3@)">
            <summary>
            Returns distance between this vector to given vector.
            </summary>
        </member>
        <member name="M:Vector3.DistanceBetweenSquared(Vector3@,Vector3@)">
            <summary>
            Returns squared distance between the 2 given vectors. This is faster than <see cref="M:Vector3.DistanceBetween(Vector3@,Vector3@)">DistanceBetween</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
        </member>
        <member name="M:Vector3.DistanceSquared(Vector3@)">
            <summary>
            Returns squared distance between this vector to given vector. This is faster than <see cref="M:Vector3.Distance(Vector3@)">Distance</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
        </member>
        <member name="M:Vector3.Approach(System.Single,System.Single)">
            <summary>
            Returns a new vector whose length is closer to given target length by given amount.
            </summary>
            <param name="length">Target length.</param>
            <param name="amount">How much to subtract or add.</param>
        </member>
        <member name="M:Vector3.Abs">
            <summary>
            Returns a new vector with all values positive. -5 becomes 5, etc.
            </summary>
        </member>
        <member name="M:Vector3.Reflect(Vector3@,Vector3@)">
            <summary>
            Returns a reflected vector based on incoming direction and plane normal. Like a ray reflecting off of a mirror.
            </summary>
        </member>
        <member name="M:Vector3.VectorPlaneProject(Vector3@,Vector3@)">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Vector_projection">Projects given vector</a> on a plane defined by <paramref name="planeNormal"/>.
            </summary>
            <param name="v">The vector to project.</param>
            <param name="planeNormal">Normal of a plane to project onto.</param>
            <returns>The projected vector.</returns>
        </member>
        <member name="M:Vector3.ProjectOnNormal(Vector3@)">
             <summary>
             <a href="https://en.wikipedia.org/wiki/Vector_projection">Projects this vector</a> onto another vector.
            
             Basically extends the given normal/unit vector to be as long as necessary to make a right triangle (a triangle which has a 90 degree corner)
             between (0,0,0), this vector and the projected vector.
             </summary>
             <param name="normal"></param>
             <returns>The projected vector.</returns>
        </member>
        <member name="M:Vector3.Sort(Vector3@,Vector3@)">
            <summary>
            Sort these two vectors into min and max. This doesn't just swap the vectors, it sorts each component.
            So that min will come out containing the minimum x, y and z values.
            </summary>
        </member>
        <member name="M:Vector3.AlmostEqual(Vector3@,System.Single)">
            <summary>
            Returns true if we're nearly equal to the passed vector.
            </summary>
            <param name="v">The value to compare with</param>
            <param name="delta">The max difference between component values</param>
            <returns>True if nearly equal</returns>
        </member>
        <member name="M:Vector3.CubicBezier(Vector3@,Vector3@,Vector3@,Vector3@,System.Single)">
            <summary>
            Calculates position of a point on a cubic beizer curve at given fraction.
            </summary>
            <param name="source">Point A of the curve in world space.</param>
            <param name="target">Point B of the curve in world space.</param>
            <param name="sourceTangent">Tangent for the Point A in world space.</param>
            <param name="targetTangent">Tangent for the Point B in world space.</param>
            <param name="t">How far along the path to get a point on. Range is 0 to 1, inclusive.</param>
            <returns>The point on the curve</returns>
        </member>
        <member name="M:Vector3.Direction(Vector3@,Vector3@)">
            <summary>
            Calculates the normalized direction vector from one point to another in 3D space.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:Vector3.SubtractDirection(Vector3@,System.Single)">
            <summary>
            Given a vector like 1,1,1 and direction 1,0,0, will return 0,1,1.
            This is useful for velocity collision type events, where you want to
            cancel out velocity based on a normal.
            For this to work properly, direction should be a normal, but you can scale
            how much you want to subtract by scaling the direction. Ie, passing in a direction
            with a length of 0.5 will remove half the direction.
            </summary>
        </member>
        <member name="M:Vector3.SnapToGrid(System.Single,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Snap to grid along any of the 3 axes.
            </summary>
        </member>
        <member name="M:Vector3.SmoothDamp(Vector3@,Vector3@,Vector3@,System.Single,System.Single)">
            <summary>
            Smoothly move towards the target vector
            </summary>
        </member>
        <member name="M:Vector3.GetAngle(Vector3@,Vector3@)">
            <summary>
            Return the distance between the two direction vectors in degrees.
            </summary>
        </member>
        <member name="M:Vector3.Angle(Vector3@)">
            <summary>
            Return the distance between the two direction vectors in degrees.
            </summary>
        </member>
        <member name="M:Vector3.VectorAngle(Vector3@)">
            <summary>
            Converts a direction vector to an angle.
            </summary>
        </member>
        <member name="P:Vector3.EulerAngles">
            <summary>
            The Euler angles of this direction vector.
            </summary>
        </member>
        <member name="P:Vector3.Inverse">
            <summary>
            Returns the inverse of this vector, which us useful for scaling vectors.
            </summary>
        </member>
        <member name="M:Vector3.AddClamped(Vector3@,System.Single)">
            <summary>
            Try to add to this vector. If we're already over max then don't add.
            If we're over max when we add, clamp in that direction so we're not.
            </summary>
        </member>
        <member name="M:Vector3.RotateAround(Vector3@,Rotation@)">
            <summary>
            Rotate this vector around given point by given rotation and return the result as a new vector.<br/>
            See <see cref="M:Transform.RotateAround(Vector3,Rotation)"/> for similar method that also transforms rotation.
            </summary>
            <param name="center">Point to rotate around.</param>
            <param name="rot">How much to rotate by. <see cref="M:Rotation.FromAxis(Vector3,System.Single)"/> can be useful.</param>
            <returns>The rotated vector.</returns>
        </member>
        <member name="M:Vector3.Parse(System.String,System.IFormatProvider)">
            <inheritdoc cref="M:Vector3.Parse(System.String)" />
        </member>
        <member name="M:Vector3.Parse(System.String)">
            <inheritdoc cref="M:Vector3.Parse(System.String)" />
        </member>
        <member name="M:Vector3.TryParse(System.String,Vector3@)">
            <inheritdoc cref="M:Vector3.Parse(System.String)" />
        </member>
        <member name="M:Vector3.TryParse(System.String,System.IFormatProvider,Vector3@)">
             <summary>
             Given a string, try to convert this into a vector. Example input formats that work would be "1,1,1", "1;1;1", "[1 1 1]".
            
             This handles a bunch of different separators ( ' ', ',', ';', '\n', '\r' ).
            
             It also trims surrounding characters ('[', ']', ' ', '\n', '\r', '\t', '"').
             </summary>
        </member>
        <member name="M:Vector3.WithAcceleration(Vector3,System.Single)">
            <summary>
            Move to the target vector, by amount acceleration 
            </summary>
        </member>
        <member name="M:Vector3.WithFriction(System.Single,System.Single)">
            <summary>
            Apply an amount of friction to the current velocity.
            </summary>
        </member>
        <member name="M:Vector3.CatmullRomSpline(Vector3@,Vector3@,Vector3@,Vector3@,System.Single)">
            <summary>
            Calculates a point on a Catmull-Rom spline given four control points and a parameter t.
            </summary>
        </member>
        <member name="M:Vector3.TcbSpline(Vector3@,Vector3@,Vector3@,Vector3@,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Calculates an interpolated point using the Kochanek-Bartels spline (TCB spline).
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="tension">Tension parameter which affects the sharpness at the control point.
            Positive values make the curve tighter, negative values make it rounder.</param>
            <param name="continuity">Continuity parameter which affects the continuity between segments.
            Positive values create smoother transitions, negative values can create corners.</param>
            <param name="bias">Bias parameter which affects the direction of the curve as it passes through the control point.
            Positive values bias the curve towards the next point, negative values towards the previous.</param>
            <param name="u">The interpolation parameter between 0 and 1, where 0 is the start of the segment and 1 is the end.</param>
            <returns>The interpolated point on the curve.</returns>
        </member>
        <member name="F:Vector3Int.x">
            <summary>
            The X component of this integer vector.
            </summary>
        </member>
        <member name="F:Vector3Int.y">
            <summary>
            The Y component of this integer vector.
            </summary>
        </member>
        <member name="F:Vector3Int.z">
            <summary>
            The Z component of this integer vector.
            </summary>
        </member>
        <member name="M:Vector3Int.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes an integer vector with given components.
            </summary>
            <param name="x">The X component.</param>
            <param name="y">The Y component.</param>
            <param name="z">The Z component.</param>
        </member>
        <member name="M:Vector3Int.#ctor(System.Int32)">
            <summary>
            Initializes an integer vector with all components set to the same value.
            </summary>
            <param name="all">The value of the X, Y, and Z components.</param>
        </member>
        <member name="M:Vector3Int.#ctor(Vector3Int)">
            <summary>
            Initializes an integer vector with given components from another integer vector
            </summary>
            <param name="vector3Int"></param>
        </member>
        <member name="F:Vector3Int.One">
            <summary>
            An integer vector with all components set to 1.
            </summary>
        </member>
        <member name="F:Vector3Int.Zero">
            <summary>
            An integer vector with all components set to 0.
            </summary>
        </member>
        <member name="F:Vector3Int.Forward">
            <summary>
            An integer vector with X set to 1. This represents the forward direction.
            </summary>
        </member>
        <member name="F:Vector3Int.Backward">
            <summary>
            An integer vector with X set to -1. This represents the backward direction.
            </summary>
        </member>
        <member name="F:Vector3Int.Up">
            <summary>
            An integer vector with Y set to 1. This represents the right direction.
            </summary>
        </member>
        <member name="F:Vector3Int.Down">
            <summary>
            An integer vector with Y set to -1. This represents the left direction.
            </summary>
        </member>
        <member name="F:Vector3Int.Right">
            <summary>
            An integer vector with Z set to 1. This represents the up direction.
            </summary>
        </member>
        <member name="F:Vector3Int.Left">
            <summary>
            An integer vector with Z set to -1. This represents the down direction.
            </summary>
        </member>
        <member name="F:Vector3Int.OneX">
            <summary>
            An integer vector with X set to 1.
            </summary>
        </member>
        <member name="F:Vector3Int.OneY">
            <summary>
            An integer vector with Y set to 1.
            </summary>
        </member>
        <member name="F:Vector3Int.OneZ">
            <summary>
            An integer vector with Z set to 1.
            </summary>
        </member>
        <member name="M:Vector3Int.ToString">
            <summary>
            Formats the integer vector into a string "x,y,z"
            </summary>
            <returns></returns>
        </member>
        <member name="P:Vector3Int.Normal">
            <summary>
            Returns a unit version of this vector. Keep in mind this returns a Vector3 and not a Vector3Int.
            </summary>
        </member>
        <member name="P:Vector3Int.EulerAngles">
            <summary>
            The Euler angles of this direction vector.
            </summary>
        </member>
        <member name="P:Vector3Int.Inverse">
            <summary>
            Returns the inverse of this vector, which is useful for scaling vectors. Keep in mind this returns a Vector3 and not a Vector3Int.
            </summary>
        </member>
        <member name="P:Vector3Int.Length">
            <summary>
            Length (or magnitude) of the integer vector (Distance from 0,0,0)
            </summary>
        </member>
        <member name="P:Vector3Int.LengthSquared">
            <summary>
            Squared length of the integer vector. This is faster than <see cref="P:Vector3Int.Length">Length</see>, and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
        </member>
        <member name="P:Vector3Int.IsZeroLength">
            <summary>
            Whether the length of this vector is zero or not.
            </summary>
        </member>
        <member name="M:Vector3Int.IsNearlyZero(System.Int32)">
            <summary>
            Returns true if value on every axis is less than or equal to tolerance.
            </summary>
        </member>
        <member name="M:Vector3Int.ComponentMin(Vector3Int)">
            <summary>
            Returns an integer vector that has the minimum values on each axis between this vector and a given vector.
            </summary>
        </member>
        <member name="M:Vector3Int.ComponentMax(Vector3Int)">
            <summary>
            Returns an integer vector that has the maximum values on each axis between this vector and a given vector.
            </summary>
        </member>
        <member name="M:Vector3Int.Cross(Vector3Int@,Vector3Int@)">
            <summary>
            Returns the cross product of this and the given integer vector.
            If this and the given vectors are linearly independent, the resulting vector is perpendicular to them both, also known as a normal of a plane.
            </summary>
        </member>
        <member name="M:Vector3Int.Dot(Vector3Int@,Vector3Int@)">
            <summary>
            Returns the scalar/dot product of the 2 given integer vectors.
            </summary>
        </member>
        <member name="M:Vector3Int.Dot(Vector3Int@,Vector3@)">
            <summary>
            Returns the scalar/dot product of the 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector3Int.Dot(Vector3Int@)">
            <summary>
            Returns the scalar/dot product of this and the given vector.
            </summary>
        </member>
        <member name="M:Vector3Int.Dot(Vector3@)">
            <summary>
            Returns the scalar/dot product of this and the given vector.
            </summary>
        </member>
        <member name="M:Vector3Int.Distance(Vector3Int)">
            <summary>
            Returns distance between this vector and another.
            </summary>
        </member>
        <member name="M:Vector3Int.Distance(Vector3)">
            <summary>
            Returns distance between this vector and another.
            </summary>
        </member>
        <member name="M:Vector3Int.SnapToGrid(System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Snap to grid along any of the 3 axes.
            </summary>
        </member>
        <member name="M:Vector3Int.Min(Vector3Int,Vector3Int)">
            <summary>
            Returns an integer vector that has the minimum values on each axis between 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector3Int.Max(Vector3Int,Vector3Int)">
            <summary>
            Returns an integer vector that has the maximum values on each axis between 2 given vectors.
            </summary>
        </member>
        <member name="M:Vector3Int.Abs">
            <summary>
            Returns a new integer vector with all values positive. -5 becomes 5, ect.
            </summary>
        </member>
        <member name="M:Vector3Int.WithX(System.Int32)">
            <summary>
            Returns this integer vector with given X component.
            </summary>
        </member>
        <member name="M:Vector3Int.WithY(System.Int32)">
            <summary>
            Returns this integer vector with given Y component.
            </summary>
        </member>
        <member name="M:Vector3Int.WithZ(System.Int32)">
            <summary>
            Returns this integer vector with given Z component.
            </summary>
        </member>
        <member name="M:Vector3Int.Parse(System.String)">
            <summary>
            Given a string, try to convert this into a Vector3Int. Example formatting is "x,y,z", "[x,y,z]", "x y z", etc.
            </summary>
        </member>
        <member name="M:Vector3Int.Parse(System.String,System.IFormatProvider)">
            <inheritdoc cref="M:Vector3Int.Parse(System.String)" />
        </member>
        <member name="M:Vector3Int.TryParse(System.String,System.IFormatProvider,Vector3Int@)">
            <inheritdoc cref="M:Vector3Int.Parse(System.String)" />
        </member>
        <member name="T:Vector4">
            <summary>
            A 4-dimensional vector/point.
            </summary>
        </member>
        <member name="F:Vector4.Zero">
            <summary>
            A 4D vector with all components set to 0.
            </summary>
        </member>
        <member name="F:Vector4.One">
            <summary>
            A 4D vector with all components set to 1.
            </summary>
        </member>
        <member name="P:Vector4.x">
            <summary>
            The X component of this Vector.
            </summary>
        </member>
        <member name="P:Vector4.y">
            <summary>
            The Y component of this Vector.
            </summary>
        </member>
        <member name="P:Vector4.z">
            <summary>
            The Z component of this Vector.
            </summary>
        </member>
        <member name="P:Vector4.w">
            <summary>
            The W component of this Vector.
            </summary>
        </member>
        <member name="M:Vector4.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a vector4 with given components.
            </summary>
            <param name="x">The X component.</param>
            <param name="y">The Y component.</param>
            <param name="z">The Z component.</param>
            <param name="w">The W component.</param>
        </member>
        <member name="M:Vector4.#ctor(Vector3@,System.Single)">
            <summary>
            Initializes a 4D vector from given #D vector and the given W component.
            </summary>
        </member>
        <member name="M:Vector4.#ctor(System.Single)">
            <summary>
            Initializes the 4D vector with all components set to given value.
            </summary>
        </member>
        <member name="M:Vector4.Lerp(Vector4,Vector4,System.Single,System.Boolean)">
            <summary>
            Performs linear interpolation between 2 given vectors.
            </summary>
            <param name="a">Vector A</param>
            <param name="b">Vector B</param>
            <param name="frac">Fraction, where 0 would return Vector A, 0.5 would return a point between the 2 vectors, and 1 would return Vector B.</param>
            <param name="clamp">Whether to clamp the fraction argument between [0,1]</param>
            <returns></returns>
        </member>
        <member name="M:Vector4.LerpTo(Vector4,System.Single,System.Boolean)">
            <summary>
            Performs linear interpolation between this and given vectors.
            </summary>
            <param name="target">Vector B</param>
            <param name="frac">Fraction, where 0 would return Vector A, 0.5 would return a point between the 2 vectors, and 1 would return Vector B.</param>
            <param name="clamp">Whether to clamp the fraction argument between [0,1]</param>
            <returns></returns>
        </member>
        <member name="M:Vector4.ToString">
            <summary>
            Formats the Vector into a string "x,y,z,w"
            </summary>
            <returns></returns>
        </member>
        <member name="P:Vector4.Length">
            <summary>
            The length of this vector object
            </summary>
        </member>
        <member name="P:Vector4.LengthSquared">
            <summary>
            The squared length of this vector object
            </summary>
        </member>
        <member name="P:Vector4.IsNearZeroLength">
            <summary>
            Whether length of this vector is nearly zero.
            </summary>
        </member>
        <member name="M:Vector4.Parse(System.String)">
            <summary>
            Given a string, try to convert this into a vector4. The format is "x,y,z,w".
            </summary>
        </member>
        <member name="M:Vector4.Parse(System.String,System.IFormatProvider)">
            <inheritdoc cref="M:Vector4.Parse(System.String)" />
        </member>
        <member name="M:Vector4.TryParse(System.String,Vector4@)">
            <inheritdoc cref="M:Vector4.Parse(System.String)" />
        </member>
        <member name="M:Vector4.TryParse(System.String,System.IFormatProvider,Vector4@)">
            <inheritdoc cref="M:Vector4.Parse(System.String)" />
        </member>
        <member name="T:AssemblyOrderer">
            <summary>
            Takes a bunch of assemblies and works out the proper loading order for them.
            </summary>
        </member>
        <member name="M:ContextLocal.GameScope">
            <summary>
            Should rarely have to get called, game scope is implicit
            </summary>
        </member>
        <member name="M:ContextLocal.MenuScope">
            <summary>
            Should only be called at a really high level, when doing menu stuff
            </summary>
        </member>
        <member name="T:ContextLocal`1">
            <summary>
            Modelled on AsyncLocal. Allows making variables that are different depending on the context, which
            is either game or menu. Game is implicit, but we should push the scope using ContextLocal.MenuScope 
            any time we think we'll be accessing menu vars. This is generally only done in MenuDll.
            </summary>
        </member>
        <member name="M:SandboxedUnsafe.IsAcceptablePod(System.Type)">
            <summary>
            Return true if this is an acceptable Plain Old data
            </summary>
        </member>
    </members>
</doc>
