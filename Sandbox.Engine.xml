<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sandbox.Engine</name>
    </assembly>
    <members>
        <member name="M:Sandbox.ActionGraphs.RandomNodes.Color(System.Single,System.Single)">
            <summary>
            Returns a color with a random hue.
            </summary>
            <param name="saturation">Saturation of the generated color, from 0 to 1.</param>
            <param name="lightness">Lightness of the generated color, from 0 to 1.</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.As``2(``0)">
            <summary>
            Tests if the given input is of the given type, otherwise returns null.
            </summary>
            <typeparam name="TIn">Input type.</typeparam>
            <typeparam name="TValue">Type to test for.</typeparam>
            <param name="input">Input value to test the type of.</param>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.IsNull``1(``0)">
            <summary>
            Tests if the given input is null.
            </summary>
            <typeparam name="TIn">Input type.</typeparam>
            <param name="input">Input value to test for null.</param>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.IsNotNull``1(``0)">
            <summary>
            Tests if the given input is not null.
            </summary>
            <typeparam name="TIn">Input type.</typeparam>
            <param name="input">Input value to test for null.</param>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.SystemToString(System.Object)">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.UtilityNodes.SystemGetHashCode(System.Object)">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:Sandbox.DataModel.ProjectConfig">
            <summary>
            Configuration of a <see cref="T:Sandbox.Project"/>.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Directory">
            <summary>
            The directory housing this addon (TODO)
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.AssetsDirectory">
            <summary>
            The directory housing this addon (TODO)
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Title">
            <summary>
            The human readable title, for example "Sandbox", "Counter-Strike"
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Type">
            <summary>
            The type of addon. Current valid values are "game"
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Org">
            <summary>
            The ident of the org that owns this addon. For example "facepunch", "valve".
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Ident">
            <summary>
            The ident of this addon. For example "sandbox", "cs" or "dm98"
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.PackageType">
            <summary>
            Type of the package.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.FullIdent">
            <summary>
            Returns a combination of Org and Ident - for example "facepunch.sandbox" or "valve.cs".
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Schema">
            <summary>
            The version of the addon file. Allows us to upgrade internally.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.IncludeSourceFiles">
            <summary>
            If true then we'll include all the source files
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Resources">
            <summary>
            A list of paths in which to look for extra assets to upload with the addon. Note that compiled asset files are automatically included.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.PackageReferences">
            <summary>
            A list of packages that this package depends on. These should be installed alongside this package.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.EditorReferences">
            <summary>
            A list of packages that this package uses but there is no need to install. For example, a map package might use
            a model package - but there is no need to download that model package because any usage will organically be included
            in the manifest. However, when loading this item in the editor, it'd make sense to install these 'cloud' packages.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.DistinctPackageReferences">
            <summary>
            Contains unique elements from <see cref="P:Sandbox.DataModel.ProjectConfig.PackageReferences"/>, along with any implicit package references.
            An example implicit reference is the parent package of an addon.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.ProjectConfig.Metadata">
            <summary>
            Custom key-value storage for this project.
            </summary>
        </member>
        <member name="M:Sandbox.DataModel.ProjectConfig.ToJson">
            <summary>
            Serialize the entire config to a JSON string.
            </summary>
        </member>
        <member name="M:Sandbox.DataModel.ProjectConfig.TryGetMeta``1(System.String,``0@)">
            <summary>
            Try to get a value at given key in <see cref="P:Sandbox.DataModel.ProjectConfig.Metadata"/>.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="keyname">The key to retrieve the value of.</param>
            <param name="outvalue">The value, if it was present in the metadata storage.</param>
            <returns>Whether the value was successfully retrieved.</returns>
        </member>
        <member name="M:Sandbox.DataModel.ProjectConfig.GetMetaOrDefault``1(System.String,``0)">
            <summary>
            Get the package's meta value. If it's missing or the wrong type then use the default value.
            </summary>
        </member>
        <member name="M:Sandbox.DataModel.ProjectConfig.SetMeta(System.String,System.Object)">
            <summary>
            Store custom data at given key in the <see cref="P:Sandbox.DataModel.ProjectConfig.Metadata"/>.
            </summary>
            <param name="keyname">The key for the data.</param>
            <param name="outvalue">The data itself to store.</param>
            <returns>Always true.</returns>
        </member>
        <member name="T:Sandbox.Project">
            <summary>
            Represents an on-disk project.
            </summary>
            <summary>
            Represents an on-disk project.
            </summary>
        </member>
        <member name="P:Sandbox.Project.HasCompiler">
            <summary>
            Whether the project's code has a compiler assigned.
            </summary>
        </member>
        <member name="P:Sandbox.Project.BaseReferencingTypes">
            <summary>
            These package types should reference package.base
            </summary>
        </member>
        <member name="M:Sandbox.Project.UpdateEditorCompiler">
            <summary>
            If required, create the editor compiler
            </summary>
        </member>
        <member name="M:Sandbox.Project.FindByCompiler(Sandbox.Compiler)">
            <summary>
            Find a project from a compiler
            </summary>
        </member>
        <member name="P:Sandbox.Project.ProjectSourceObject">
            <summary>
            If this is a single asset project, this will be the asset object
            </summary>
        </member>
        <member name="P:Sandbox.Project.ConfigFilePath">
            <summary>
            Absolute path to the .addon file
            </summary>
        </member>
        <member name="P:Sandbox.Project.RootDirectory">
            <summary>
            Root directory of this project
            </summary>
        </member>
        <member name="P:Sandbox.Project.Active">
            <summary>
            True if this project is active
            </summary>
        </member>
        <member name="P:Sandbox.Project.Pinned">
            <summary>
            True if this project is pinned, we'll prioritise it when sorting
            </summary>
        </member>
        <member name="P:Sandbox.Project.LastOpened">
            <summary>
            When did the user last open this project?
            </summary>
        </member>
        <member name="P:Sandbox.Project.Broken">
            <summary>
            True if this project failed to load properly for some reason
            </summary>
        </member>
        <member name="P:Sandbox.Project.IsPublished">
            <summary>
            Returns true if this project has previously been published. This is kind of a guess though
            because all it does is look to see if we have a published package cached with the same ident.
            </summary>
        </member>
        <member name="P:Sandbox.Project.EditUrl">
            <summary>
            The URL to the package's page for editing
            </summary>
        </member>
        <member name="P:Sandbox.Project.ViewUrl">
            <summary>
            The URL to the package's page for viewing/linking
            </summary>
        </member>
        <member name="P:Sandbox.Project.Config">
            <summary>
            Configuration of the project.
            </summary>
        </member>
        <member name="P:Sandbox.Project.IsTransient">
            <summary>
            If true this project isn't a 'real' project. It's likely a temporary project created with the
            intention to configure and publish a single asset.
            </summary>
        </member>
        <member name="P:Sandbox.Project.IsBuiltIn">
            <summary>
            If true this project isn't a 'real' project. It's likely a temporary project created with the
            intention to configure and publish a single asset.
            </summary>
        </member>
        <member name="P:Sandbox.Project.OnSaveProject">
            <summary>
            Called when the project is about to save
            </summary>
        </member>
        <member name="P:Sandbox.Project.AssemblyFileSystem">
            <summary>
            A filesystem into which compiled assemblies are written
            </summary>
        </member>
        <member name="P:Sandbox.Project.IsWhitelistDisabled">
            <summary>
            Whether or not this project has the whitelist disabled. If this is the case, it can only be exported, and cannot be uploaded to sbox.game.
            </summary>
        </member>
        <member name="M:Sandbox.Project.GetRootPath">
            <summary>
            Absolute path to the location of the <c>.sbproj</c> file of the project.
            </summary>
        </member>
        <member name="M:Sandbox.Project.GetCodePath">
            <summary>
            Absolute path to the code folder of the project.
            </summary>
        </member>
        <member name="M:Sandbox.Project.HasCodePath">
            <summary>
            Returns true if the Code path exists
            </summary>
        </member>
        <member name="M:Sandbox.Project.GetAssetsPath">
            <summary>
            Absolute path to the assets folder of the project, or <see langword="null"/> if not set.
            </summary>
        </member>
        <member name="M:Sandbox.Project.GetLocalizationPath">
            <summary>
            Absolute path to the localization folder of the project, or <see langword="null"/> if not set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Project.HasAssetsPath">
            <summary>
            Returns true if the Assets path exists
            </summary>
        </member>
        <member name="P:Sandbox.Project.Package">
            <summary>
            The package for this project. This is a mock up of the actual package.
            </summary>
        </member>
        <member name="M:Sandbox.Project.IsSourcePublish">
            <summary>
            Return true if this project type uploads all the source files when it's published
            </summary>
        </member>
        <member name="P:Sandbox.Project.Current">
            <summary>
            Current open project.
            </summary>
        </member>
        <member name="M:Sandbox.Project.Clear">
            <summary>
            Remove all local packages. Used by unit tests to reset state.
            </summary>
        </member>
        <member name="M:Sandbox.Project.Tick">
            <summary>
            Check whether the group needs recompiling, and recompiles
            </summary>
        </member>
        <member name="M:Sandbox.Project.InitializeBuiltIn(System.Boolean)">
            <summary>
            Initializes all the base projects
            </summary>
        </member>
        <member name="M:Sandbox.Project.SyncWithPackageManager">
            <summary>
            Takes all of the active projects and makes sure we're in sync
            with the package manager. Creates mock packages that act like real ones.
            Removes packages that are no longer active. If nothing changed then this should
            do nothing.
            </summary>
        </member>
        <member name="M:Sandbox.Project.GenerateSolution">
            <summary>
            (Re)generate the active project's solution file.
            </summary>
        </member>
        <member name="M:Sandbox.Project.AddFromFileBuiltIn(System.String)">
            <summary>
            Like AddFromFile but the project is marked as "built in" - which means
            it's always automatically loaded and can't be unloaded.
            </summary>
        </member>
        <member name="M:Sandbox.Project.ResolveCompiler(System.Reflection.Assembly)">
            <summary>
            Resolve an assemblt to a compiler using the assembly name
            </summary>
        </member>
        <member name="M:Sandbox.Api.Performance.CollectStat(System.String,System.Double)">
            <summary>
            Collect a statistic. This should usually be called ONCE per frame, per stat.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Performance.BuildStats">
            <summary>
            Convert statDict into an object that we can send to the backend.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Performance.ArrayToMetric(System.Collections.Generic.List{System.Double})">
            <summary>
             Here we take the array of values and convert them into an object with a bunch of statistics about them.
             Basically trying to cover our bases as much as possible, in case we need to show this data later on.
            </summary>
        </member>
        <member name="M:Sandbox.Api.RetryAndIgnore(System.Func{System.Threading.Tasks.Task},System.Int32,System.Int32)">
            <summary>
            Call a function - retry a number of times on failure, then silently fail.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Benchmarks.Post(Sandbox.Api.BenchmarkRecord[],System.Threading.CancellationToken)">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkInput.Session">
            <summary>
            Unique GUID for this benchmark run
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkInput.Package">
            <summary>
            The package that is running this benchmark
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkInput.Host">
            <summary>
            Unique ID for the system this is running on. This allows us to set up benchmark machines and track them by id.
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkInput.Version">
            <summary>
            The engine version, so we can track the compile time. This is the github SHA
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkInput.VersionDate">
            <summary>
            When this version was compiled
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkInput.System">
            <summary>
            Stats about the system
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkInput.Entries">
            <summary>
            Each compile entry
            </summary>
        </member>
        <member name="T:Sandbox.Api.BenchmarkRecord">
            <summary>
            A record of a benchmark entry
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkRecord.Name">
            <summary>
            The name of the benchmark
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkRecord.Duration">
            <summary>
            Duration in seconds
            </summary>
        </member>
        <member name="P:Sandbox.Api.BenchmarkRecord.Data">
            <summary>
            The data created from the benchmark. Can vary.
            </summary>
        </member>
        <member name="M:Sandbox.Api.ClearCache">
            <summary>
            Clear the cache. This is good to call when you know something has changed - like a package has been uploaded.
            </summary>
        </member>
        <member name="M:Sandbox.Api.GetAsync``1(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Single,System.Threading.CancellationToken)">
            <summary>
            Get from the API and get a JSON result
            </summary>
        </member>
        <member name="M:Sandbox.Api.PostAsync``1(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String},Sandbox.Utility.DataProgress.Callback,System.Threading.CancellationToken)">
            <summary>
            Post to the API and get a JSON result
            </summary>
        </member>
        <member name="M:Sandbox.Api.PostAsync(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String},Sandbox.Utility.DataProgress.Callback,System.Threading.CancellationToken)">
            <summary>
            Post to the API and get a string result
            </summary>
        </member>
        <member name="T:Sandbox.Api.Packages.Get">
            <summary>
            Get a single package
            </summary>
        </member>
        <member name="T:Sandbox.Api.Packages.Find">
            <summary>
            Get a list of packages
            </summary>
        </member>
        <member name="T:Sandbox.Api.Packages.List">
            <summary>
            Get a list of packages
            </summary>
        </member>
        <member name="T:Sandbox.Api.Packages.Versions">
            <summary>
            Get a list of versions
            </summary>
        </member>
        <member name="T:Sandbox.Api.Packages.Update">
            <summary>
            Update a package
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadFile.Package">
            <summary>
            The package ident
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadFile.Contents">
            <summary>
            A base64 encoded version of the file, for files under a certain size (say 20mb)
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadFile.Blob">
            <summary>
            The name of the blob on our upload storage container
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadFile.Path">
            <summary>
            The game path of the file
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadFile.Crc">
            <summary>
            CRC64.ToString( "x" )
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadFile.Size">
            <summary>
            The size of the file
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadVideo.Package">
            <summary>
            Package ident
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadVideo.Tag">
            <summary>
            Optional video tag. If a video with this tag is found we'll replace it instead of creating a new one.
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadVideo.File">
            <summary>
            A base64 embed of the file - or a blob name 
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadVideo.Thumb">
            <summary>
            Is this a thumb - will replace any existing thumbs
            </summary>
        </member>
        <member name="P:Sandbox.Api.Packages.UploadVideo.Hidden">
            <summary>
            True for this video to start hidden
            </summary>
        </member>
        <member name="M:Sandbox.Api.GetAccountInformation">
            <summary>
            Get linked service credentials, ie "twitch". Under the hood, on our server, we will
            probably be renewing the token with the service (assume the token is only good for 2-3 hours).
            </summary>
        </member>
        <member name="M:Sandbox.Api.GetAuthToken(System.String,System.String)">
            <summary>
            Get an auth token, which can be used on the backend to authenticate that this user is this user.
            This creates an entry in a table in a database on the backend, so it would be great if you only
            called this if you were definitely going to use the result!
            </summary>
        </member>
        <member name="P:Sandbox.Api.ServiceToken.Id">
            <summary>
            The UserId returned by the service
            </summary>
        </member>
        <member name="P:Sandbox.Api.ServiceToken.Name">
            <summary>
            The Username returned by the service
            </summary>
        </member>
        <member name="P:Sandbox.Api.ServiceToken.Token">
            <summary>
            The Token returned by the service
            </summary>
        </member>
        <member name="P:Sandbox.Api.ServiceToken.Type">
            <summary>
            The type (ie "Twitch")
            </summary>
        </member>
        <member name="M:Sandbox.Api.GetLinkedService(System.String)">
            <summary>
            Get linked service credentials, ie "twitch". Under the hood, on our server, we will
            probably be renewing the token with the service (assume the token is only good for 2-3 hours).
            </summary>
        </member>
        <member name="M:Sandbox.Api.Events.Add(Sandbox.Api.Events.EventRecord)">
            <summary>
            Add an event to the queue. You should not use this event again.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Events.Flush(System.Boolean)">
            <summary>
            Force an immediate flush of all events
            </summary>
        </member>
        <member name="M:Sandbox.Api.Events.TickEvents">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Events.PostEventsAsync(Sandbox.Api.Events.EventRecord[])">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="T:Sandbox.Api.LeaderboardResponse">
            <summary>
            Internal on purpose so the structures so we can present data how we want
            to game without api breaking.
            </summary>
        </member>
        <member name="F:Sandbox.Api.LaunchGuid">
            <summary>
            This attempts to be a unique identifier for the launch of a game.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.FlushWithBookmarkAsync(System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Flush the stats and wait until they have been ingested by the backend, 
            at which point they should be available in stats and leaderboard queries.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.ForceFlush(System.Boolean)">
            <summary>
            Force an immediate flush of all events
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.ForceFlushAsync">
            <summary>
            Force an immediate flush of the stats and wait until it's done
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.TickStats">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="M:Sandbox.Api.Stats.PostStatsAsync(Sandbox.Api.Stats.StatRecord[])">
            <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Package">
            <summary>
            The package ident (lowercase [org.package])
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Name">
            <summary>
            The name of the stat (lowercase, no spaces)
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Created">
            <summary>
            When this stat was created
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Updated">
            <summary>
            When this stat was updated
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.IsIncrement">
            <summary>
            If this is an increment
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Compounds">
            <summary>
            If this represents multiple calls, this is the number of calls
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.MinValue">
            <summary>
            If this represents multiple calls, this is the smallest
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.MaxValue">
            <summary>
            If this represents multiple calls, this is the largest
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Value">
            <summary>
            The actual value
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Context">
            <summary>
            Additional context. Map etc..
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Session">
            <summary>
            The current session (or null if #local)
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.SessionSeconds">
            <summary>
            The current time in session
            </summary>
        </member>
        <member name="P:Sandbox.Api.Stats.StatRecord.Data">
            <summary>
            Should be a dynamic object
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Id">
            <summary>
            Our steamid, redundant but here for verification
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.OwnerId">
            <summary>
            If we borrowed this game, this is the real owner id
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Banned">
            <summary>
            Currently just indicates if we're VAC banned
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Links">
            <summary>
            A list of services that we have linked
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Memberships">
            <summary>
            A list of organizations of which we're a member
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Favourites">
            <summary>
            A list of our favourited games
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.GlobalLobbyId">
            <summary>
            Global lobby id
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Session">
            <summary>
            Current client hash (the login session cookie)
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.MessagingEndpoint">
            <summary>
            The azure pubsub endoint to connect to the messaging service.
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.Update">
            <summary>
            Update Current
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.IsFavourite(System.String)">
            <summary>
            Helper - return true if Current.Favourites contains us
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.HasOrganization(System.String)">
            <summary>
            Returns true if a user is a member of this organization
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.GetUploadEndPointAsync(System.String)">
            <summary>
            Returns a URL in which users have the ability to upload files (but not the ability to list or download files).
            This is used so users can upload files to our blob storage, and give us the filename - rather than uploading big
            ass files to our api.
            </summary>
        </member>
        <member name="T:Sandbox.PlatformBackend">
            <summary>
            Backend for s&amp;box platform games
            </summary>
        </member>
        <member name="T:Sandbox.StandaloneBackend">
            <summary>
            Stubbed backend for standalone games - we don't want them using the platform backend
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsInitialized">
            <summary>
            Prevent double initialization
            </summary>
        </member>
        <member name="P:Sandbox.Application.AppId">
            <summary>
            Steam AppId of S&amp;box.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsUnitTest">
            <summary>
            True if we're running the engine as part of a unit test
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsLiveUnitTest">
            <summary>
            True if we're running a live unit test.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsHeadless">
            <summary>
            True if running as a background task, or terminal, like a dedicated server.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsBenchmark">
            <summary>
            True if running a benchmark
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsEditor">
            <summary>
            True if running with the tools or editor attached
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsJoinLocal">
            <summary>
            True if running with -joinlocal. This is an instance that launches and joins
            an in process editor session.
            </summary>
        </member>
        <member name="P:Sandbox.Application.Version">
            <summary>
            The engine's version string
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsRetail">
            <summary>
            True if this is compiled and published on steam
            </summary>
        </member>
        <member name="P:Sandbox.Application.VersionDate">
            <summary>
            The date of this version, as a UTC datetime.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsStandalone">
            <summary>
            True if the game is running in standalone mode
            </summary>
        </member>
        <member name="M:Sandbox.Application.InitUnitTest">
            <summary>
            Called from unit test projects to initialize the engine
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="P:Sandbox.Application.GamePackage">
            <summary>
            The currently loaded game package. May be null if no game loaded. 
            Controlled by GameMenuDll.
            </summary>
        </member>
        <member name="P:Sandbox.Application.GameIdent">
            <summary>
            The currently loaded game package's ident - if applicable.
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsMicrophoneListening">
            <summary>
            Returns true if the microphone is currently listening
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsMicrophoneRecording">
            <summary>
            Returns true if the microphone is currently listening and actually hearing/capturing sounds
            </summary>
        </member>
        <member name="P:Sandbox.Application.IsFocused">
            <summary>
            Is the game window in focus?
            </summary>
        </member>
        <member name="M:Sandbox.Application.Exit">
            <summary>
            Exits the application if running in standalone mode
            </summary>
        </member>
        <member name="T:Sandbox.Cloud">
            <summary>
            For accessing assets from the cloud - from code
            </summary>
        </member>
        <member name="M:Sandbox.Cloud.Asset(System.String)">
            <summary>
            Returns the path of the asset referenced by this package
            </summary>
        </member>
        <member name="T:Sandbox.Cloud.AssetAttribute">
            <summary>
            Automatically addeded to a type as a result of using Cloud.Model etc inside.
            </summary>
        </member>
        <member name="T:Sandbox.Cloud.CloudAssetProviderAttribute">
            <summary>
            Tells codegen to generate a [assembly: Cloud.Asset] for this method
            </summary>
        </member>
        <member name="T:Sandbox.LocalPackage">
            <summary>
            A mock package, this is a package wrapped around a <see cref="P:Sandbox.LocalPackage.Project"/>
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.ContentPath">
            <summary>
            The path to this project's assets
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.CodePath">
            <summary>
            The path to this project's code
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.LocalizationPath">
            <summary>
            The path to this project's localization files
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.IsBuiltIn">
            <summary>
            True if this package is shipped with the game - so everyone should have it
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.IsUsingWhitelist">
            <summary>
            If true then this package is sandboxed. Everything it does should use access control. This is the default.
            Packages that aren't sandboxed won't be able to be published to the platform.. but this is something that 
            makes sense to allow, when we allow standalone exports.
            </summary>
        </member>
        <member name="P:Sandbox.LocalPackage.AssemblyFileSystem">
            <summary>
            A filesystem into which compiled assemblies are written
            </summary>
        </member>
        <member name="M:Sandbox.LocalPackage.GetMeta``1(System.String,``0)">
            <summary>
            Retrieve meta directly from the project instead of the package
            </summary>
        </member>
        <member name="M:Sandbox.LocalPackage.NeedsLocalBasePackage">
            <summary>
            Return true if we need the "base" package including. There are a few situations:
            
            1. We're the root gamemode
            
            </summary>
        </member>
        <member name="T:Sandbox.ManifestSchema">
            <summary>
            An addon's manifest, describing what files are available
            </summary>
        </member>
        <member name="P:Sandbox.ManifestSchema.Schema">
            <summary>
            For internal use
            </summary>
        </member>
        <member name="P:Sandbox.ManifestSchema.Files">
            <summary>
            A list of files that should be mounted to use this asset
            </summary>
        </member>
        <member name="T:Sandbox.Package">
            <summary>
            Represents an asset on <a href="https://asset.party/">Asset Party</a>.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IsRemote">
            <summary>
            Whether this is a remote or a locally installed package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Org">
            <summary>
            The owner of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.FullIdent">
            <summary>
            Full unique identity of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Ident">
            <summary>
            Unique identity of this package within its <see cref="P:Sandbox.Package.Org">organization.</see>.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Title">
            <summary>
            A "nice" name of this package, which will be shown to players in UI.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Summary">
            <summary>
            A short summary of the package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Description">
            <summary>
            Full description of the package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Thumb">
            <summary>
            Link to the thumbnail image of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.VideoThumb">
            <summary>
            Link to the thumbnail video of this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.EngineVersion">
            <summary>
            Engine version this package was uploaded with.
            This is useful for when the base game undergoes large API changes.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Tags">
            <summary>
            List of tags for this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageReferences">
            <summary>
            List of packages that this package depends on. These will be downloaded and installed when
            installing this package.
            </summary>
        </member>
        <member name="P:Sandbox.Package.EditorReferences">
            <summary>
            List of packages that this package depended on during editing.
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageType">
            <summary>
            What kind of package it is.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Public">
            <summary>
            Whether this package is public or hidden.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Archived">
            <summary>
            Whether this package is archived or not.
            </summary>
        </member>
        <member name="P:Sandbox.Package.FileSize">
            <summary>
            The total size of this package in MB. This only applies to packages from Asset Party, the total file size
            of local packages are not calculated.
            </summary>
        </member>
        <member name="T:Sandbox.Package.PackageUsageStats">
            <summary>
            Statistics for user interactions with this package
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Group.Users">
            <summary>
            Unique Users
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Group.Seconds">
            <summary>
            Total combined user-seconds
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Total">
            <summary>
            Total lifetime usage stats
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Month">
            <summary>
            Usage for the last 3 days
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Week">
            <summary>
            Usage for the last week
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Day">
            <summary>
            Usage for the last 24 hours
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.UsersNow">
            <summary>
            How many users are using it right now
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.DailyUsers">
            <summary>
            A historic array of daily unique users. Last entry is yesterday.
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.DailySeconds">
            <summary>
            A historic array of number of seconds played. Last entry is yesterday.
            </summary>
        </member>
        <member name="P:Sandbox.Package.PackageUsageStats.Trend">
            <summary>
            The trend is a number that represents whether it's been popular recently. Higher means more popular.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Usage">
            <summary>
            Statistics for user interactions with this package
            </summary>
        </member>
        <member name="P:Sandbox.Package.Favourited">
            <summary>
            Number of players who added this package to their favourites.
            </summary>
        </member>
        <member name="P:Sandbox.Package.VotesUp">
            <summary>
            Number of players who voted this package up.
            </summary>
        </member>
        <member name="P:Sandbox.Package.VotesDown">
            <summary>
            Number of players who voted this package down.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Source">
            <summary>
            Link to this package's sources, if set.
            </summary>
        </member>
        <member name="P:Sandbox.Package.ApiVersion">
            <summary>
            For game extension compatibility. Game targeting extensions are only compatible with that game
            if the API Versions match.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Screenshots">
            <summary>
            A list of screenshots
            </summary>
        </member>
        <member name="P:Sandbox.Package.Screenshot.IsVideo">
            <summary>
            True if this is a loading screen rather than a regular screenshot
            </summary>
        </member>
        <member name="M:Sandbox.Package.Screenshot.GetThumbUrl(System.Int32,System.Int32)">
            <summary>
            Return the URL of a thumbnail matching this exact size. For caching reasons it's going to be best if
            we can keep this to round number sizes (256, 512 etc) rather than trying to exact fit.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IsFavourite">
            <summary>
            True if this asset is in our favourite list.
            </summary>
        </member>
        <member name="P:Sandbox.Package.CanEdit">
            <summary>
            True if we're a member of this package's organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Url">
            <summary>
            A link to this asset on our backend
            </summary>
        </member>
        <member name="P:Sandbox.Package.Updated">
            <summary>
            When the entry was last updated. If these are different between packages
            then something updated on the backend.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Created">
            <summary>
            When the package was originally created.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Collections">
            <summary>
            How many collections we're in (roughly)
            </summary>
        </member>
        <member name="P:Sandbox.Package.Referencing">
            <summary>
            How many packages we're referencing (roughly)
            </summary>
        </member>
        <member name="P:Sandbox.Package.Referenced">
            <summary>
            How many packages we're referenced by (roughly)
            </summary>
        </member>
        <member name="T:Sandbox.Package.Organization">
            <summary>
            Represents an organization on Asset Party. Organization owns packages.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Ident">
            <summary>
            Unique string that identifies this organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Title">
            <summary>
            Full or "nice" name of this organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.SocialTwitter">
            <summary>
            Link to Twitter of this organization, if set.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.SocialWeb">
            <summary>
            Link to the website of this organization, if set.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Description">
            <summary>
            Description of this organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Thumb">
            <summary>
            Link to the thumbnail image of this organization.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Organization.Created">
            <summary>
            When the organization was created.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.VersionId">
            <summary>
            Unique index of this revision.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.FileCount">
            <summary>
            Number of files in this revision.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.TotalSize">
            <summary>
            Total size of all the files in this revision, in bytes.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.Created">
            <summary>
            When this revision was created.
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.EngineVersion">
            <summary>
            Engine version of this revision.
            TODO: How exactly is this different from <see cref="P:Sandbox.Package.EngineVersion"/>?
            </summary>
        </member>
        <member name="P:Sandbox.Package.IRevision.Manifest">
            <summary>
            Manifest of the revision, describing what files are available. For this to be available
            you should call DownloadManifestAsync first.
            </summary>
        </member>
        <member name="M:Sandbox.Package.IRevision.DownloadManifestAsync(System.Threading.CancellationToken)">
            <summary>
            The manifest will not be immediately available until you've downloaded it.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Revision">
            <summary>
            Information about the current package revision/version.
            </summary>
        </member>
        <member name="M:Sandbox.Package.IsNamed(System.String)">
            <summary>
            Returns true if the org and ident of the passed in ident matches this package
            </summary>
        </member>
        <member name="P:Sandbox.Package.Interaction">
            <summary>
            Describes the authenticated user's interactions with this package. This is only available
            clientside for specific users in order to show things like play history state, favourite
            status and whether they have rated the item or not.
            </summary>
        </member>
        <member name="M:Sandbox.Package.Download(Sandbox.Internal.ILoadingInterface,System.Threading.CancellationToken)">
            <summary>
            Download a package to a temporary location and return a filesystem with its contents
            </summary>
        </member>
        <member name="M:Sandbox.Package.CheckFileCrc(System.String,Sandbox.ManifestSchema.File,System.Threading.CancellationToken)">
            <summary>
            Make sure this manifest file entry is what it says it is
            </summary>
        </member>
        <member name="M:Sandbox.Package.DownloadFileAsync(Sandbox.Package.FileDownloadEntry,Sandbox.PackageFileSystem,Sandbox.Utility.DataProgress.Callback,System.Threading.CancellationToken)">
            <summary>
            Download an individual file
            </summary>
        </member>
        <member name="T:Sandbox.Package.Facet">
            <summary>
            Describes a facet of a group of items, with a limited
            number of each facet with their total item counts
            </summary>
        </member>
        <member name="P:Sandbox.Package.Facet.Name">
            <summary>
            The internal name of this facet. This is used to reference the facet in filters.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Facet.Title">
            <summary>
            The print friendly title of this facet in English.
            </summary>
        </member>
        <member name="P:Sandbox.Package.Facet.Entries">
            <summary>
            A list of entries inside this facet.
            </summary>
        </member>
        <member name="T:Sandbox.Package.Facet.Entry">
            <summary>
            A facet entry consists of a name, display information and the number of items inside
            </summary>
        </member>
        <member name="P:Sandbox.Package.Facet.Entry.Name">
            <summary>
            The name of this item. A filter for this would look like "facet.Name:facet.entry.Name"
            </summary>
        </member>
        <member name="P:Sandbox.Package.Facet.Entry.Icon">
            <summary>
            The material icon for this facet
            </summary>
        </member>
        <member name="P:Sandbox.Package.Facet.Entry.Title">
            <summary>
            The display name of this facet in English
            </summary>
        </member>
        <member name="P:Sandbox.Package.Facet.Entry.Count">
            <summary>
            The number of items within this facet
            </summary>
        </member>
        <member name="T:Sandbox.Package.FacetImp">
            <summary>
            This is the solid class that we actually use to deserialize from the api.
            We do all this extra work so we can only expose what we want to in the interface.
            </summary>
        </member>
        <member name="T:Sandbox.Package.FindResult">
            <summary>
            A result from the call to FindAsync
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Milliseconds">
            <summary>
            The amount of time the query took
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Packages">
            <summary>
            A list of packages retrieved
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.TotalCount">
            <summary>
            The total amount of packages
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Facets">
            <summary>
            Facets particular to this search
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Tags">
            <summary>
            A list of tags relevant to this search
            </summary>
        </member>
        <member name="P:Sandbox.Package.FindResult.Orders">
            <summary>
            A list of sort orders. There may be other sort orders, but we provide a list here that can
            be easily used to save rewriting the same code over and over.
            </summary>
        </member>
        <member name="T:Sandbox.Package.TagEntry">
            <summary>
            Represents a tag along with the count of items it contains
            </summary>
        </member>
        <member name="P:Sandbox.Package.TagEntry.Name">
            <summary>
            The name of the tag. This is the raw tag name. It should generally be lowercase with only letters.
            </summary>
        </member>
        <member name="P:Sandbox.Package.TagEntry.Count">
            <summary>
            The amount of items within this tag.
            </summary>
        </member>
        <member name="T:Sandbox.Package.SortOrder">
            <summary>
            Describes a sort order which can be used with the package/find api
            </summary>
        </member>
        <member name="M:Sandbox.Package.SortOrder.#ctor(System.String,System.String,System.String)">
            <summary>
            Describes a sort order which can be used with the package/find api
            </summary>
        </member>
        <member name="T:Sandbox.Package.ListResult">
            <summary>
            Represents the actual response from the api
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Groupings">
            <summary>
            The groups of packages
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Grouping.Title">
            <summary>
            The title of this group
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Grouping.QueryString">
            <summary>
            Link to get a full list of this category
            </summary>
        </member>
        <member name="P:Sandbox.Package.ListResult.Grouping.Packages">
            <summary>
            The packages in this group
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetMeta``1(System.String,``0)">
            <summary>
            Get metadata value from this package for given key. This will be specific to each <see cref="T:Sandbox.Package.Type"/>.
            </summary>
            <typeparam name="T">Type of the metadata value. This should be something that can be serialized by JSON.</typeparam>
            <param name="keyName">The name of the key to look up.</param>
            <param name="defaultValue">Default value to return when requested key was not present in the package's metadata.</param>
        </member>
        <member name="M:Sandbox.Package.GetCachedMeta``1(System.String,``0)">
            <summary>
            <see cref="M:Sandbox.Package.GetMeta``1(System.String,``0)"/> but with cache.
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetCachedMeta``1(System.String,System.Func{``0})">
            <summary>
            <see cref="M:Sandbox.Package.GetMeta``1(System.String,``0)"/> but with cache.
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetIdent(System.Boolean,System.Boolean)">
            <summary>
            Get the full ident with your choice of fidelity
            </summary>
        </member>
        <member name="M:Sandbox.Package.ClearCache(System.String)">
            <summary>
            Remove a specific package from the cache
            </summary>
        </member>
        <member name="M:Sandbox.Package.TryParseIdent(System.String,System.ValueTuple{System.String,System.String,System.Nullable{System.Int32},System.Boolean}@)">
            <summary>
            Parse a package ident into parts. There are a few different formats you can pass to this.
            
             - org/package
             - org.package
             - org.package#version
             - https://sbox.game/org/package
             - https://sbox.game/org/package#version
             
             If package version isn't specified version will be null
            
            </summary>
        </member>
        <member name="M:Sandbox.Package.FormatIdent(System.String,System.String,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Produces a package ident of the form <c><paramref name="org"/>.<paramref name="package"/>[#<paramref name="local"/>|#<paramref name="version"/>]</c>.
            </summary>
        </member>
        <member name="M:Sandbox.Package.FetchAsync(System.String,System.Boolean)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="M:Sandbox.Package.FetchAsync(System.String,System.Boolean,System.Boolean)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="M:Sandbox.Package.TryGetCached(System.String,Sandbox.Package@,System.Boolean)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="M:Sandbox.Package.Fetch(System.String,System.Boolean)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetCachedTitle(System.String)">
            <summary>
            If we have this package information, try to get its name
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetMockPackages(System.String)">
            <summary>
            These packages are created from local addons, and should be the only way 99% of systems interact with local addons.
            </summary>
        </member>
        <member name="M:Sandbox.Package.FindAsync(System.String,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Retrieve a list of packages
            </summary>
        </member>
        <member name="M:Sandbox.Package.ListAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Retrieve a list of packages, organised into groups, for discovery
            </summary>
        </member>
        <member name="M:Sandbox.Package.SortByReferences(System.Collections.Generic.IEnumerable{Sandbox.Package})">
            <summary>
            Sort the given list of packages so that referenced packages are ordered before the packages that reference them.
            </summary>
            <param name="unordered">Unordered list of packages.</param>
            <returns>A new enumerable, ordered to maintain references.</returns>
        </member>
        <member name="M:Sandbox.Package.SortByReferences``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Sandbox.Package})">
            <summary>
            Sort the given list of items so that referenced packages are ordered before the packages that reference them.
            </summary>
            <param name="unordered">Unordered list of items with a corresponding package.</param>
            <param name="getPackageFunc">Delegate that maps each item to its corresponding package.</param>
            <returns>A new enumerable, ordered to maintain references.</returns>
        </member>
        <member name="M:Sandbox.Package.FetchVersions(System.String,System.Threading.CancellationToken)">
            <summary>
            Get package version list
            </summary>
        </member>
        <member name="T:Sandbox.LoadedAssembly">
            <summary>
            An assembly that has been loaded into a PackageLoader.
            </summary>
        </member>
        <member name="P:Sandbox.LoadedAssembly.ModifiedAssembly">
            <summary>
            If not null, this is an assembly that was created by Fast Hotload
            </summary>
        </member>
        <member name="T:Sandbox.PackageOptions">
            <summary>
            Options when downloading a package
            </summary>
        </member>
        <member name="F:Sandbox.PackageOptions.Loading">
            <summary>
            Loading progress callbacks
            </summary>
        </member>
        <member name="F:Sandbox.PackageOptions.AllowLocalPackages">
            <summary>
            If true then allow finding local packages
            </summary>
        </member>
        <member name="T:Sandbox.PackageLoader">
            <summary>
            Handles the loading of package assemblies into a loadcontext.
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoader.AccessControl">
            <summary>
            The library used to load assemblies
            </summary>
        </member>
        <member name="P:Sandbox.PackageLoader.ToolsMode">
            <summary>
            In tools mode we don't register events unless they're from a tools project
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            Called on Game Loop Init
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.TestAccessControl(System.IO.Stream,Sandbox.TrustedBinaryStream@)">
            <summary>
            Make sure we should be able to load this dll
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.TryFastHotload(Sandbox.LoadedAssembly,Sandbox.LoadedAssembly)">
            <summary>
            If successful, will change outgoing in place and return true
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.HasOldReferencedAssemblyUnloaded(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            Return true if, between <paramref name="incoming"/> and <paramref name="outgoing"/>,
            package references are added or removed, or a package reference changes version and wasn't fast-hotloaded itself.
            If either is the case, the incoming assembly can't be fast-hotloaded because the types it references have changed.
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.EmitFastHotloadEvent(Sandbox.LoadedAssembly)">
            <summary>
            Trigger a switch event
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.TriggerRegisterEvent(Sandbox.LoadedAssembly)">
            <summary>
            Trigger a switch event
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.TriggerUnregisterEvent(Sandbox.LoadedAssembly)">
            <summary>
            Trigger a switch event
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.GetLoadedAssemblies(System.String,System.Boolean,System.Boolean)">
            <summary>
            Called by Enroller to get the assemblies associated with a package. If deep is true then
            this should return all assemblies needed by this package and its dependencies.
            </summary>
        </member>
        <member name="T:Sandbox.PackageLoader.Enroller">
            <summary>
            Holds a list of assemblies with the intention of enrolling them into
            services like TypeLibrary, Event. Handles deduplication and switching due to 
            hotloading etc..
            </summary>
        </member>
        <member name="F:Sandbox.PackageLoader.Enroller.loaded">
            <summary>
            All of the assembles loaded into this enroller
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.GetLoadedAssemblies">
            <summary>
            Get all of the loaded assemblies. This is only to be used when sending 
            assemblies to children.
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.OnHotloadEvent(Sandbox.LoadedAssembly)">
            <summary>
            Called by PackageLoader when the assembly has undergone a fast hotload
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.OnRegisterEvent(Sandbox.LoadedAssembly)">
            <summary>
            Called after hotload, to register a swapped assembly
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.OnUnregisterEvent(Sandbox.LoadedAssembly)">
            <summary>
            Called after hotload, to register a swapped assembly
            </summary>
        </member>
        <member name="M:Sandbox.PackageLoader.Enroller.Add(Sandbox.LoadedAssembly)">
            <summary>
            Called internally on all the assemblies when a package is loaded.
            This then calls down to all of the listeners, to let them know.
            </summary>
        </member>
        <member name="T:Sandbox.PackageManager.ActivePackage">
            <summary>
            Describes a package that is currently mounted. Mounted packages are shared between client, server and editor.
            We keep track of which host is using which package using Tags.
            </summary>
        </member>
        <member name="P:Sandbox.PackageManager.ActivePackage.ProjectSettings">
            <summary>
            The project settings folder
            </summary>
        </member>
        <member name="P:Sandbox.PackageManager.ActivePackage.Localization">
            <summary>
            The project's localization folder
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.ActivePackage.DownloadAsync(Sandbox.Internal.ILoadingInterface,System.Threading.CancellationToken)">
            <summary>
            Set the filesystem up from this downloaded asset
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.ActivePackage.Delete">
            <summary>
            Called to unmount and remove this package from being active
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.CmdList">
            <summary>
            List all currently active packages
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.CmdAdd(System.String,System.String)">
            <summary>
            Install a package in the specific context
            </summary>
            <param name="package">The package ident</param>
            <param name="context">The context (ie, client, server)</param>
        </member>
        <member name="M:Sandbox.PackageManager.CmdWipe(System.String)">
            <summary>
            Unmount all packages that use a specific tag. This is usually done on leaving a game for client and server
            </summary>
        </member>
        <member name="E:Sandbox.PackageManager.OnPackageInstalledToContext">
            <summary>
            Called when a new package is installed
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.InstallAsync(System.String,System.String,System.Threading.CancellationToken,System.Nullable{Sandbox.PackageOptions})">
            <summary>
            Install a package
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.InstallProjects(Sandbox.Project[],System.Threading.CancellationToken)">
            <summary>
            Install all of the projects as packages
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.Find(System.String)">
            <summary>
            Retrieve a package by ident.
            </summary>
        </member>
        <member name="M:Sandbox.PackageManager.Find(System.String,System.Boolean,System.Boolean)">
            <summary>
            Retrieve a package by ident and minimum download mode.
            </summary>
        </member>
        <member name="M:Sandbox.PackageRevision.DownloadManifestAsync(System.Threading.CancellationToken)">
            <summary>
            The manifest might not be immediately available until you've downloaded it
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioEngine">
            <summary>
            A mix frame size is 512 samples
            A second is made up of 44100 samples
            This means one frame is about 11.6ms
            So as long as mixing takes less than 10ms we're okay
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.ChannelCount">
            <summary>
            How many output channels do we have? Generally 2, but if they have a 7.1 setup it can be more.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.QueuedBuffers">
            <summary>
            By getting the amount of buffers queued, we can determine how many seconds there are of audio in the buffer
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.SecondsPerSample">
            <summary>
            How many seconds one sample lasts
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.EmptyBuffers">
            <summary>
            How many empty buffers are there on the device? We want to keep them all as full as possible, so this
            should generally be 0.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.SamplingRate">
            <summary>
            The engine's output sampling rate. This doesn't change.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioEngine.MixBufferSize">
            <summary>
            The size of one 
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioMeter">
            <summary>
            Allows the capture and monitor of an audio source
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioMeter.Frame.VoiceCount">
            <summary>
            The amount of individual voices playing
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioSampler">
            <summary>
            A wrapper around CAudioMixer, which is used in c++ to read from a wav etc.
            This has two parts. 
            
             o Sample - reads the samples, advances the index
             o GetSamples - returns the samples.
             
            The reason it's coded like this is because each mix frame we read all samples, then
            the mixers can do whatever they want with them. So rather than have the mixers fight
            over reading and advancing, they can all get the samples if they want to.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioSampler.Sample(System.Single)">
            <summary>
            Read samples to our internal buffer and advance the index. 
            Pitch should be default 1.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioSampler.GetLastReadSamples">
            <summary>
            Get the last read samples. This is called by the mixers.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.MixBuffer">
            <summary>
            Contains 512 samples of audio data, this is used when mixing a single channel
            </summary>
        </member>
        <member name="F:Sandbox.Audio.MixBuffer._external">
            <summary>
            If true, this buffer pointer is managed by something else
            </summary>
        </member>
        <member name="F:Sandbox.Audio.MixBuffer._locked">
            <summary>
            This is locked from being disposed
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixBuffer.Silence">
            <summary>
            Silence this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixBuffer.CopyFrom(Sandbox.Audio.MixBuffer)">
            <summary>
            Set this buffer to this value 
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixBuffer.MixFrom(Sandbox.Audio.MixBuffer,System.Single)">
            <summary>
            Mix this buffer with another
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixBuffer.Scale(System.Single)">
            <summary>
            Scale the buffer by volume
            </summary>
        </member>
        <member name="T:Sandbox.Audio.MultiChannelBuffer">
            <summary>
            Holds up to 8 mix buffers, which usually represent output speakers.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.MultiChannelBuffer.ChannelCount">
            <summary>
            How many channels do we have
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.Dispose">
            <summary>
            Delete and release all resources. Cannot be used again.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.Get(System.Int32)">
            <summary>
            Get MixBuffer number i
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.Silence">
            <summary>
            Silence all buffers
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.CopyFrom(Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Set this buffer to this value 
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.MixFrom(Sandbox.Audio.MultiChannelBuffer,System.Single)">
            <summary>
            Mix the target buffer into this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.Scale(System.Single)">
            <summary>
            Scale volume of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.SendToOutput">
            <summary>
            Send to device output
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MultiChannelBuffer.ToMono(Sandbox.Audio.MixBuffer,System.Single)">
            <summary>
            Mix each channel into the single buffer, using passed in volume
            </summary>
        </member>
        <member name="T:Sandbox.Audio.DspInstance">
            <summary>
            An instance of a DspPreset. The actual processor creates one of these from
            a DspPreset, and then uses it to process the audio buffers.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.DspPreset">
            <summary>
            Defines a DSP preset. This is a collection of DSP processors that can be applied to a sound.
            These originate from Half-Life 1's DSP system, and give that iconic Source Engine Sound.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.DspPresetHandle">
            <summary>
            A handle to a DspPreset
            </summary>
        </member>
        <member name="T:Sandbox.Audio.Mixer">
            <summary>
            Takes a bunch of sound, changes its volumes, mixes it together, outputs it
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Meter">
            <summary>
            Allows monitoring of the output of the mixer
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Id">
            <summary>
            Unique identifier for this object, for lookup, deserialization etc
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._listener">
            <summary>
            We don't want to access Sound.Listener directly, because it might keep changing
            in the other thread. This is a local copy for us to use.
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._voiceCount">
            <summary>
            The current voices playing on this mixer
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Name">
            <summary>
            The display name for this mixer
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Volume">
            <summary>
            Scale the volume of our output by this amount
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Spacializing">
            <summary>
            When 0 the sound will come out of all speakers, when 1 it will be fully spacialized
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.DistanceAttenuation">
            <summary>
            Sounds get quieter as they go further away
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Occlusion">
            <summary>
            How much these sounds can get occluded
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.AirAbsorption">
            <summary>
            How much the air absorbs energy from the sound
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Solo">
            <summary>
            Should this be the only mixer that is heard?
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.Mute">
            <summary>
            Is this mixer muted?
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.IsMaster">
            <summary>
            The default mixer gets all sounds that don't have a mixer specifically assigned
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.StartMixing(Transform)">
            <summary>
            Called at the start of the mixing frame
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.MixChildren(System.Collections.Generic.List{Sandbox.SoundHandle})">
            <summary>
            Mix the child mixes
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.MixVoices(System.Collections.Generic.List{Sandbox.SoundHandle})">
            <summary>
            Mix the incoming voices into the mix
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.FinishMixing">
            <summary>
            Mixing is finished. Clean up and finalize
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.MixVoice(Sandbox.SoundHandle)">
            <summary>
            Mix a single voice
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.ConvertToBinaural(Sandbox.SoundHandle,Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            This will spatialize the voice based on its location
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.StopAll(System.Single)">
            <summary>
            Stop all sound handles using this mixer
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.FindMixerByName(Sandbox.Audio.Mixer,System.String)">
            <summary>
            We might want to do a fast lookup at some point
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.FindMixerByGuid(Sandbox.Audio.Mixer,System.Guid)">
            <summary>
            We might want to do a fast lookup at some point
            </summary>
        </member>
        <member name="F:Sandbox.Audio.Mixer._processorList">
            <summary>
            Private, because we want to make this as thread safe as possible
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.AddProcessor(Sandbox.Audio.AudioProcessor)">
            <summary>
            Add a processor to the list
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.ClearProcessors">
            <summary>
            Add a processor to the list
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.RemoveProcessor(Sandbox.Audio.AudioProcessor)">
            <summary>
            Add a processor to the list
            </summary>
        </member>
        <member name="P:Sandbox.Audio.Mixer.ProcessorCount">
            <summary>
            The amount of processors
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.GetProcessors">
            <summary>
            Get the current processor list
            </summary>
        </member>
        <member name="M:Sandbox.Audio.Mixer.ApplyProcessors">
            <summary>
            Actually apply the processors to the output buffer
            </summary>
        </member>
        <member name="T:Sandbox.Audio.MixerHandle">
            <summary>
            A handle to a Mixer
            </summary>
        </member>
        <member name="T:Sandbox.Audio.MixingThread">
            <summary>
            This is a real thread! We need to be very careful about what this accesses, and how.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixingThread.SampleVoices(System.Collections.Generic.List{Sandbox.SoundHandle})">
            <summary>
            Read one sample from each voice
            </summary>
        </member>
        <member name="M:Sandbox.Audio.MixingThread.FinishVoices(System.Collections.Generic.List{Sandbox.SoundHandle})">
            <summary>
            Mark any finished voices as finished
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioProcessor">
            <summary>
            Takes a bunch of samples and processes them. It's common for these to be chained together.
            It's also common for the processor to store state between calls.
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioProcessor.Enabled">
            <summary>
            Is this processor active?
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioProcessor.Mix">
            <summary>
            Should we fade the influence of this processor in?
            </summary>
        </member>
        <member name="P:Sandbox.Audio.AudioProcessor.Listener">
            <summary>
            The listener's position in this frame (don't use Sound.Listener!)
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.Process(Sandbox.Audio.MultiChannelBuffer,Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Should process input into output
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.ProcessInPlace(Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Will process the buffer, and copy it back to output
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.ProcessEachChannel(Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Called internally to process each channel in a buffer
            </summary>
        </member>
        <member name="M:Sandbox.Audio.AudioProcessor.ProcessSingleChannel(Sandbox.Audio.AudioChannel,System.Span{System.Single})">
            <summary>
            For implementations that process each channel individually
            </summary>
        </member>
        <member name="T:Sandbox.Audio.AudioChannel">
            <summary>
            Represents an audio channel, between 0 and 7. This is used to index into buffers.
            This is used rather than an int to avoid unfortuate bugs.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.PerChannel`1">
            <summary>
            Stores a variable per channel
            </summary>
        </member>
        <member name="T:Sandbox.Audio.HighPassProcessor">
            <summary>
            Just a test - don't count on this sticking around
            </summary>
        </member>
        <member name="P:Sandbox.Audio.HighPassProcessor.Amount">
            <summary>
            Controls the strength of the filtering. Range is 0.0 to 1.0.
            Higher values mean more of the high frequencies are allowed through.
            </summary>
        </member>
        <member name="T:Sandbox.Audio.LowPassProcessor">
            <summary>
            Just a test - don't count on this sticking around
            </summary>
        </member>
        <member name="P:Sandbox.Audio.LowPassProcessor.Amount">
            <summary>
            Controls the strength of the filtering. Range is 0.0 to 1.0.
            Lower values mean more smoothing (stronger low-pass effect).
            </summary>
        </member>
        <member name="M:Sandbox.Audio.DirectSource.Snap">
            <summary>
            Stop any lerping and jump straight to the target occlusion
            </summary>
        </member>
        <member name="T:Sandbox.Audio.SteamAudio">
            <summary>
            Static global SteamAudio manager
            </summary>
        </member>
        <member name="T:Sandbox.Audio.SteamAudioSource">
            <summary>
            A source for the "direct" group of effects. This gets added to the SteamAudio scene and
            is simulated for things like occlusion.
            </summary>
        </member>
        <member name="M:Sandbox.Audio.SteamAudioSource.ApplyDirectMix(Transform@,Sandbox.Audio.MultiChannelBuffer,Sandbox.Audio.MultiChannelBuffer,System.Single,System.Single,System.Single)">
            <summary>
            Buffers should be mono in, mono out
            </summary>
        </member>
        <member name="M:Sandbox.Audio.SteamAudioSource.ApplyBinauralMix(Vector3,System.Single,Sandbox.Audio.MultiChannelBuffer,Sandbox.Audio.MultiChannelBuffer)">
            <summary>
            Buffers should be mono in, stereo out
            </summary>
        </member>
        <member name="M:Sandbox.Audio.SteamAudioSource.UpdateFrom(Sandbox.SoundHandle)">
            <summary>
            Called by the sound handle at the appropriate times to update the native source
            </summary>
        </member>
        <member name="T:Sandbox.Sound">
            <summary>
            Single source for creating sounds
            </summary>
        </member>
        <member name="P:Sandbox.Sound.MasterVolume">
            <summary>
            The user's preference for their field of view
            </summary>
        </member>
        <member name="M:Sandbox.Sound.Preload(System.String)">
            <summary>
            Precaches sound files associated with given sound event by name.
            This helps avoid stutters on first load of each sound file.
            </summary>
        </member>
        <member name="P:Sandbox.Sound.DspNames">
            <summary>
            Get a list of available DSP names
            </summary>
        </member>
        <member name="M:Sandbox.Sound.UncompressVoiceData(System.Byte[],System.Action{System.Memory{System.Int16}})">
            <summary>
            Uncompress the voice data
            </summary>
        </member>
        <member name="P:Sandbox.Sound.VoiceSampleRate">
            <summary>
            The sample rate for voice data
            </summary>
        </member>
        <member name="M:Sandbox.Sound.Play(Sandbox.SoundEvent,Vector3)">
            <summary>
            Play a sound and set its position
            </summary>
        </member>
        <member name="M:Sandbox.Sound.Play(System.String,Vector3)">
            <summary>
            Play a sound and set its position
            </summary>
        </member>
        <member name="M:Sandbox.Sound.Play(System.String,Sandbox.Audio.Mixer)">
            <summary>
            Play a sound and set its mixer
            </summary>
        </member>
        <member name="T:Sandbox.SoundHandle">
            <summary>
            A handle to a sound that is currently playing. You can use this to control the sound's position, volume, pitch etc.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Position">
            <summary>
            Position of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Rotation">
            <summary>
            The direction the sound is facing
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Transform">
            <summary>
            This sound's transform
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Volume">
            <summary>
            Volume of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Name">
            <summary>
            A debug name to help identify the sound
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.SpacialBlend">
            <summary>
            How 3d the sound should be. 0 means no 3d, 1 means fully
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Decibels">
            <summary>
            Determines how far away the sound can be heard
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Pitch">
            <summary>
            Pitch of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.IsPlaying">
            <summary>
            Whether the sound is currently playing or not.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Finished">
            <summary>
            Sound is done
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Reflections">
            <summary>
            Enable the sound reflecting off surfaces
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Occlusion">
            <summary>
            Allow this sound to be occluded by geometry etc
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.OcclusionRadius">
            <summary>
            The radius of this sound's occlusion, allow for partial occlusion
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.DistanceAttenuation">
            <summary>
            Should the sound fade out over distance
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.AirAbsorption">
            <summary>
            Should the sound get absorbed by air, so it sounds different at distance
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Transmission">
            <summary>
            Should the sound transmit through walls, doors etc
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.TargetMixer">
            <summary>
            Which mixer do we want to write to
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.SampleRate">
            <summary>
            How many samples per second?
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.SamplingFinished">
            <summary>
            We finished sampling, likely sticking around for a bit
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.TimeUntilFinished">
            <summary>
            Keep playing silently for a second or two, to finish reverb effect
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.IsStopped">
            <summary>
            True if the sound has been stopped
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.ListenLocal">
            <summary>
            Place the listener at 0,0,0 facing 1,0,0.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Loopback">
            <summary>
            If true, then this sound won't be played unless voice_loopback is 1. The assumption is that it's the 
            local user's voice. Amplitude and visme data will still be available!
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.Amplitude">
            <summary>
            Measure of audio loudness.
            </summary>
        </member>
        <member name="M:Sandbox.SoundHandle.WantsDefaultMixer">
            <summary>
            Return true if this has no mixer specified, so will use the default mixer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SoundHandle.IsTargettingMixer(Sandbox.Audio.Mixer)">
            <summary>
            Return true if we want to play on this mixer. Will return true if we have no
            mixer specified, and the provided mixer is the default.
            </summary>
        </member>
        <member name="M:Sandbox.SoundHandle.Update">
            <summary>
            Called to push changes to a sound immediately, rather than waiting for the next tick.
            You should call this if you make changes to a sound.
            </summary>
        </member>
        <member name="M:Sandbox.SoundHandle.OnActive">
            <summary>
            Before we're added to the active list, we need to get some stuff straight
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSync">
            <summary>
            Access lipsync processing.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.Visemes">
            <summary>
            A list of 15 lipsync viseme weights. Requires <see cref="P:Sandbox.SoundHandle.LipSyncAccessor.Enabled"/> to be true.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.FrameNumber">
            <summary>
            Count from start of recognition.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.FrameDelay">
            <summary>
            Frame delay in milliseconds.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.LaughterScore">
            <summary>
            Laughter score for the current audio frame.
            </summary>
        </member>
        <member name="P:Sandbox.SoundHandle.LipSyncAccessor.Enabled">
            <summary>
            Enables lipsync processing.
            </summary>
        </member>
        <member name="P:Sandbox.SoundStream.SampleRate">
            <summary>
            Number of samples per second, as set during its creation.
            </summary>
        </member>
        <member name="P:Sandbox.SoundStream.Channels">
            <summary>
            Number of audio channels, as set during its creation.
            </summary>
        </member>
        <member name="M:Sandbox.SoundStream.Play(System.Single,System.Single,System.Single)">
            <summary>
            Play sound of the stream.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Bootstrap.VersionSha">
            <summary>
            The github SHA of the current build
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.PreInit(CMaterialSystem2AppSystemDict)">
            <summary>
            Called before anything else. This should set up any low level stuff that
            might be relied on if static functions are called.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.EnvironmentExit(System.Int32)">
            <summary>
            Let's native exit the C# app so AppDomain.ProcessExit gets called
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.TaskScheduler_UnobservedTaskException(System.Object,System.Threading.Tasks.UnobservedTaskExceptionEventArgs)">
            <summary>
            Called on exceptions from a task (delayed, because it'll only get called when the exception gets collected)
            TODO: Move this somewhere else
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.Init">
            <summary>
            Called to initialize the engine.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.LoadingFinished">
            <summary>
            Should be called when startup has finished.
            If we have a client, this is when the menu is first entered.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IBaseDll.OwnsAssembly(System.Reflection.Assembly)">
            <summary>
            Return true if this assembly is a part of this context
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IGameMenuDll.Disconnect">
            <summary>
            Called when the "disconnect" command is ran.
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GameLoadingFlags.Remote">
            <summary>
            Set if we're loading a game as a result of joining a server
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GameLoadingFlags.Host">
            <summary>
            Set if we're the hosting as the result of starting our own server
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GameLoadingFlags.Reload">
            <summary>
            Set if we want to reload the game, even if it's already loaded
            </summary>
        </member>
        <member name="F:Sandbox.Engine.GameLoadingFlags.Developer">
            <summary>
            Set if this is a developer session. It started from an editor session and as such we shouldn't load
            assemblies from the package, they should be loaded from the Network Tables instead.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.Name">
            <summary>
            The name of this context, for debugging purposes
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.MouseCursor">
            <summary>
            What mouse cursor does this context want to show?
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.MouseState">
            <summary>
            What kind of mouse interaction is this context interested in right now
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.MouseCapture">
            <summary>
            Mouse is UI mode but wants to use the mouse capture/delta mode
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.KeyboardState">
            <summary>
            What kind of keyboard interaction is this context interested in right now
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.OnMouseMotion">
            <summary>
            Mouse moved in game mode
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.OnMouseMoved">
            <summary>
            Mouse moved in UI mode
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.OnGameButton">
            <summary>
            A button event to be sent to the game
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.OnEscapeButton">
            <summary>
            The escape button has been pressed
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputContext.TrappingKeys">
            <summary>
            When true we've called StartTrapping and are waiting for the user to release keys
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputContext.StartTrapping(System.Action{System.String[]})">
            <summary>
            Start trapping keys. When the user releases all keys the callback will be called
            with a list of buttons that were pressed during the trap.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputContext.EndTrapping">
            <summary>
            Called when a key is released if we're trapping keys.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputContext.In_Escape">
            <summary>
            Special handling for the escape button. Return false if we didn't use it.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputContext.IN_ButtonReleased(NativeEngine.ButtonCode,Sandbox.KeyboardModifiers)">
            <summary>
            This is called even if the context doesn't have focus.
            It's just a place to unpress buttons, if they're down.
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputContext.InputState.Ignore">
            <summary>
            Doesn't want it, pass down to next context
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputContext.InputState.UI">
            <summary>
            Interacting with UI
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputContext.InputState.Game">
            <summary>
            Interacting with the game
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IToolsDll.RegisterHandle(System.IntPtr,System.UInt32)">
            <summary>
            Registers exclusive Sandbox.Tools <see cref="T:Sandbox.IHandle"/> types
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IToolsDll.LoadProject">
            <summary>
            Load the startup project for the first time
            </summary>
        </member>
        <member name="P:Sandbox.Engine.IToolsDll.IsGameViewVisible">
            <summary>
            Is the game view visible, or is it in a tab in the background?
            </summary>
        </member>
        <member name="T:Sandbox.Engine.SandboxedLoadContext">
            <summary>
            A LoadContext holds a bunch of instanced assemblies. These assemblies and the types within
            are separate from each other. This means we can load two Sandbox.Event dlls and the globals
            will be different in both. This is good for different realms of addons where we want them to
            all be separate.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Settings.RenderSettings.ApplySettingsForBenchmarks">
            <summary>
            We want benchmarks to have all similar settings. Set them here.
            The only fluctuations we should see are resolution and hardware.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Input">
            <summary>
            Temporary housing for common inputs
            Games that don't define any input actions will get a bunch of default actions given to them
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Input.GetKeyWithBinding(System.String)">
            <summary>
            Returns the name of a key that is bound to this value
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Input.GetBindingForButton(System.String)">
            <summary>
            Returns the binding for this key
            </summary>
        </member>
        <member name="T:Sandbox.Engine.BindCollection">
            <summary>
            
            A collection of action binds. 
            
             BindCollection
               - Action: attack1
                 - Slot0: mouse1
               - Action: selectall
                 - Slot0: ctrl + a
                 
            The bind collection can be saved and loaded from disk via the BindSaveConfig class.
            
            The bind collection can have a base collection which it will fall back to if it contains
            the same binds. This allows us to have a "common" collection which can be shared between
            all games, but can also let the games + users to override those binds if they choose.
            
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindCollection.Base">
            <summary>
            The base collection. Game binds have this set to the common binds.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindCollection.CollectionName">
            <summary>
            Will be either "common" or the ident of the current game.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindCollection.ConfigPath">
            <summary>
            The location of the config file to load from in EngineFileSystem.Config
            </summary>
        </member>
        <member name="F:Sandbox.Engine.BindCollection.Actions">
            <summary>
            The actual collection of binds.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.#ctor(System.String)">
            <summary>
            Creates a collection and tries to load it from disk.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.FillDefaultCommonInputs">
            <summary>
            If we're the common collection and have no binds (because we haven't
            been able to load a customized config from disk) then we'll fill in
            the defaults based on Input.CommonInputs.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.GetBind(System.String,System.Boolean)">
            <summary>
            Get the bind, create if it doesn't exist
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.Set(System.String,System.Int32,System.String)">
            <summary>
            Set the bind value for this action. This will overwrite what's in this slot.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.Get(System.String,System.Int32)">
            <summary>
            Get the bind value at this slot
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.SaveToDisk">
            <summary>
            Save the collection to disk
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.ResetToDefaults">
            <summary>
            Reset the collection to the default values.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.EnumerateWithButton(System.String)">
            <summary>
            Enumerate all actions that contain this button
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindCollection.UpdateActions(System.Collections.Generic.List{Sandbox.InputAction})">
            <summary>
            The action list has changed, we just got the config from the server.
            Here we'll clear the actions, add all of the defaults from the new config
            and then load the user config if it exists.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindCollection.ActionBind.IsCommon">
            <summary>
            If this is set then we want to read the value from the base collection
            </summary>
        </member>
        <member name="T:Sandbox.Engine.BindSaveConfig">
            <summary>
            A struct which is serialized/deserialized to save binds to a file (in a more readable format)
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindSaveConfig.Schema">
            <summary>
            To allow us to cater for changes in schema
            </summary>
        </member>
        <member name="P:Sandbox.Engine.BindSaveConfig.Binds">
            <summary>
            A list of strings that describe the binds
                "jump": "space;m",
            	"run": "shift",
            	"walk": "alt",
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindSaveConfig.Load(System.String,Sandbox.Engine.BindCollection)">
            <summary>
            Load a serialized collection from disk
            </summary>
        </member>
        <member name="M:Sandbox.Engine.BindSaveConfig.Save(System.String,Sandbox.Engine.BindCollection)">
            <summary>
            Save a serialized collection to disk
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputBinds.FindCollection(System.String)">
            <summary>
            Find a bind collection by name. The name is generally the ident of the current game.
            We'll try to load the binds from /config/input/*.json - if we fail then we'll serve
            the default.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.InputRouter">
            <summary>
            This is where input is sent to from the engine. This is the first place input is routed to.
            From here it tries to route it to the menu, game menu and client - in that order. That should
            really be abstracted out though, so we can use this properly in Standalone.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.MouseCursorVisible">
            <summary>
            True if the cursor is visible
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.MouseCursorPosition">
            <summary>
            The mouse cursor position. Or the last position if it's now invisible.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.MouseCursorDelta">
            <summary>
            The mouse cursor delta
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.KeyboardFocusPanel">
            <summary>
            The panel we're keyboard focusing on
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputRouter.mouseCapturePosition">
            <summary>
            The position in which we entered capture/relative mode
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.EscapeIsDown">
            <summary>
            True if an "exit game" button is pressed, escape on keyboard
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.EscapeWasPressed">
            <summary>
            The escape button was pressed this frame. 
            The game is allowed to consume this. Then it will go to the menu.
            This is distinct from EscapeIsDown, because that is used to close the game when held down.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.TimeSinceEscapePressed">
            <summary>
            Time since escape was pressed
            </summary>
        </member>
        <member name="F:Sandbox.Engine.InputRouter.PressedButtons">
            <summary>
            Buttons that are currently pressed
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.EscapeTime">
            <summary>
            Returns the number of seconds escape has been held down
            </summary>
        </member>
        <member name="P:Sandbox.Engine.InputRouter.Contexts">
            <summary>
            Return the input contexts of each context, in order of priority
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.SetCursorPosition(Sandbox.Engine.InputContext,Vector2)">
            <summary>
            An input context wants to set the cursor position
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.IsButtonDown(NativeEngine.ButtonCode)">
            <summary>
            Return true if button is pressed
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.SetButtonState(NativeEngine.ButtonCode,System.Boolean)">
            <summary>
            Return true if button is pressed
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.OnMouseMotion(System.Int32,System.Int32)">
            <summary>
            Cursor is hidden and restricted to window (game mode) but the mouse has been moved
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.OnMousePositionChange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Cursor is visible and mouse is being moved
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.OnEscapePressed(System.Boolean)">
            <summary>
            The escape, or start button has been pressed
            </summary>
        </member>
        <member name="M:Sandbox.Engine.InputRouter.EngineToModifier(System.Int32)">
            <summary>
            Convert engine (IE_ShiftPressed etc) to our KeyboardModifiers enum
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Protocol">
            <summary>
            Protocol values are defined in c++ and passed down.
            Check out protocol.h to update them.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Protocol.Api">
            <summary>
            Only show addons that were compiled with this version
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Protocol.Network">
            <summary>
            Network protocol version
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.Username">
            <summary>
            Your own username
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.UserId">
            <summary>
            Your own user id
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.ServiceType">
            <summary>
            The service type (ie "Twitch")
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.IsActive">
            <summary>
            Are we connected to a service
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.ProcessorName">
            <summary>
            Human-readable product name of this system's processor.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.ProcessorFrequency">
            <summary>
            The frequency of this system's processor in GHz.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.ProcessorCount">
            <summary>
            The number of logical processors in this system.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.TotalMemory">
            <summary>
            Total physical memory available on this machine, in bytes.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.Gpu">
            <summary>
            Human-readable product name of the graphics card in this system.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.GpuVersion">
            <summary>
            The version number of the graphics card driver.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.GpuMemory">
            <summary>
            Total VRAM on this system's graphics card.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.StorageSizeAvailable">
            <summary>
            Indicates the amount of available free space on game drive in bytes
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SystemInfo.StorageSizeTotal">
            <summary>
            Gets the total size of storage space on game drive in bytes
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Run">
            <summary>
            Run the trace and return the result. The result will return the first hit.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Ray(Vector3@,Vector3@)">
            <summary>
            Casts a ray from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Ray(Ray@,System.Single@)">
            <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithTag(System.String)">
            <summary>
            Only return scene objects with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the scene object will need all tags).
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithAllTags(System.String[])">
            <summary>
            Only return scene objects with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithAnyTags(System.String[])">
            <summary>
            Only return scene objects with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithoutTags(System.String[])">
            <summary>
            Only return scene objects without any of these tags
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Distance">
            <summary>
            The distance between start and end positions.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.StartPosition">
            <summary>
            The start position of the trace
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.EndPosition">
            <summary>
            The end or hit position of the trace
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.HitPosition">
            <summary>
            The hit position of the trace
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Fraction">
            <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Normal">
            <summary>
            The hit surface normal (direction vector)
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Transform">
            <summary>
            The transform of the hit object (if it has one)
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.SceneObject">
            <summary>
            If we hit something associated with a sceneobject, this will be that object.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.HitTriangleUv">
            <summary>
            This is the Uv coordinate on the triangle hit. 'x' represents the distance between Vertex 0-1, 'y' represents the distance between Vertex 0-2.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.VertexInfluence">
            <summary>
            Given the position on the triangle hit, this vector gives the influence of each vertex on that position.
            So for example, if the Vector is [1,0,0] that means that the hit point is right on vertex 0. If it's [0.33, 0.33, 0.33] then it's 
            right in the middle of each vertex.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.WebSocket">
            <summary>
            A WebSocket client for connecting to external services.
            </summary>
            <remarks>
            Events handlers will be called on the synchronization context that <see cref="M:Sandbox.Engine.WebSocket.Connect(System.String,System.Threading.CancellationToken)"/> was called on.
            </remarks>
        </member>
        <member name="T:Sandbox.Engine.WebSocket.MessageReceivedHandler">
            <summary>
            Event handler which processes text messages from the WebSocket service.
            </summary>
            <param name="message">The message text that was received.</param>
        </member>
        <member name="T:Sandbox.Engine.WebSocket.DataReceivedHandler">
            <summary>
            Event handler which processes binary messages from the WebSocket service.
            </summary>
            <param name="data">The binary message data that was received.</param>
        </member>
        <member name="T:Sandbox.Engine.WebSocket.DisconnectedHandler">
            <summary>
            Event handler which fires when the WebSocket disconnects from the server.
            </summary>
            <param name="status">The close status code from the server, or 0 if there was none. See known values here: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</param>
            <param name="reason">The reason string for closing the connection. This may not be populated, may be from the server, or may be a client exception message.</param>
        </member>
        <member name="P:Sandbox.Engine.WebSocket.IsConnected">
            <summary>
            Returns true as long as a WebSocket connection is established.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.WebSocket.SubProtocol">
            <summary>
            Get the sub-protocol that was negotiated during the opening handshake.
            </summary>
        </member>
        <member name="E:Sandbox.Engine.WebSocket.OnMessageReceived">
            <summary>
            Event which fires when a text message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.Engine.WebSocket.OnDataReceived">
            <summary>
            Event which fires when a binary message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.Engine.WebSocket.OnDisconnected">
            <summary>
            Event which fires when the connection to the WebSocket service is lost, for any reason.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.#ctor(System.Int32)">
            <summary>
            Initialized a new WebSocket client.
            </summary>
            <param name="maxMessageSize">The maximum message size to allow from the server, in bytes. Default 64 KiB.</param>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Dispose">
            <summary>
            Cleans up resources used by the WebSocket client. This will also immediately close the connection if it is currently open.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.AddSubProtocol(System.String)">
            <summary>
            Add a sub-protocol to be negotiated during the WebSocket connection handshake.
            </summary>
            <param name="protocol"></param>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Connect(System.String,System.Threading.CancellationToken)">
            <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
            <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
            <param name="ct">A <see cref="T:System.Threading.CancellationToken"/> which allows the connection attempt to be aborted if necessary.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the connection is established, or throws if it failed to connect.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.String)">
            <summary>
            Sends a text message to the WebSocket server.
            </summary>
            <param name="message">The message text to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.Byte[])">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <remarks>
            The <see cref="M:Sandbox.Engine.WebSocket.Send(System.ArraySegment{System.Byte})"/> and <see cref="M:Sandbox.Engine.WebSocket.Send(System.Span{System.Byte})"/> overloads allow sending subsections of byte arrays.
            </remarks>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.ArraySegment{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.Span{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="P:Sandbox.Command.IsProtected">
            <summary>
            If true, this command should not be accessible by the game code.
            It's okay to run the command via the console, but not via game code.
            This should default to true unless the command is created in game code.
            </summary>
        </member>
        <member name="M:Sandbox.Command.GetAutoComplete(System.String)">
            <summary>
            Todo: Add support for managed commands to return shit here
            Todo: We could maybe do this in a cool way, using parameters?
                  So that for example, we could list players if it's a player etc
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.AddAssembly(System.Reflection.Assembly,System.String,System.Boolean)">
            <summary>
            Add this assembly to the console library, which will scan it for console commands and make them available.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.RemoveAssembly(System.Reflection.Assembly)">
            <summary>
            Remove this assembly and its console commands.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.AddCommand(Sandbox.Command)">
            <summary>
            Add this command to the library. Any existing commands named the same will be over-written.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.AddConVar(Sandbox.Command)">
            <summary>
            Add this convar to the library. Any existing commands named the same will be over-written.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.GetValue(System.String,System.String,System.Boolean)">
            <summary>
            Get a ConVar value as a string.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.SetValue(System.String,System.Object,System.Boolean)">
            <summary>
            Try to set a ConVar. You will only be able to set variables that you have permission to set.
            </summary>
        </member>
        <member name="M:Sandbox.ConVarSystem.SaveAll">
            <summary>
            Save all the convars.
            </summary>
        </member>
        <member name="P:Sandbox.CookieItem.DeleteAt">
             <summary>
             If set to non 0, this key will be deleted at/after given time.
             This is useful in case you didn't open your game for more than 30 days (which is the default expiry time),
             and then you lose all your cookies because they all are expired and get deleted on launch.
            
             This way you have a 24 hour grace period.
             </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Dispose">
            <summary>
            Not public, not IDisposable. Don't want people to be able to do this from game.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.SetString(System.String,System.String)">
            <summary>
            Set a cookie to be stored between sessions. The cookie will expire one month
            from when it was set.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.GetString(System.String,System.String)">
            <summary>
            Get a stored session cookie.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.TryGetString(System.String,System.String@)">
            <summary>
            Get a stored session cookie.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Get``1(System.String,``0)">
            <summary>
            Load JSON encodable data from cookies
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Set``1(System.String,``0)">
            <summary>
            Set JSON encodable object to data
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Remove(System.String)">
            <summary>
            Removes a cookie from the cache entirely
            </summary>
            <param name="key"></param>
        </member>
        <member name="T:Sandbox.Diagnostics.Allocations">
            <summary>
            Tools for diagnosing heap allocations
            </summary>
        </member>
        <member name="T:Sandbox.Diagnostics.CodeIterate">
            <summary>
            A shared private class with the explicit purpose of recording how long it takes
            between a developer saving a .cs file, and the changes being available on the client.
            This is used to diagnose and monitor the code iteration time.
            </summary>
        </member>
        <member name="M:Sandbox.Diagnostics.Performance.Scope(System.String)">
            <summary>
            Record a frame state section in PerformanceStats
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.FrameTime">
            <summary>
            Get the time taken, in seconds, that were required to process the previous frame.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.GpuFrametime">
            <summary>
            Latest available GPU frametime, in ms.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.GpuFrameNumber">
            <summary>
            Frame number of the last reported <see cref="P:Sandbox.Diagnostics.PerformanceStats.GpuFrametime"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.BytesAllocated">
            <summary>
            The number of bytes that were allocated on the managed heap in the last frame.
            <remarks>This may not include allocations from threads other than the game thread.</remarks>
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.Gen0Collections">
            <summary>
            Number of generation 0 (fastest) garbage collections were done in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.Gen1Collections">
            <summary>
            Number of generation 1 (fast) garbage collections were done in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.Gen2Collections">
            <summary>
            Number of generation 2 (slow) garbage collections were done in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.ApproximateProcessMemoryUsage">
            <summary>
            Approximate working set of this process.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.LastSecond">
            <summary>
            Performance statistics over the last period, which is dictated by "perf_time" console command.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.perf_time">
            <summary>
            Update interval for <see cref="P:Sandbox.Diagnostics.PerformanceStats.LastSecond"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.ObjectsRendered">
            <summary>
            Number of objects rendered that passed the cull checks.
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.TrianglesRendered">
            <summary>
            Total number of triangles rendered
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.DrawCalls">
            <summary>
            Number of draw calls
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.MaterialChanges">
            <summary>
            Number of scenesystem material changes
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.DisplayLists">
            <summary>
            Number of display lists submitted to the GPU
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.SceneViewsRendered">
            <summary>
            Number of scene system views rendered
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.RenderTargetResolves">
            <summary>
            Number of render target resolves
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.ObjectsCulledByVis">
            <summary>
            Number of objects culled by static visibility (vis)
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.ObjectsCulledByScreenSize">
            <summary>
            Number of objects culled by screen size
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.ObjectsCulledByFade">
            <summary>
            Number of objects culled by distance fading
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.ObjectsFading">
            <summary>
            Number of objects currently being distance-faded
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.ShadowedLightsInView">
            <summary>
            Number of lights in view that cast shadows
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.UnshadowedLightsInView">
            <summary>
            Number of lights in view that don't cast shadows
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.SceneStats.ShadowMaps">
            <summary>
            Number of shadow maps rendered this frame
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.NumFrames">
            <summary>
            How many frames have we rendered so far?
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.NumDroppedFrames">
            <summary>
            How many frames have we missed so far?
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.ReprojectionRatio">
            <summary>
            Number of frames that were reprojected as a fraction
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.TotalRenderGpu">
            <summary>
            Total GPU time in milliseconds
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.CompositorRenderGpu">
            <summary>
            Total time the compositor took on the GPU, in milliseconds
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.CompositorRenderCpu">
            <summary>
            Total time the compositor took on the CPU, in milliseconds
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.ResolutionScale">
            <summary>
            SteamVR supersampling scale as a fraction
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.Resolution">
            <summary>
            Effective render resolution (base resolution multiplied by <see cref="F:Sandbox.Diagnostics.PerformanceStats.VRStats.ResolutionScale"/>), per-eye
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.InterpupillaryDistance">
            <summary>
            IPD in millimetres
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.LeftControllerBatteryPercentage">
            <summary>
            Total left controller battery percentage (0 to 100)
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.RightControllerBatteryPercentage">
            <summary>
            Total right controller battery percentage (0 to 100)
            </summary>
        </member>
        <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.HeadsetBatteryPercentage">
            <summary>
            Total headset battery percentage (0 to 100)
            </summary>
        </member>
        <member name="P:Sandbox.Diagnostics.PerformanceStats.VR">
            <summary>
            Stats retrieved from the SteamVR compositor
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.Exiting">
            <summary>
            Game is closing
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.DispatchConsoleCommand(System.String,System.String,System.Int64)">
            <summary>
            A console command has arrived, or a convar has changed
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.DisposeAtFrameEnd(System.IDisposable)">
            <summary>
            Queue something to be disposed of after the frame has ended and everything has finished rendering.
            </summary>
        </member>
        <member name="T:Sandbox.BlendMode">
            <summary>
            Blend modes used by the UI system
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.Translucent">
            <summary>
            Translucent pass. We're rendering translucent objects in depth sorted order, from back to front.
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.Shadow">
            <summary>
            Rendering dynamic shadows
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.EffectsTranslucent">
            <summary>
            Translucent effects on the 1/4 texture
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.EffectsOpaque">
            <summary>
            Opaque effects on the 1/4 texture
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.DepthPrepass">
            <summary>
            Depth prepass to reduce overdraw
            </summary>
        </member>
        <member name="T:Sandbox.AssetDownloadCache">
            <summary>
            Downloadeded assets go in the ".source2/assets" folder, where they are symlinked on demand
            for use by the engine.
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.Reset">
            <summary>
            Remove all symlinks, clear the filesystem
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.StoreFile(System.String,System.UInt64,System.Byte[])">
            <summary>
            We have downloaded an asset file. Store it for reuse in the future
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.TryMountFile(System.String,System.UInt64,System.Boolean@)">
            <summary>
            Try to mount the downloaded file with this path and crc. If it doesn't exist, return false
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.CreateCacheFilename(System.String,System.UInt64)">
            <summary>
            Makes sure the directory exists, and returns the relative path to this file
            </summary>
        </member>
        <member name="M:Sandbox.AssetDownloadCache.GetAbsolutePath(System.String,System.UInt64)">
            <summary>
            Generate the absolute path for this, whether it exists or not
            </summary>
        </member>
        <member name="P:Sandbox.EngineFileSystem.Assets">
            <summary>
            For tools, maintain a list of mounted addon content paths
            </summary>
        </member>
        <member name="P:Sandbox.EngineFileSystem.Temporary">
            <summary>
            A place to write files temporarily. This is stored in memory so 
            cleaning up after yourself is a good idea (!)
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.Initialize(System.String)">
            <summary>
            Don't try to use the filesystem until you've called this!
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.InitializeConfigFolder(System.String)">
            <summary>
            Setup Config parameter
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.InitializeAddonsFolder(System.String)">
            <summary>
            Setup Addons parameter (there's no reason for this to exist now?)
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.InitializeDownloadsFolder(System.String)">
            <summary>
            Setup Download folder
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.InitializeDataFolder(System.String)">
            <summary>
            Setup Addons parameter (there's no reason for this to exist now?)
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.Shutdown">
            <summary>
            Should only be called at the very death
            </summary>
        </member>
        <member name="T:Sandbox.PackageFileSystem">
            <summary>
            A filesystem that redirects a package's local paths to the actual files in a download cache
            </summary>
        </member>
        <member name="M:Sandbox.PackageFileSystem.AddFile(System.String,System.UInt64)">
            <summary>
            Add a file to this redirect system
            </summary>
        </member>
        <member name="T:Sandbox.Clothing">
            <summary>
            A piece of player model customization.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Title">
            <summary>
            Name of the clothing to show in UI.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Subtitle">
            <summary>
            A subtitle for this clothing piece.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Category">
            <summary>
            What kind of clothing this is?
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.ConditionalModels">
            <summary>
            A list of conditional models.
            (key) = tag(s), (value) = model
            </summary>
        </member>
        <member name="M:Sandbox.Clothing.GetModel(System.Collections.Generic.IEnumerable{Sandbox.Clothing})">
            <summary>
             Tries to get the model for this current clothing. Takes into account any conditional model for other clothing.
            </summary>
            <param name="clothingList"></param>
            <returns></returns>
        </member>
        <member name="P:Sandbox.Clothing.SubCategory">
            <summary>
            This should be a single word to describe the subcategory, and should match any other items you want to categorize in the same bunch. The work will be tokenized so it can become localized.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Parent">
            <summary>
            The clothing to parent this too.  It will be displayed as a variation of its parent
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Model">
            <summary>
            The model to bonemerge to the player when this clothing is equipped.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HumanAltModel">
            <summary>
            The model to bonemerge to the human player when this clothing is equipped.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.SkinMaterial">
            <summary>
            Replace the skin with this material
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.EyesMaterial">
            <summary>
            Replace the eyes with this material
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.MaterialGroup">
            <summary>
            Which material group of the model to use.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.SlotsUnder">
            <summary>
            Which slots this clothing takes on "inner" layer.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.SlotsOver">
            <summary>
            Which slots this clothing takes on "outer" layer.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.HideBody">
            <summary>
            Which body parts of the player model should not show when this clothing is equipped.
            </summary>
        </member>
        <member name="M:Sandbox.Clothing.CanBeWornWith(Sandbox.Clothing)">
            <summary>
            Return true if this item of clothing can be worn with the target item, at the same time.
            </summary>
        </member>
        <member name="P:Sandbox.Clothing.Icon">
            <summary>
            Icon for this clothing piece.
            </summary>
        </member>
        <member name="M:Sandbox.Clothing.DressSceneObject(Sandbox.SceneModel,System.Collections.Generic.IEnumerable{Sandbox.Clothing})">
            <summary>
            Dress this sceneobject with the passed clothes. Return the created clothing.
            </summary>
        </member>
        <member name="M:Sandbox.Clothing.GetBodyGroups(System.Collections.Generic.IEnumerable{Sandbox.Clothing})">
            <summary>
            Return a list of bodygroups and what their value should be
            </summary>
        </member>
        <member name="T:Sandbox.ClothingContainer">
            <summary>
            Holds a collection of clothing items. Won't let you add items that aren't compatible.
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.ClothingEntry.Tint">
            <summary>
            Used to select a tint
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.Height">
            <summary>
            The avatar's height. Default is 1.
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Normalize">
            <summary>
            Restrict things like Height to their sensible limits
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Toggle(Sandbox.Clothing)">
            <summary>
            Add a clothing item if we don't already contain it, else remove it
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Add(Sandbox.Clothing)">
            <summary>
            Add clothing item
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.FindEntry(Sandbox.Clothing)">
            <summary>
            Find a clothing entry matching this clothing item
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Remove(Sandbox.Clothing)">
            <summary>
            Remove clothing item
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Has(Sandbox.Clothing)">
            <summary>
            Returns true if we have this clothing item
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.GetBodyGroups">
            <summary>
            Return a list of bodygroups and what their value should be
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.GetBodyGroups(System.Collections.Generic.IEnumerable{Sandbox.Clothing})">
            <summary>
            Return a list of bodygroups and what their value should be
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Serialize">
            <summary>
            Serialize to Json
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.Deserialize(System.String)">
            <summary>
            Deserialize from Json
            </summary>
        </member>
        <member name="T:Sandbox.ClothingContainer.Entry">
            <summary>
            Used for serialization
            </summary>
        </member>
        <member name="P:Sandbox.ClothingContainer.Entry.Tint">
            <summary>
            Tint variable used to evaluate the model tint color gradient
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.CreateFromJson(System.String)">
            <summary>
            Create the container from json definitions
            </summary>
        </member>
        <member name="M:Sandbox.ClothingContainer.CreateFromLocalUser">
            <summary>
            Create the container from the local user's setup
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsMe">
            <summary>
            Returns true if this friend is the local user
            </summary>
        </member>
        <member name="P:Sandbox.Friend.Id">
            <summary>
            The friend's Steam Id
            </summary>
        </member>
        <member name="P:Sandbox.Friend.Name">
            <summary>
            The friend's name
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsOnline">
            <summary>
            Returns true if your friend is online
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsFriend">
            <summary>
            Returns true if this user is your friend
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsAway">
            <summary>
            Returns true if your friend is away
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsBusy">
            <summary>
            Returns true if this friend is marked as busy
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsSnoozing">
            <summary>
            Returns true if this friend is marked as snoozing
            </summary>
        </member>
        <member name="M:Sandbox.Friend.GetRichPresence(System.String)">
            <summary>
            Returns a string that was possibly set by rich presence
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsPlayingThisGame">
            <summary>
            Returns true if they're playing this game
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsPlayingAGame">
            <summary>
            Returns true if they're playing any game
            </summary>
        </member>
        <member name="M:Sandbox.Friend.OpenInOverlay">
            <summary>
            Opens the Steam overlay web browser to their user profile.
            </summary>
        </member>
        <member name="M:Sandbox.Friend.OpenAddFriendOverlay">
            <summary>
            Opens the Steam overlay with a popup that allows the local Steam user to confirm whether to add this user to their Steam friends list.
            </summary>
        </member>
        <member name="P:Sandbox.Menu.LoadingProgress.Fraction">
            <summary>
            A value between 0 and 1, to show a progress bar
            </summary>
        </member>
        <member name="P:Sandbox.Menu.LoadingProgress.Mbps">
            <summary>
            The current transfer rate in Megabits per second. 0 is none.
            </summary>
        </member>
        <member name="P:Sandbox.Menu.LoadingProgress.Percent">
            <summary>
            Delta multipled by 100
            </summary>
        </member>
        <member name="T:Sandbox.IGameInstance">
            <summary>
            Todo: make internal - the only thing using ir right now is the binds system
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.Id">
            <summary>
            The Id of the element ( id="foo" )
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.SourceFile">
            <summary>
            If the panel created by razor, this is the file in which it was defined
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.SourceLine">
            <summary>
            If the panel was created by razor, this is the line in which it was defined
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.WantsPointerEvents">
            <summary>
            If true then this panel (or its ancestor) has pointer-events: all
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IPanel.SetAbsolutePosition(Sandbox.TextFlag,Vector2,System.Single)">
            <summary>
            Set the panel's absolute position. This wouldn't be needed if we could expose the styles. Which we should
            do.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.PseudoClass">
            <summary>
            Procedural classes such as :hover and :active
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IPanel.ActiveStyleBlocks">
            <summary>
            Get all style blocks active on this panel
            </summary>
        </member>
        <member name="T:Sandbox.Internal.BlockingLoopPumper">
            <summary>
            Sometimes stuff is blocking that doesn't need to be. We want to keep running the main loop
            while the function is blocking. This usually happens with Qt stuff like the drag and drop.
            This should allow the main loop to still be pumped while waiting for that blocking function.
            
            - main game loop
            while ( true )
            {
            	mainloop();
            	
            	BlockingLoopPumper.Run()
            	{
            		runBlockingFunction();
            	}
            }
            
            - somewhere else - usually Qt Timer
            BlockingLoopPumper.Pump();
            {
            	mainloop();
            }
            
            </summary>
        </member>
        <member name="P:Sandbox.Internal.BlockingLoopPumper.PendingFunction">
            <summary>
            Used to call things outside of the main frame
            </summary>
        </member>
        <member name="M:Sandbox.Internal.BlockingLoopPumper.Run(System.Action)">
            <summary>
            Called outside the main game loop.
            </summary>
            <param name="pumper">An action to call the main game loop</param>
        </member>
        <member name="M:Sandbox.Internal.BlockingLoopPumper.Pump">
            <summary>
            Should be called regularly, on the main thread. Generally this is called
            automatically by Qt in the timer (search OnQtHeartbeat).
            This should do total nothing if we're not actually in a blocking loop -  
            because loopPump will be null.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.IMenuSystem">
            <summary>
            This is how the engine communicates with the menu system
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.Init">
            <summary>
            Called to initialize the menu system
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.Shutdown">
            <summary>
            Close down the menu, delete everything
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.Tick">
            <summary>
            Called every frame, to let the menu think
            </summary>
        </member>
        <member name="M:Sandbox.Internal.IMenuSystem.Popup(System.String,System.String,System.String)">
            <summary>
            Show a popup
            </summary>
        </member>
        <member name="P:Sandbox.Internal.IMenuSystem.ForceCursorVisible">
            <summary>
            True if we want to force the cursor to be visible and swallow input.
            This is used for the developer console and loading screens.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.ILoadingInterface">
            <summary>
            Used to talk to the menu's loading screen.
            </summary>
        </member>
        <member name="T:Sandbox.LaunchArguments">
            <summary>
            These are arguments that were set when launching the current game.
            This is used to pre-configure the game from the menu
            </summary>
        </member>
        <member name="P:Sandbox.LaunchArguments.Map">
            <summary>
            The map to start with. It's really up to the game to use this
            </summary>
        </member>
        <member name="M:Sandbox.LaunchArguments.Reset">
            <summary>
            Should be called when leaving a game to set the properties back to default. We need to be
            aware and prevent these leaking between games.
            </summary>
        </member>
        <member name="T:Sandbox.LoadingScreen">
            <summary>
            Holds metadata and raw data relating to a Saved Game.
            </summary>
        </member>
        <member name="T:Sandbox.LobbyManager">
            <summary>
            A class to orchestrate lobbies, globally.
            </summary>
        </member>
        <member name="P:Sandbox.LobbyManager.ActiveLobbies">
            <summary>
            A low level list of lobbies we're in
            </summary>
        </member>
        <member name="M:Sandbox.LobbyManager.OnLeave(System.UInt64)">
            <summary>
            Note there's not a callback for this afaik, so we call this manually
            </summary>
        </member>
        <member name="T:Sandbox.Navigation.NavAgent">
            <summary>
            Internal only to avoid confusion with the component. We can open it up later, if we need to.
            </summary>
        </member>
        <member name="T:Sandbox.Navigation.NavMesh">
            <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
            <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
            <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
            <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
            <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IsEnabled">
            <summary>
            The navigation mesh is generating
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IsGenerating">
            <summary>
            The navigation mesh is generating
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IsDirty">
            <summary>
            The navigation mesh is dirty and needs a complete rebuild
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IncludeStaticBodies">
            <summary>
            Should the generator include static bodies
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IncludeKeyframedBodies">
            <summary>
            Should the generator include keyframed bodies
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.ExcludedBodies">
            <summary>
            Don't include these bodies in the generation
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.IncludedBodies">
            <summary>
            If any, we'll only include bodies with this tag
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.EditorAutoUpdate">
            <summary>
            Constantly update the navigation mesh in the editor
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.DrawMesh">
            <summary>
            Draw the navigation mesh in the editor
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.AgentHeight">
            <summary>
            Height of the agent
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.AgentRadius">
            <summary>
            The radius of the agent. This will change how much gap is left on the edges of surfaces, so they don't clip into walls.
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.AgentStepSize">
            <summary>
            The maximum height an agent can climb (step)
            </summary>
        </member>
        <member name="P:Sandbox.Navigation.NavMesh.AgentMaxSlope">
            <summary>
            The maximum slope an agent can walk up (in degrees)
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.SetDirty">
            <summary>
            Set the navgiation a dirty, so it will rebuild next update
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.GetRandomPoint(BBox)">
            <summary>
            Get a random point on the navmesh, within the bounding box. 
            This will return null if it can't find a point on the navmesh in a few tries. Returning false doesn't mean it's impossible, our algorithm here isn't the best.
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.GetRandomPoint(Vector3,System.Single)">
            <summary>
            Get a random point on the navmesh, within the sphere.
            This will return null if it can't find a point on the navmesh in a few tries. Returning false doesn't mean it's impossible, our algorithm here isn't the best.
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.Serialize">
            <summary>
            Data saved in a Scene file
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.Deserialize(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Data loaded from a Scene file
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.EnumerateTriangles">
            <summary>
            Enumerate the "live" triangles. We cache this off into _triangles on mesh build.
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.EnumerateTriangles(System.Int32)">
            <summary>
            Enumerate the "live" triangles for a specific poly
            </summary>
        </member>
        <member name="M:Sandbox.Navigation.NavMesh.EnumerateTriangles(System.UInt64)">
            <summary>
            Enumerate the "live" triangles for a specific poly
            </summary>
        </member>
        <member name="T:Sandbox.PartyRoom">
            <summary>
            A Party. A Party with your friends.
            </summary>
        </member>
        <member name="P:Sandbox.PartyRoom.Id">
            <summary>
            The unique identifier of this lobby
            </summary>
        </member>
        <member name="P:Sandbox.PartyRoom.VoiceCommunicationAllowed">
            <summary>
            Allow communication via voice when in the main menu.
            </summary>
        </member>
        <member name="M:Sandbox.PartyRoom.OnVoiceRecorded(System.Memory{System.Byte})">
            <summary>
            Voice data has been recieved. Send it to everyone.
            </summary>
        </member>
        <member name="P:Sandbox.PartyRoom.Members">
            <summary>
            A list of members in this room
            </summary>
        </member>
        <member name="M:Sandbox.PartyRoom.SetBroadcastVoice">
            <summary>
            Called each frame that a client wants to broadcast their voice
            </summary>
        </member>
        <member name="T:Sandbox.Preferences">
            <summary>
            Holds information about the current user's preferences.
            </summary>
        </member>
        <member name="P:Sandbox.Preferences.FieldOfView">
            <summary>
            The user's preference for their field of view
            </summary>
        </member>
        <member name="P:Sandbox.Preferences.VoipVolume">
            <summary>
            The user's preferred VOIP volume, as set in the options, clamped between 0 and 1
            </summary>
        </member>
        <member name="P:Sandbox.Preferences.Sensitivity">
            <summary>
            The mouse sensitivity
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.GizmoControls">
            <summary>
            Extendable helper to create common gizmos
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Position(System.String,Vector3,Vector3@,System.Nullable{Rotation},System.Single)">
            <summary>
            A front left up position movement widget. If widget was moved then will return true and out will return the new position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Arrow(System.String,Vector3,System.Single@,System.Single,System.Single,System.Single,System.Single,System.Single,System.String)">
            <summary>
            Draw an arrow - return move delta if interacted with
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.DragSquare(System.String,Vector2,Rotation,Vector3@,System.Action)">
            <summary>
            Manipulate a 2d value by moving on 2 axis
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.PushFixedScale(System.Nullable{System.Single})">
            <summary>
            Scope this before drawing a control to obey Settings.GizmoScale
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Rotate(System.String,Angles@)">
            <summary>
            A full 3d rotation gizmo. If rotated will return true and newValue will be the new value
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.RotateSingle(System.String,Color,System.Single@,System.Single)">
            <summary>
            A single rotation axis
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Scale(System.String,System.Single,System.Single@)">
            <summary>
            A front left up position movement widget. If widget was moved then will return true and out will return the new position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Scale(System.String,Vector3,Vector3@,System.Nullable{Rotation},System.Single)">
            <summary>
            A front left up position movement widget. If widget was moved then will return true and out will return the new position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoControls.Sphere(System.String,System.Single,System.Single@,Color)">
            <summary>
            A scalable sphere gizmo. Returns true if the gizmo was interacted with and outValue will return the new radius.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Control">
            <summary>
            Holds fully realized controls to manipulate some value
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Draw">
            <summary>
            Draw a shape using the gizmo library
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.GizmoDraw">
            <summary>
            Contains functions to add objects to the Gizmo Scene. This
            is an instantiable class so it's possible to add extensions.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.GizmoDraw.Color">
            <summary>
            The color to render the next object
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.GizmoDraw.IgnoreDepth">
            <summary>
            Ignore depth when drawing, draw on top of everything
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.GizmoDraw.LineThickness">
            <summary>
            The thickness of line drawings
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Model(System.String,Transform)">
            <summary>
            Draw a model
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Model(System.String)">
            <summary>
            Draw a model
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Model(Sandbox.Model,Transform)">
            <summary>
            Draw a model
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Model(Sandbox.Model)">
            <summary>
            Draw a model
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Particles(System.String,Transform,System.Nullable{System.Single})">
            <summary>
            Draw particles. Control points will be set to the transform position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Particles(System.String,System.Nullable{System.Single})">
            <summary>
            Draw particles. Control point 0 will be set to the transform position.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Text(System.String,Transform,System.String,System.Single,Sandbox.TextFlag)">
            <summary>
            Draw text
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenText(System.String,Vector2,System.String,System.Single,Sandbox.TextFlag)">
            <summary>
            Draw text
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenRect(Sandbox.Rect,Color,Vector4,Color,Vector4,Sandbox.BlendMode)">
            <summary>
            Draw a rect, on the screen
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenText(System.String,Vector2,Vector2,System.Single,System.String,System.Single,Sandbox.TextFlag)">
            <summary>
            Draw text at an angle
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Plane(Vector3,Vector3)">
            <summary>
            Draw a plane
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Arrow(Vector3,Vector3,System.Single,System.Single)">
            <summary>
            Draw a line with an arrow on the end
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Grid(Sandbox.Gizmo.GridAxis,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws a grid
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Grid(Sandbox.Gizmo.GridAxis,Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Draws a grid
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.AddLineInternal(Sandbox.VertexSceneObject,Vector3@,Vector3@)">
            <summary>
            Adds a line to the current object, but also adds it as a potential hitbox
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Line(Vector3@,Vector3@)">
            <summary>
            Draw a line from a to b
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Line(Line@)">
            <summary>
            Draw a line from a to b
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Lines(System.Collections.Generic.IEnumerable{Line}@)">
            <summary>
            Draw a lines
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineBBox(BBox@)">
            <summary>
            Draw a bounding box
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineFrustum(Sandbox.Frustum@)">
            <summary>
            Draws a frustum.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineSphere(Vector3@,System.Single@,System.Int32@)">
            <summary>
            Draw a sphere made out of lines
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineSphere(Sandbox.Sphere@,System.Int32)">
            <summary>
            Draw a sphere made out of lines
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineCircle(Vector3@,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draw a sphere made out of lines
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineCylinder(Vector3,Vector3,System.Single,System.Single,System.Int32)">
            <summary>
            A cylinder
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineTriangle(Sandbox.Triangle@)">
            <summary>
            A triangle
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.LineTriangles(System.Collections.Generic.IEnumerable{Sandbox.Triangle}@)">
            <summary>
            Multiple triangles
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCone(Vector3,Vector3,System.Single,System.Nullable{System.Int32})">
            <summary>
            Draw a solid cone shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidBox(BBox)">
            <summary>
            Draw a solid box shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidTriangle(Sandbox.Triangle@)">
            <summary>
            Draw a solid triangle shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidTriangle(Vector3@,Vector3@,Vector3@)">
            <summary>
            Draw a solid triangle shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidTriangles(System.Collections.Generic.IEnumerable{Sandbox.Triangle}@)">
            <summary>
            Multiple solid triangles
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCircle(Vector3,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draw a filled circle
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidRing(Vector3,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draw a filled ring
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidSphere(Vector3,System.Single,System.Int32,System.Int32)">
            <summary>
            Draw a solid sphere shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCylinder(Vector3,Vector3,System.Single,System.Int32)">
            <summary>
            Draw a solid cylinder shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCapsule(Vector3,Vector3,System.Single,System.Int32,System.Int32)">
            <summary>
            Draw a solid capsule shape
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenBiasedHalfCircle(Vector3,System.Single)">
            <summary>
            Draws a half circle that tries its best to point towards the camera. This is used by
            the rotation widgets that bias towards the camera.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Sprite(Vector3,System.Single,Sandbox.Texture)">
            <summary>
            Draw a sprite. This is horrible right now because it doesn't seem like we can load png textures from disk!?!?
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoDraw.Sprite(Vector3,Vector2,Sandbox.Texture,System.Boolean)">
            <summary>
            Draw a sprite. This is horrible right now because it doesn't seem like we can load png textures from disk!?!?
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.Colors">
            <summary>
            Using pure primary colors is horrible. Lets make it easier to avoid.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Scope(System.String,Transform)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Scope(System.String,Vector3)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Scope(System.String,Vector3,Rotation,System.Single)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Scope(System.String)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.ObjectScope``1(``0,Transform)">
            <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetPositionOnPlane(Vector3,Vector3,Ray)">
            <summary>
            Get the distance from a point on a plane
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetMouseDelta(Vector3,Vector3)">
            <summary>
            Get the mouse delta at this current position
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetMouseDrag(Vector3,Vector3)">
            <summary>
            Get the mouse drag distance at this current position, assuming we are pressed
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetMouseDistance(Vector3,Vector3)">
            <summary>
            Get the distance from a point on a plane
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GetMouseDistanceDelta(Vector3,Vector3)">
            <summary>
            Get the distance moved from (or towards) a position on a plane
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.CursorPosition">
            <summary>
            The current cursor position, in screen space
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.CursorMoveDelta">
            <summary>
            The delta of cursor movement between this frame and last, in screen space
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.CursorDragDelta">
            <summary>
            The delta of cursor movement between last press and now, in screen space.
            If left mouse isn't down, will return CursorMoveDelta
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.KeyboardModifiers">
            <summary>
            The current keyboard modifiers
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Snap(Vector3,Vector3)">
            <summary>
            Will snap this position, depending on the current snap settings and keys that are pressed.
            Will snap along if movement is detected along that axis. For example, if movement is 1,0,0 then we'll
            only snap on the x axis.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Snap(Angles,Angles)">
            <summary>
            Will snap this position, depending on the current snap settings and keys that are pressed.
            Will snap along if movement is detected along that axis. For example, if movement is 1,0,0 then we'll
            only snap on the x axis.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Nudge(Rotation,Vector2)">
            <summary>
            Will give you a nudge vector along the most aligned left and up axis of the rotation
            based on left/right/up/down direction and camera angle
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.CameraTransform">
            <summary>
            The cameras transform - in world space
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.LocalCameraTransform">
            <summary>
            The cameras transform - in local space
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.Inputs">
            <summary>
            The input state, allows interaction with Gizmos
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Inputs.IsHovered">
            <summary>
            True if the scene is being hovered by the mouse. False if the cursor is being used somewhere else
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.Instance">
            <summary>
            Holds the backend state for a Gizmo scope. This allows us to have multiple different gizmo
            states (for multiple views, multiple windows, game and editor) and push them as the current
            active state whenever needed.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Debug">
            <summary>
            If true, we'll draw some debug information
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.DebugHitboxes">
            <summary>
            If true we'll enable hitbox debugging
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.World">
            <summary>
            The SceneWorld this instance is writing to. This world exists only for this instance.
            You need to add this world to your camera for it to render (!)
            </summary>
        </member>
        <member name="F:Sandbox.Gizmo.Instance.Input">
            <summary>
            Input state. Should be setup before push.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.PreviousInput">
            <summary>
            The previous input state
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Pool">
            <summary>
            Last frame's objects that are available for reuse
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Entries">
            <summary>
            This frame's created (or re-used) objects
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Selection">
            <summary>
            This frame's created (or re-used) objects
            </summary>
        </member>
        <member name="F:Sandbox.Gizmo.Instance.scope">
            <summary>
            When a new scope is pushed, we store the old one and copy it to this.
            When it's disposed we restore this to the old one. This is the currently
            active scope.
            </summary>
        </member>
        <member name="F:Sandbox.Gizmo.Instance.lineScope">
            <summary>
            Holds the current hitbox line scope status
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.ControlMode">
            <summary>
            The current control mode. This is generally implementation specific. 
            We tend to use "mouse" and "firstperson".
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.Settings">
            <summary>
            Some global settings accessible to the gizmos. Your implementation
            generally lets your users set up  these things to their preference, 
            and the gizmos should try to obey them.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.GetValue``1(System.String)">
            <summary>
            Generic storage for whatever you want to do. 
            You're responsible for not spamming into this and cleaning up after yourself.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.SetValue``1(System.String,``0)">
            <summary>
            Generic storage for whatever you want to do. 
            You're responsible for not spamming into this and cleaning up after yourself.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.Clear">
            <summary>
            Called when the scene changes and we don't want to inherit a bunch of values.
            We might want to just target some specific values here instead of clearing the log.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Instance.LoopMilliseconds">
            <summary>
            how long the previous loop took, in milliseconds
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.Dispose">
            <summary>
            Destroy this instance, clean up any created resources/scene objects, destroy the world.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.Push">
            <summary>
            Push this instance as the global Gizmo state. All Gizmo calls during this scope
            will use this instance.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.Start">
            <summary>
            Called at the start of a 'frame'
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.End">
            <summary>
            Called at the end of a 'frame'
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.FindOrCreate``1(System.String,System.Func{``0})">
            <summary>
            Find a cached version of this sceneobject - if not found, create one
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.Instance.StompCursorPosition(Vector2)">
            <summary>
            Set all of the state's cursor positions to this value. This stomps previous values
            which will effectively clear any deltas. This should be used prior to starting a loop.
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.Pressed">
            <summary>
            Access to the currently pressed path information
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.Ray">
            <summary>
            The ray representing the cursor direction
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.This">
            <summary>
            True if the current gizmo scope is pressed
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.Any">
            <summary>
            True if any object is currently pressed
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.CursorDelta">
            <summary>
            The distance the cursor has travelled since press started
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.CursorPosition">
            <summary>
            The cursor position at the start of the press
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Pressed.IsActive">
            <summary>
            True if press is active. This generally means that the left mouse button is down
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.EditMode">
            <summary>
            How do we want to edit this? Usually something like "position", "rotation", "scale" etc
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.Selection">
            <summary>
            Do we want to let the user select things in the current mode?
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.ViewMode">
            <summary>
            What is the current view mode? 3d, 2d, ui?
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.GizmosEnabled">
            <summary>
            Are gizmos enabled?
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.GizmoScale">
            <summary>
            How big to show the gizmos
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.GridSpacing">
            <summary>
            Grid spacing
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.SnapToGrid">
            <summary>
            Snap positions to the grid
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.SnapToAngles">
            <summary>
            Snap angles
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.AngleSpacing">
            <summary>
            Grid spacing
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.GlobalSpace">
            <summary>
            Editing in local space
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.SceneSettings.DebugActionGraphs">
            <summary>
            Should we show lines representing GameObject references in action graphs?
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.ScopeState">
            <summary>
            Whenever Gizmo.State is called, this is copied, stored and restored. This
            should hold whatever data is important to reset at the end of a scope. We
            should be really careful not to fill this with too much shit.
            </summary>
        </member>
        <member name="P:Sandbox.Gizmo.Hitbox">
            <summary>
            Allows creating a gizmo hitbox which will be interactable using the mouse (or vr deck2 super controller)
            </summary>
        </member>
        <member name="T:Sandbox.Gizmo.GizmoHitbox">
            <summary>
            Contains functions to add objects to the immediate mode Scene. This
            is an instantiable class so it's possible to add extensions.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.TrySetHovered(System.Single)">
            <summary>
            If this distance is closer than our previous best, this path will become the hovered path
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.TrySetHovered(Vector3)">
            <summary>
            If this distance is closer than our previous best, this path will become the hovered path
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.Sphere(Sandbox.Sphere)">
            <summary>
            A sphere hitbox
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.BBox(BBox)">
            <summary>
            A bounding box hitbox
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.Circle(Vector3,Vector3,System.Single,System.Single)">
            <summary>
            A 2d circle hitbox, on a plane
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.Model(Sandbox.Model)">
            <summary>
            A model hitbox
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.LineScope">
            <summary>
            Start a line scope. Any drawn lines should become a hitbox during this scope.
            </summary>
        </member>
        <member name="M:Sandbox.Gizmo.GizmoHitbox.AddPotentialLine(Vector3@,Vector3@,System.Single)">
            <summary>
            If we're in a hitbox linescope we'll distance this test vs the current ray. If
            not, we'll return immediately.
            This is automatically called when rendering lines
            </summary>
        </member>
        <member name="T:Sandbox.GizmoInlineSceneObject">
            <summary>
            Draws anything
            </summary>
        </member>
        <member name="T:Sandbox.TextSceneObject">
            <summary>
            Draws text in screenspace
            </summary>
        </member>
        <member name="T:Sandbox.VertexSceneObject">
            <summary>
            Draws a vertex object. Lines or solids usually.
            </summary>
        </member>
        <member name="T:Sandbox.ModelArchetype">
            <summary>
            Default model archetypes.
            These types are defined in "tools/model_archetypes.txt".
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.static_prop_model">
            <summary>
            A static model. It can still have collisions, but they do not have physics.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.animated_model">
            <summary>
            Animated model. Typically no physics.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.physics_prop_model">
            <summary>
            A generic physics enabled model.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.jointed_physics_model">
            <summary>
            A ragdoll type model.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.breakable_prop_model">
            <summary>
            A physics model that can be broken into other physics models.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.generic_actor_model">
            <summary>
            A generic actor/NPC model.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.Internal.BaseModelDocAttribute.AddTransform(System.Text.StringBuilder)">
            <summary>
            Internal, used to add multi level key-values.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.Internal.BaseModelDocAttribute.AddKeys(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Add generic key-values to the helper.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Bone">
            <summary>
            Internal name of the key that dictates which bone to use as parent for position/angles.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Attachment">
            <summary>
            Internal name of the key that dictates which attachment to use as parent for position/angles.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Origin">
            <summary>
            Internal name of the key to store position in, if set, allows the helper to be moved.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Angles">
            <summary>
            Internal name of the key to store angles in, allows the helper to be rotated.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.GameDataAttribute">
            <summary>
            Indicates that this class/struct should be available as GenericGameData node in ModelDoc
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.GameDataAttribute.AllowMultiple">
            <summary>
            Indicates that this type compiles as list, rather than a single entry in the model.
            This will also affect how you retrieve this data via Model.GetData().
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.AxisAttribute">
            <summary>
            Draws 3 line axis visualization, which can set up to be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.AxisAttribute.Enabled">
            <summary>
            Internal name of a boolean key that dictates whether this helper should draw or not. If unset, will draw always.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.AxisAttribute.ParentLine">
            <summary>
            If set to true, when the node is selected a line will be drawn from the helper to the parent attachment/bone.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.BoxAttribute">
            <summary>
            Draws a box, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.BoxAttribute.HideSurface">
            <summary>
            If set, the semi-transparent box "walls" will not be drawn.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.BoxAttribute.ShowGizmos">
            <summary>
            If set, gizmos will be shown in transform mode to quickly move/scale the box.
            For "dimensions" box Origin/Angles must be set.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.BoxAttribute.#ctor(System.String)">
            <summary>
            Store the box's dimensions in a single key, acting as (maxs-mins) which assumes the box's center is at the models origin.
            The box's center can be set up to be movable via "Origin" property and rotatable via "Angles" property.
            </summary>
            <param name="dimensionsKey">Internal name of a key on the node that will store the dimensions of the box.</param>
        </member>
        <member name="M:Sandbox.ModelEditor.BoxAttribute.#ctor(System.String,System.String)">
            <summary>
            Store the box's dimensions in 2 keys as Mins and Maxs. This type cannot be rotated.
            </summary>
            <param name="minsKey">Internal name of a key on the node that will store the mins of the box.</param>
            <param name="maxsKey">Internal name of a key on the node that will store the maxs of the box.</param>
        </member>
        <member name="T:Sandbox.ModelEditor.SphereAttribute">
            <summary>
            Draws a sphere, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.SphereAttribute.HideSurface">
            <summary>
            If set, the semi-transparent sphere "wall"/surface will not be drawn.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.CapsuleAttribute">
            <summary>
            Draws a capsule, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.CapsuleAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            This variation has 1 radius for both points.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.CapsuleAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            This variation has independent radius for each point.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.CylinderAttribute">
            <summary>
            Draws a cylinder, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.CylinderAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            This variation has 1 radius for both points.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.CylinderAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            This variation has independent radius for each point.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.HingeJointAttribute">
            <summary>
            A helper that draws axis of rotation and angle limit of a hinge joint.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HingeJointAttribute.EnableLimit">
            <summary>
            Key name that dictates whether the hinge limit is enabled or not.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HingeJointAttribute.MinAngle">
            <summary>
            Key name that stores the minimum angle value for the revolute joint.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HingeJointAttribute.MaxAngle">
            <summary>
            Key name that stores the maximum angle value for the revolute joint.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.EditorWidgetAttribute">
            <summary>
            Adds a custom editor widget to the game data node.
            Currently only 1 option is available - "HandPosePairEditor"
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.HandPoseAttribute">
            <summary>
            A helper used for VR hand purposes.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Origin">
            <summary>
            Internal name of the key to store position in.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Angles">
            <summary>
            Internal name of the key to store angles in.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Model">
            <summary>
            Path to a model to use.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.IsRightHand">
            <summary>
            Whether this helper represents the right hand or not.
            This decides the names of the bones the helper will try to use.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Label">
            <summary>
            Text label this helper will have when hovered/selected.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Enabled">
            <summary>
            Internal name of the key that controls whether this helper is visible or not.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEditor.HandPoseAttribute.#ctor(System.String,System.String,System.String,System.Boolean)">
            <param name="originKey">Internal name of the key to store position in.</param>
            <param name="anglesKey">Internal name of the key to store angles in.</param>
            <param name="model">Path to a model to use.</param>
            <param name="isRightHand">Whether this helper represents the right hand or not. This decides the names of the bones the helper will try to use.</param>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.BoneFrom">
            <summary>
            Internal name of the key that dictates which bone to use as parent for start position.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.AttachmentFrom">
            <summary>
            Internal name of the key that dictates which attachment to use as parent for start position.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.OriginFrom">
            <summary>
            Internal name of the key to read line start position from.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.BoneTo">
            <summary>
            Internal name of the key that dictates which bone to use as parent for end position.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.AttachmentTo">
            <summary>
            Internal name of the key that dictates which attachment to use as parent for end position.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.OriginTo">
            <summary>
            Internal name of the key to read line end position from.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.Enabled">
            <summary>
            Internal name of the key that controls whether this helper is visible or not.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.Color">
            <summary>
            A string formatted color for this helper. Format is "255 255 255"
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.LineAttribute.Width">
            <summary>
            The width of the line helper
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.ScaleBoneRelativeAttribute">
            <summary>
            Scales the vector with the "ScaleAndMirror" node, relative to associated bone.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.ScaleWorldAttribute">
            <summary>
            Scales the vector with the "ScaleAndMirror" node.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelBreakPiece">
            <summary>
            Defines a single breakable prop gib.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelPropData">
            <summary>
            Generic prop settings. Support for this depends on the entity.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.BakeLighting">
            <summary>
            When this model is used as prop_static, it will bake lighting by default depending on this value.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.Health">
            <summary>
            When this model is used as prop_physics, it's health will be set to this value.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior">
            <summary>
            Defines the model as explosive. Support for this depends on the entity.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Sound">
            <summary>
            Sound override for when the prop explodes.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Effect">
            <summary>
            Particle effect override for when the problem explodes.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Damage">
            <summary>
            Amount of damage to do at the center on the explosion. It will falloff over distance.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Radius">
            <summary>
            Range of explosion's damage.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Force">
            <summary>
            Scale of the force applied to entities damaged by the explosion and the models break pieces.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelCapsuleAOProxy">
            <summary>
            Capsule Ambient Occlusion Proxy. Used internally by the engine for AO and reflections.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelCylinderAOProxy">
            <summary>
            Cylinder Ambient Occlusion Proxy. Used internally by the engine for AO and reflections.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelSphereAOProxy">
            <summary>
            Sphere Ambient Occlusion Proxy. Used internally by the engine for AO and reflections.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelBoxAOProxy">
            <summary>
            Box Ambient Occlusion Proxy. Used internally by the engine for AO and reflections.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelEye">
            <summary>
            Defines an eye on a character model.
            </summary>
        </member>
        <member name="T:Sandbox.ModelEditor.Nodes.ModelNavData">
            <summary>
            Carries navigation related data.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEditor.Nodes.ModelNavData.Avoid">
            <summary>
            During map compile this model would mark its volume as an area that should be avoided by AI.
            </summary>
        </member>
        <member name="T:Sandbox.AutoGenerateAttribute">
            <summary>
            Indicates that this type should generate meta data. Tagging your asset with this will
            mean that the .asset file is automatically generated - which means you don't have to do that.
            </summary>
        </member>
        <member name="T:Sandbox.FGDTypeAttribute">
            <summary>
            Overrides the auto generated FGD type.
            </summary>
        </member>
        <member name="M:Sandbox.FGDTypeAttribute.#ctor(System.String,System.String,System.String)">
            <param name="type">The FGD type override.</param>
            <param name="editor">The name of a custom editor to use for this property.</param>
            <param name="editorArgs">Arguments for given editor override. Format depends on each editor.</param>
        </member>
        <member name="T:Sandbox.ResourceTypeAttribute">
            <summary>
            Allows you to specify a string property as a resource type. This will
            give the property a resource finder. Type should be the file extension, ie "vmdl"
            </summary>
        </member>
        <member name="T:Sandbox.BitFlagsAttribute">
            <summary>
            This choices type is bitflags, so we should be able to choose more than one option at a time.
            </summary>
            <remarks>
            TODO: Once this is no longer used in assets it can be deleted.
                  It should be derived from [System.Flags]
            </remarks>
        </member>
        <member name="T:Sandbox.AssetPathAttribute">
            <summary>
            When added to a string property, will becomes a selector for AssetTypeExtension
            </summary>
        </member>
        <member name="T:Sandbox.ImageAssetPathAttribute">
            <summary>
            When added to a string property, will become an image string selector
            </summary>
        </member>
        <member name="T:Sandbox.MapAssetPathAttribute">
            <summary>
            When added to a string property, will become a map string selector
            </summary>
        </member>
        <member name="F:Sandbox.HotloadManager.PerTypeAssertThresholdMillis">
            <summary>
            Assert if any one type takes more than this duration to process, AND more than
            <see cref="F:Sandbox.HotloadManager.PerTypeAssertThresholdFraction"/> of the total time.
            </summary>
        </member>
        <member name="F:Sandbox.HotloadManager.PerTypeAssertThresholdFraction">
            <summary>
            Assert if any one type takes more than this fraction of the total time to process,
            AND more than <see cref="F:Sandbox.HotloadManager.PerTypeAssertThresholdMillis"/>.
            </summary>
        </member>
        <member name="M:Sandbox.HotloadManager.DoSwap">
            <summary>
            Does the actual hotload
            </summary>
        </member>
        <member name="M:Sandbox.HotloadManager.Replace(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            Lets the hotload system know that something has changed. If we detect that we are
            replacing a dll (instead of just adding one) we'll queue up a swap. We should still
            call this even if <paramref name="oldAssembly"/> or <paramref name="newAssembly"/>
            is null, since that will tell the hotload system to start / stop watching static
            members of the assembly.
            </summary>
        </member>
        <member name="M:Sandbox.ConfigData.OnValidate">
            <summary>
            Called after deserialization, and before serialization. A place to error check and make sure everything is fine.
            </summary>
        </member>
        <member name="P:Sandbox.Controller.Gyroscope">
            <summary>
            Gets a sensor reading from the device's gyroscope (if it has one)
            </summary>
        </member>
        <member name="P:Sandbox.Controller.Accelerometer">
            <summary>
            Gets a sensor reading from the device's accelerometer (if it has one)
            </summary>
        </member>
        <member name="P:Sandbox.Controller.InstanceId">
            <summary>
            Gets the instance ID for this controller.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sandbox.Controller.IsConnected">
            <summary>
            Is this controller connected right now? (It could've been disconnected at some point)
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sandbox.Controller.LEDColor">
            <summary>
            Sets the color of the gamepad if supported
            </summary>
        </member>
        <member name="P:Sandbox.Controller.ControllerType">
            <summary>
            What type of controller is this?
            </summary>
        </member>
        <member name="P:Sandbox.Controller.GlyphVendor">
            <summary>
            Which glyph vendor are we using for this controller?
            - default "The default vendor type, which uses Xbox glyphs"
            - playstation
            - switch 
            </summary>
        </member>
        <member name="M:Sandbox.Controller.Rumble(System.Int32,System.Int32,System.Int32)">
            <summary>
            Rumbles the controller.
            </summary>
            <param name="leftMotor">The speed of the left motor, between 0 and 0xFFFF</param>
            <param name="rightMotor">The speed of the right motor, between 0 and 0xFFFF</param>
            <param name="duration">The duration of the vibration in ms</param>
        </member>
        <member name="M:Sandbox.Controller.RumbleTriggers(System.Int32,System.Int32,System.Int32)">
            <summary>
            Rumbles the controller's triggers (if supported)
            </summary>
            <param name="leftTrigger">The speed of the left trigger motor, between 0 and 0xFFFF</param>
            <param name="rightTrigger">The speed of the right trigger motor, between 0 and 0xFFFF</param>
            <param name="duration">The duration of the vibration in ms</param>
        </member>
        <member name="M:Sandbox.Controller.StopAllHaptics">
            <summary>
            Stops all rumble and haptic events on this controller.
            </summary>
        </member>
        <member name="M:Sandbox.Controller.StopAllVibrations">
            <summary>
            Stop all vibration events on this controller.
            </summary>
        </member>
        <member name="M:Sandbox.Controller.TriggerHapticEffect(Sandbox.HapticEffect,System.Single,System.Single,System.Single)">
            <summary>
            Trigger a vibration based on a predefined <see cref="T:Sandbox.HapticPattern"/>.
            All <see cref="T:Sandbox.HapticPattern"/>s are normalized (start at 0, peak at 1).
            </summary>
            <param name="effect">The pattern to use</param>
            <param name="lengthScale">The amount to scale the pattern's length by.</param>
            <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
            <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
        </member>
        <member name="P:Sandbox.Controller.All">
            <summary>
            A list of all of the controllers, active and inactive.
            </summary>
        </member>
        <member name="P:Sandbox.Controller.First">
            <summary>
            Get the first controller that's connected (shortcut)
            </summary>
        </member>
        <member name="P:Sandbox.Controller.InputContext">
            <summary>
            The input context for this controller.
            </summary>
        </member>
        <member name="F:Sandbox.Controller.AXIS_RANGE">
            SDL reports values between this range
        </member>
        <member name="M:Sandbox.Controller.GetAxis(NativeEngine.GameControllerAxis,System.Single)">
            <summary>
            Get an axis
            </summary>
            <param name="axis"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="T:Sandbox.Controller.InputAxis">
            <summary>
            An axis
            </summary>
        </member>
        <member name="T:Sandbox.Input">
            <summary>
            Allows querying of player button presses and other inputs.
            </summary>
        </member>
        <member name="P:Sandbox.Input.CurrentPlayerScope">
            <summary>
            What's our current player index (for input scoping)?
            -1 is the default behavior, where it'll accept keyboard AND gamepad inputs.
            Anything above that, is targeting a specific controller.
            </summary>
        </member>
        <member name="P:Sandbox.Input.ControllerCount">
            <summary>
            How many controllers are active right now?
            </summary>
        </member>
        <member name="P:Sandbox.Input.CurrentController">
            <summary>
            Tries to find the current controller to use.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetAnalog(Sandbox.InputAnalog)">
            <summary>
            An analog input, when fetched, is between -1 and 1 (0 being default)
            </summary>
        </member>
        <member name="M:Sandbox.Input.ProcessControllerInput(System.Int32)">
            <summary>
            Processes controller inputs based on a player index (for input scoping). This can be called many times a frame.
            </summary>
        </member>
        <member name="M:Sandbox.Input.PlayerScope(System.Int32)">
            <summary>
            Push a specific player scope to be active
            </summary>
        </member>
        <member name="P:Sandbox.Input.UsingController">
            <summary>
            Was the last button pressed a game controller button?
            </summary>
        </member>
        <member name="P:Sandbox.Input.MissingActions">
            <summary>
            Missing action names that we've warned about already.
            This gets cleared when actions are initialized again.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetActionIndex(System.String)">
            <summary>
            We pack actions bit-by-bit in CUserCmd, using the index (which is shared between realms) to map it to an action.
            This is an accessor to grab that index easily from its action.
            </summary>
            <param name="actionName"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Input.GetActionIndex(Sandbox.InputAction)">
            <inheritdoc cref="M:Sandbox.Input.GetActionIndex(System.String)"/>
        </member>
        <member name="P:Sandbox.Input.EscapePressed">
            <summary>
            True if escape was pressed
            </summary>
        </member>
        <member name="M:Sandbox.Input.Down(System.String,System.Boolean)">
            <summary>
            Action is currently pressed down
            </summary>
        </member>
        <member name="M:Sandbox.Input.Pressed(System.String)">
            <summary>
            Action wasn't pressed but now it is
            </summary>
        </member>
        <member name="M:Sandbox.Input.Released(System.String)">
            <summary>
            Action was pressed but now it isn't
            </summary>
        </member>
        <member name="M:Sandbox.Input.SetAction(Sandbox.InputAction,System.Boolean)">
            <inheritdoc cref="M:Sandbox.Input.SetAction(System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Input.SetAction(System.String,System.Boolean)">
            <inheritdoc cref="M:Sandbox.Input.SetAction(System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Input.Clear(System.String)">
            <summary>
            Remove this action, so it's no longer being pressed.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Sandbox.Input.ClearActions">
            <summary>
            Clears the current input actions, so that none of them are active.
            </summary>
        </member>
        <member name="M:Sandbox.Input.ReleaseActions">
            <summary>
            Clears the current input actions, so that none of them are active. Unlike ClearActions
            this will unpress the buttons, so they won't be active again until they're pressed again.
            </summary>
        </member>
        <member name="M:Sandbox.Input.ReleaseAction(System.String)">
            <summary>
            Releases the action, and it won't be active again until it's pressed again.
            </summary>
        </member>
        <member name="M:Sandbox.Input.SetAction(System.Int32,System.Boolean)">
            <summary>
            Activates / Deactivates an action when building input.
            </summary>
            <param name="index"></param>
            <param name="down"></param>
        </member>
        <member name="M:Sandbox.Input.OnButton(NativeEngine.ButtonCode,System.String,System.Boolean)">
            <summary>
            Called when a compatible button is pressed.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetActions">
            <summary>
            Copies all input actions to be used publicly
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sandbox.Input.ActionNames">
            <summary>
            Names of all actions from the current game's input settings.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetGroupName(System.String)">
            <summary>
            Finds the <see cref="P:Sandbox.InputAction.GroupName"/> of the given action.
            </summary>
            <param name="action">Action name to find the group name of.</param>
        </member>
        <member name="M:Sandbox.Input.ReadConfig(Sandbox.InputSettings)">
            <summary>
            Read the config from this source
            </summary>
        </member>
        <member name="P:Sandbox.Input.CurrentContext">
            <summary>
            The current input context, pushed using Context.Push
            </summary>
        </member>
        <member name="P:Sandbox.Input.Contexts">
            <summary>
            Get all of the contexts
            </summary>
        </member>
        <member name="T:Sandbox.Input.Context">
            <summary>
            Allows tracking states of button changes and input deltas in a custom period (such as a tick) rather
            than in a per frame manner. This allows frame and tick to have legit data.
            </summary>
        </member>
        <member name="M:Sandbox.Input.Context.Flip">
            <summary>
            Copy accumulated values. Flip previous actions to current actions etc.
            </summary>
        </member>
        <member name="M:Sandbox.Input.Context.Push">
            <summary>
            Make this the current active context. You can optionally use the returned
            IDisposable to restore back to the previous context when you're done.
            </summary>
        </member>
        <member name="P:Sandbox.Input.VR">
            <summary>
            Virtual Reality specific input data.
            </summary>
        </member>
        <member name="P:Sandbox.Input.MouseDelta">
            <summary>
            Movement delta from the mouse.
            </summary>
        </member>
        <member name="P:Sandbox.Input.MouseWheel">
            <summary>
            The state of the mouse wheel.
            </summary>
        </member>
        <member name="P:Sandbox.Input.MouseCursorVisible">
            <summary>
            True if the mouse cursor is visible (using UI etc)
            </summary>
        </member>
        <member name="P:Sandbox.Input.AnalogLook">
            <summary>
            Analog look value from the default input device. This is scaled by Preferences.Sensitivity - so you don't need to scale it afterwards.
            </summary>
        </member>
        <member name="P:Sandbox.Input.AnalogMove">
            <summary>
            Analog move value from the default input device.
            </summary>
        </member>
        <member name="M:Sandbox.Input.Process(System.Single)">
            <summary>
            Called multiple times between ticks.
            </summary>
        </member>
        <member name="P:Sandbox.Input.MotionData">
            <summary>
            Current state of the current input device's motion sensor(s) if supported.
            This is only supported on: Dualshock 4+, Switch Controllers, Steam Controller, Steam Deck.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetButtonOrigin(Sandbox.InputAction,System.Boolean)">
            <inheritdoc cref="M:Sandbox.Input.GetButtonOrigin(System.String,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Input.GetButtonOrigin(System.String,System.Boolean)">
            <summary>
            Returns the name of a key bound to this InputAction
            <example>For example:
            <code>Input.GetButtonOrigin( "Undo" )</code>
            could return <c>SPACE</c> if using keyboard or <c>A Button</c> when using a controller.
            </example>
            </summary>
        </member>
        <member name="M:Sandbox.Input.LoadGlyphTexture(System.String,Sandbox.InputGlyphSize,System.Boolean)">
            <summary>
            Tries to load a glyph texture, will seek the current vendor controller (Xbox, PlayStation, Nintendo) and fall back to Xbox if not found.
            </summary>
            <param name="file"></param>
            <param name="size"></param>
            <param name="outline"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Input.GetButtonName(System.String)">
            <summary>
            Some keys can't be parsed by files because they're symbols, so we change them into something readable
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Input.GetGlyph(System.String,Sandbox.InputGlyphSize,System.Boolean)">
            <summary>
            Get a glyph texture from the controller bound to the action.
            If no binding is found will return an 'UNBOUND' glyph.
            </summary>
            <remarks>You should update your UI with this every frame, it's very cheap to call and context can change.</remarks>
        </member>
        <member name="M:Sandbox.Input.GetGlyph(System.String,Sandbox.InputGlyphSize,Sandbox.GlyphStyle)">
            <inheritdoc cref="M:Sandbox.Input.GetGlyph(System.String,Sandbox.InputGlyphSize,System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Input.GetGlyph(Sandbox.InputAnalog,Sandbox.InputGlyphSize,System.Boolean)">
            <summary>
            Get a glyph texture from an analog input on a controller.
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetButtonOrigin(Sandbox.InputAnalog)">
            <summary>
            Returns the name of the analog axis bound to this <see cref="T:Sandbox.InputAnalog"/>.
            <example>For example:
            <code>Input.GetButtonOrigin( InputAnalog.Move )</code>
            could return <c>Left Joystick</c>
            </example>
            </summary>
        </member>
        <member name="M:Sandbox.Input.TriggerHaptics(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Trigger a haptic event on supported controllers including Xbox trigger impulse rumble.
            </summary>
            <remarks>
            SDL will translate these commands into haptic pulses that should work on all controller types.
            </remarks>
            <param name="leftMotor">The speed of the left motor, between 0.0 and 1.0.</param>
            <param name="rightMotor">The speed of the right motor, between 0.0 and 1.0.</param>
            <param name="leftTrigger">(Xbox One controller only) The speed of the left trigger motor, between 0.0 and 1.0.</param>
            <param name="rightTrigger">(Xbox One controller only) The speed of the right trigger motor, between 0.0 and 1.0.</param>
            <param name="duration">How long (in milliseconds) should we apply this for?</param>
        </member>
        <member name="M:Sandbox.Input.TriggerHaptics(Sandbox.HapticEffect,System.Single,System.Single,System.Single)">
            <summary>
            Trigger haptics based on a predefined <see cref="T:Sandbox.HapticEffect"/>.
            All <see cref="T:Sandbox.HapticEffect"/>s are normalized (start at 0, peak at 1).
            </summary>
            <param name="pattern">The pattern to use</param>
            <param name="lengthScale">The amount to scale the pattern's length by.</param>
            <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
            <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
        </member>
        <member name="M:Sandbox.Input.TriggerHaptics(Sandbox.HapticEffect,System.Single,System.Single)">
            <summary>
            Trigger haptics based on a predefined <see cref="T:Sandbox.HapticEffect"/>.
            All <see cref="T:Sandbox.HapticEffect"/>s are normalized (start at 0, peak at 1).
            </summary>
            <param name="pattern">The pattern to use</param>
            <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
            <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
        </member>
        <member name="M:Sandbox.Input.StopAllHaptics">
            <summary>
            Stop all vibration events on the current controller.
            </summary>
        </member>
        <member name="T:Sandbox.InputAnalog">
            <summary>
            An analog input, when fetched, is between -1 and 1 (0 being default)
            </summary>
        </member>
        <member name="T:Sandbox.InputMotionData">
            <summary>
            Represents the current state of a device's motion sensor(s).
            </summary>
        </member>
        <member name="F:Sandbox.InputMotionData.Gyroscope">
            <summary>
            The raw value from the input device's gyroscope.
            </summary>
        </member>
        <member name="F:Sandbox.InputMotionData.Accelerometer">
            <summary>
            The raw value from the input device's accelerometer.
            </summary>
        </member>
        <member name="T:Sandbox.HapticEffect">
            <summary>
            Contains a haptic effect, which consists of patterns for the controller and triggers.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.SoftImpact">
            <summary>
            A haptic pattern that represents a light, soft impact.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.HardImpact">
            <summary>
            A haptic pattern that represents a hard, sudden impact.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.Rumble">
            <summary>
            Applies a simple rumble to the controller.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.RumbleLeftTrigger">
            <summary>
            Applies a simple rumble to the left trigger.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.RumbleRightTrigger">
            <summary>
            Applies a simple rumble to the right trigger.
            </summary>
        </member>
        <member name="P:Sandbox.HapticEffect.Heartbeat">
            <summary>
            A haptic effect that feels like a heartbeat.
            </summary>
        </member>
        <member name="T:Sandbox.HapticPattern">
            <summary>
            Contains a haptic pattern, which consists of frequency and amplitude values that can change over time.
            </summary>
        </member>
        <member name="M:Sandbox.HapticPattern.#ctor(System.Single,Sandbox.Curve,Sandbox.Curve)">
            <summary>
            Contains a haptic pattern, which consists of frequency and amplitude values that can change over time.
            </summary>
        </member>
        <member name="P:Sandbox.HapticPattern.SoftImpact">
            <summary>
            A haptic pattern that represents a light, soft impact.
            </summary>
        </member>
        <member name="P:Sandbox.HapticPattern.HardImpact">
            <summary>
            A haptic pattern that represents a hard, sudden impact.
            </summary>
        </member>
        <member name="P:Sandbox.HapticPattern.Rumble">
            <summary>
            A haptic pattern that represents a constant low-frequency rumble.
            </summary>
        </member>
        <member name="P:Sandbox.HapticPattern.Heartbeat">
            <summary>
            A haptic pattern that feels like a heartbeat.
            </summary>
        </member>
        <member name="T:Sandbox.HapticTarget">
            <summary>
            Places you can trigger haptics on
            </summary>
        </member>
        <member name="F:Sandbox.HapticTarget.Controller">
            <summary>
            Controller
            </summary>
        </member>
        <member name="F:Sandbox.HapticTarget.LeftTrigger">
            <summary>
            Left impulse trigger (Xbox)
            </summary>
        </member>
        <member name="F:Sandbox.HapticTarget.RightTrigger">
            <summary>
            Right impulse trigger (Xbox)
            </summary>
        </member>
        <member name="F:Sandbox.InputGlyphSize.Small">
            <summary>
            Small 32x32 ( Keyboard glyphs can be wider for long key names )
            </summary>
        </member>
        <member name="F:Sandbox.InputGlyphSize.Medium">
            <summary>
            Medium 128x128 ( Keyboard glyphs can be wider for long key names )
            </summary>
        </member>
        <member name="F:Sandbox.InputGlyphSize.Large">
            <summary>
            Large 256x256 ( Keyboard glyphs can be wider for long key names )
            </summary>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.ToPixels(Sandbox.InputGlyphSize)">
            <summary>
            Translates this enum to pixel size.
            </summary>
        </member>
        <member name="F:Sandbox.GlyphStyle.Knockout">
            <summary>
            Face buttons will have colored labels/outlines on a knocked out background
            Rest of inputs will have white detail/borders on a knocked out background
            </summary>
        </member>
        <member name="F:Sandbox.GlyphStyle.Light">
            <summary>
            Black detail/borders on a white background
            </summary>
        </member>
        <member name="F:Sandbox.GlyphStyle.Dark">
            <summary>
            White detail/borders on a black background
            </summary>
        </member>
        <member name="M:Sandbox.GlyphStyle.WithNeutralColorABXY">
            <summary>
            ABXY Buttons will match the base style color instead of their normal associated color
            </summary>
        </member>
        <member name="M:Sandbox.GlyphStyle.WithSolidABXY">
            <summary>
            ABXY Buttons will have a solid fill
            </summary>
        </member>
        <member name="T:Sandbox.GlyphStyleMask">
            <summary>
            Internal bit flags for glyph styles, matches Steam Input ones.
            </summary>
        </member>
        <member name="T:Sandbox.InputSettings">
            <summary>
            A class that holds all configured input settings for a game.
            This is serialized as a config and shared from the server to the client.
            </summary>
        </member>
        <member name="P:Sandbox.InputSettings.Actions">
            <summary>
            A list of actions used by the game.
            </summary>
        </member>
        <member name="T:Sandbox.VR.AnalogInput">
            <summary>
            Represents a VR analog input action (e.g. trigger)
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput.Value">
            <summary>
            The current value of this input, from 0 to 1.
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput.Delta">
            <summary>
            How much <see cref="P:Sandbox.VR.AnalogInput.Value"/> has changed since the last update, from 0 to 1.
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput.Active">
            <summary>
            Whether or not this action is currently accessible (if false, then <see cref="P:Sandbox.VR.AnalogInput.Value"/> will always be 0 and will never change).
            </summary>
        </member>
        <member name="M:Sandbox.VR.AnalogInput.op_Implicit(Sandbox.VR.AnalogInput)~System.Single">
            <summary>
            Implicitly returns <see cref="P:Sandbox.VR.AnalogInput.Value"/> as a <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="T:Sandbox.VR.AnalogInput2D">
            <summary>
            Represents a two-dimensional VR analog input action (e.g. joysticks)
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput2D.Value">
            <summary>
            The current value of this input, with both axes ranging from 0 to 1.
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput2D.Delta">
            <summary>
            How much <see cref="P:Sandbox.VR.AnalogInput2D.Value"/> has changed since the last update, with both axes ranging from 0 to 1.
            </summary>
        </member>
        <member name="P:Sandbox.VR.AnalogInput2D.Active">
            <summary>
            Whether or not this action is currently accessible (if false, then <see cref="P:Sandbox.VR.AnalogInput2D.Value"/> will always be 0 and will never change).
            </summary>
        </member>
        <member name="M:Sandbox.VR.AnalogInput2D.op_Implicit(Sandbox.VR.AnalogInput2D)~Vector2">
            <summary>
            Implicitly returns <see cref="P:Sandbox.VR.AnalogInput2D.Value"/> as a <see cref="T:Vector2"/>.
            </summary>
        </member>
        <member name="T:Sandbox.VR.DigitalInput">
            <summary>
            Represents a VR digital input action (e.g. X button)
            </summary>
        </member>
        <member name="P:Sandbox.VR.DigitalInput.IsPressed">
            <summary>
            The current value of this input - true if pressed, false if not pressed.
            </summary>
        </member>
        <member name="P:Sandbox.VR.DigitalInput.WasPressed">
            <summary>
            The previous value of this input - true if it was pressed, false if it was not pressed.
            </summary>
        </member>
        <member name="P:Sandbox.VR.DigitalInput.Delta">
            <summary>
            How much <see cref="P:Sandbox.VR.DigitalInput.IsPressed"/> has changed since the last update.
            </summary>
        </member>
        <member name="P:Sandbox.VR.DigitalInput.Active">
            <summary>
            Whether or not this action is currently accessible (if false, then <see cref="P:Sandbox.VR.DigitalInput.IsPressed"/> will always be false and will never change).
            </summary>
        </member>
        <member name="M:Sandbox.VR.DigitalInput.op_Implicit(Sandbox.VR.DigitalInput)~System.Boolean">
            <summary>
            Implicitly returns <see cref="P:Sandbox.VR.DigitalInput.IsPressed"/> as a <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.Current">
            <summary>
            The current relevant <see cref="T:Sandbox.VR.VRInput"/> instance.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.Scale">
            <summary>
            Get or set the player's scale in the world. If you set it to 2 the player will be twice as big.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.Anchor">
            <summary>
            Gets or sets where the center of the VR play area is in world space.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.ControllersAreDrawing">
            <summary>
            Returns true if SteamVR is drawing the controllers
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.IsLeftHandDominant">
            <summary>
            Returns true if the left hand is dominant
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.Head">
            <summary>
            Position and rotation of the Head Mounted Display in local space coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.LeftHand">
            <summary>
            Information about the left hand input.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.RightHand">
            <summary>
            Information about the right hand input.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRInput.TrackedObjects">
            <summary>
            A list of available trackers.
            </summary>
        </member>
        <member name="T:Sandbox.VR.TrackedObject">
            <summary>
            Represents a physically tracked VR object with a transform
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Active">
            <summary>
            Whether or not this object is currently accessible (if false, then the transform will not update).
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Velocity">
            <summary>
            Local velocity of this object.
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.AngularVelocity">
            <summary>
            Local angular velocity of this object (degrees/s)
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Transform">
            <summary>
            The position and rotation of this tracked object in world space (based on the anchor position)
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Role">
            <summary>
            Which part of the body this tracked object represents - waist, left shoulder, etc.
            </summary>
        </member>
        <member name="P:Sandbox.VR.TrackedObject.Type">
            <summary>
            What type of object this is - tracker, controller, etc.
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRController">
            <summary>
            Represents a VR controller, along with its transform, velocity, and inputs.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.Trigger">
            <summary>
            The trigger input on this controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.Grip">
            <summary>
            The grip input on this controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.Joystick">
            <summary>
            The primary joystick input on this controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.JoystickPress">
            <summary>
            The primary joystick press on this controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.ButtonA">
            <summary>
            The primary button on this controller (Usually A, can be X for Oculus Touch)
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.ButtonB">
            <summary>
            The secondary button on this controller (Usually B, can be Y for Oculus Touch)
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.IsVive">
            <summary>
            Returns true if this is a Vive controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.IsRift">
            <summary>
            Returns true if this is a Meta Rift or Meta Touch controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.IsKnuckles">
            <summary>
            Returns true if this is a Valve Knuckles controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRController.IsWMR">
            <summary>
            Returns true if this is a Windows Mixed Reality controller
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRController._pose">
            <summary>
            Current input pose for this hand
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.GetFingerValue(Sandbox.VR.FingerValue)">
            <summary>
            Get the skeletal value (from 0 to 1) of a specified <see cref="T:Sandbox.VR.FingerValue"/> - includes curl and splay.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.GetFingerCurl(System.Int32)">
            <summary>
            Get the skeletal value (from 0 to 1) of a specified finger curl index.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.GetFingerSplay(System.Int32)">
            <summary>
            Get the skeletal value (from 0 to 1) of a specified finger splay index.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.GetModel">
            <summary>
            Retrieves or creates a cached model that can be used to render this controller.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.TriggerHapticVibration(System.Single,System.Single,System.Single)">
            <summary>
            Triggers a haptic vibration event on the controller for this hand.
            </summary>
            <remarks>
            If a haptic event is already running it will be interrupted immediately.
            </remarks>
            <param name="duration">How long the haptic action should last (in seconds - can be 0 to "pulse" it)</param>
            <param name="frequency">How often the haptic motor should bounce (0 - 320 in hz. The lower end being more useful)</param>
            <param name="amplitude">How intense the haptic should be (0 - 1)</param>
        </member>
        <member name="M:Sandbox.VR.VRController.StopAllVibrations">
            <summary>
            Stop all vibration events on this controller.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRController.TriggerHaptics(Sandbox.HapticEffect,System.Single,System.Single,System.Single)">
            <summary>
            Trigger a vibration based on a predefined <see cref="T:Sandbox.HapticPattern"/>.
            All <see cref="T:Sandbox.HapticPattern"/>s are normalized (start at 0, peak at 1).
            </summary>
            <param name="effect">The pattern to use</param>
            <param name="lengthScale">The amount to scale the pattern's length by.</param>
            <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
            <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
        </member>
        <member name="M:Sandbox.VR.VRController.StopAllHaptics">
            <summary>
            Stops all rumble and haptic events on this controller.
            </summary>
        </member>
        <member name="T:Sandbox.VR.FingerValue">
            <summary>
            Accessors for <see cref="M:Sandbox.VR.VRController.GetFingerValue(Sandbox.VR.FingerValue)"/>
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.ThumbCurl">
            <summary>
            Represents the curling motion of the thumb.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.IndexCurl">
            <summary>
            Represents the curling motion of the index finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.MiddleCurl">
            <summary>
            Represents the curling motion of the middle finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.RingCurl">
            <summary>
            Represents the curling motion of the ring finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.PinkyCurl">
            <summary>
            Represents the curling motion of the pinky finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.ThumbIndexSplay">
            <summary>
            Represents the splaying motion between the thumb and index finger.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.IndexMiddleSplay">
            <summary>
            Represents the splaying motion between the index and middle fingers.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.MiddleRingSplay">
            <summary>
            Represents the splaying motion between the middle and ring fingers.
            </summary>
        </member>
        <member name="F:Sandbox.VR.FingerValue.RingPinkySplay">
            <summary>
            Represents the splaying motion between the ring and pinky fingers.
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRSystem.States.Shutdown">
            <summary>
            The VR system is currently shut down.
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRSystem.States.Standby">
            <summary>
            The VR system is not updating or rendering, but is ready.
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRSystem.States.PreInit">
            <summary>
            The VR system has begun to initialise. An OpenXR instance has been created.
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRSystem.States.Active">
            <summary>
            The VR system is active and updating.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRSystem.Init">
            <summary>
            Initialise the VR instance.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRSystem.Disable">
            <summary>
            Disable the VR instance.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRSystem.Shutdown">
            <summary>
            Shut down the VR instance.
            </summary>
        </member>
        <member name="T:Sandbox.VR.TrackedDevice">
            <summary>
            Describes a tracked VR device
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.Transform">
            <summary>
            This device's transform in absolute space
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.Velocity">
            <summary>
            Velocity in tracker space in inch/s
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.AngularVelocity">
            <summary>
            Angular velocity in degrees/s
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.DeviceRole">
            <summary>
            Where is this device (left hand, right hand, left ankle, chest, etc.)?
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.DeviceType">
            <summary>
            What type of device is this (HMD, controller, tracker, etc.)?
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.InputSource">
            <summary>
            The input source for this device
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.InputSourceHandle">
            <summary>
            Handle we should use internally for performance-sensitive calls
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.IsActive">
            <summary>
            Is this tracked device currently active (connected)?
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDevice.DeviceIndex">
            <summary>
            Index we can use when referring to poses retrieved through WaitGetPose and similar functions
            </summary>
        </member>
        <member name="M:Sandbox.VR.TrackedDevice.Update">
            <summary>
            Update this tracked device's position, velocity, etc.
            </summary>
        </member>
        <member name="T:Sandbox.VR.TrackedDeviceInfo">
            <summary>
            Information about a tracked device - vendor info, serial number, battery data
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.VendorName">
            <summary>
            Which tracking system does this use (e.g. "oculus")? <br/>
            Represents the value given by <c>Prop_TrackingSystemName_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.ManufacturerName">
            <summary>
            Who manufactured this device (e.g. "Oculus")? <br />
            Represents the value given by <c>Prop_ManufacturerName_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.DisplayName">
            <summary>
            What is this device called (e.g. "Oculus Rift S (Left Controller)")? <br/>
            Represents the value given by <c>Prop_ModelNumber_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.RenderModelName">
            <summary>
            Which render model should this use (e.g. "oculus_rifts_controller_left")? <br/>
            Represents the value given by <c>Prop_RenderModelName_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.SerialNumber">
            <summary>
            What is the serial number for this device (e.g. "1WMGH---------_Controller_Left")? <br/>
            Represents the value given by <c>Prop_SerialNumber_String</c>.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.BatteryPercentage">
            <summary>
            Battery percentage from 0 to 100
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceInfo.TypeString">
            <summary>
            If this is a controller, then represents the value given by <c>Prop_ControllerType_String</c>, otherwise "unknown".
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Unknown">
            <summary>
            Unknown device role
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftHand">
            <summary>
            Represents the left hand
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightHand">
            <summary>
            Represents the right hand
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Head">
            <summary>
            Represents the head
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Gamepad">
            <summary>
            Represents a gamepad
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Treadmill">
            <summary>
            Represents a treadmill
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Stylus">
            <summary>
            Represents a stylus
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftFoot">
            <summary>
            Represents the left foot
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightFoot">
            <summary>
            Represents the right foot
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftShoulder">
            <summary>
            Represents the left shoulder
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightShoulder">
            <summary>
            Represents the right shoulder
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftElbow">
            <summary>
            Represents the left elbow
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightElbow">
            <summary>
            Represents the right elbow
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftKnee">
            <summary>
            Represents the left knee
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightKnee">
            <summary>
            Represents the right knee
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftWrist">
            <summary>
            Represents the left wrist
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightWrist">
            <summary>
            Represents the right wrist
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.LeftAnkle">
            <summary>
            Represents the left ankle
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.RightAnkle">
            <summary>
            Represents the right ankle
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Waist">
            <summary>
            Represents the waist
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Chest">
            <summary>
            Represents the chest
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Camera">
            <summary>
            Represents a camera - such as a base station
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceRole.Keyboard">
            <summary>
            Represents a keyboard
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Invalid">
            <summary>
            The ID was not valid.
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Hmd">
            <summary>
            Head-mounted display (your headset)
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Controller">
            <summary>
            Tracked controllers
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Tracker">
            <summary>
            Generic trackers
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.BaseStation">
            <summary>
            Camera and base stations that serve as tracking reference points
            </summary>
        </member>
        <member name="F:Sandbox.VR.TrackedDeviceType.Redirect">
            <summary>
            Accessories that aren't necessarily tracked themselves, but may redirect video output from other tracked devices
            </summary>
        </member>
        <member name="T:Sandbox.VR.VROverlay">
            <summary>
            <para>VR overlays draw over the top of the 3D scene, they will not be affected by lighting,
            post processing effects or anything else in the world.<br />
            This makes them ideal for HUDs or menus, or anything else that should be local to the
            HMD or tracked devices.</para>
            
            <para>If you need something in the world, consider using WorldPanel
            and WorldInput instead.</para>
            </summary>
        </member>
        <member name="M:Sandbox.VR.VROverlay.Dispose">
            <summary>
            Destroys this overlay.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VROverlay.Dispose(System.Boolean)">
            <summary>
            Destroys this overlay.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Visible">
            <summary>
            Shows or hides the VR overlay.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Transform">
            <summary>
            Sets the transform to absolute tracking origin
            </summary>
        </member>
        <member name="M:Sandbox.VR.VROverlay.SetTransformAbsolute(Transform)">
            <summary>
            Sets the transform to absolute tracking origin
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.SortOrder">
            <summary>
            Sets the rendering sort order for the overlay.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Width">
            <summary>
            The width of the overlay quad.
            By default overlays are rendered on a quad that is 1 meter across.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Curvature">
            <summary>
            Use to draw overlay as a curved surface. Curvature is a percentage from (0..1] where 1 is a fully closed cylinder.
            For a specific radius, curvature can be computed as: overlay.width / (2 PI r).
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Color">
            <summary>
            Sets the color tint of the overlay quad. Use 0.0 to 1.0 per channel.
            Sets the alpha of the overlay quad. Use 1.0 for 100 percent opacity to 0.0 for 0 percent opacity.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.Texture">
            <summary>
            Texture that is rendered on the overlay quad.
            <see cref="T:Sandbox.TextureBuilder"/>
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlay.MouseScale">
            <summary>
            Sets the mouse scaling factor that is used for mouse events. 
            </summary>
        </member>
        <member name="M:Sandbox.VR.VROverlay.TriggerLaserMouseHapticVibration(System.Single,System.Single,System.Single)">
            <summary>
            Triggers a haptic event on the laser mouse controller for this overlay
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRNative">
            <summary>
            Native helpers for VR
            </summary>
            <summary>
            Native helpers for VR
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IPD">
            <summary>
            Private store for distance between user's pupils, in inches.
            Accessed and converted through <see cref="P:Sandbox.VR.VRNative.IPDMillimetres"/> and <see cref="P:Sandbox.VR.VRNative.IPDInches"/>
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IPDMillimetres">
            <summary>
            Distance between user's pupils, in millimetres
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IPDInches">
            <summary>
            Distance between user's pupils, in inches
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.RefreshRate">
            <summary>
            Headset refresh rate, in Hz
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IsDashboardVisible">
            <summary>
            Is the SteamVR dashboard currently visible?
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.IsLeftHandDominant">
            <summary>
            Has the user selected that they're left hand dominant in SteamVR?
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.FullRenderTargetSize">
            <summary>
            Spans both eyes - equivalent to (eye width * 2, eye height)
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.EyeRenderTargetSize">
            <summary>
            Spans one eye
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRNative.WorldScale">
            <summary>
            Scales the relative position between the two eyes
            </summary>
        </member>
        <member name="M:Sandbox.Modals.IModalSystem.PauseMenu">
            <summary>
            The menu that is shown when escape is pressed while playing.
            </summary>
        </member>
        <member name="P:Sandbox.Modals.FriendsListModalOptions.ShowOfflineMembers">
            <summary>
            Show offline members
            </summary>
        </member>
        <member name="P:Sandbox.Modals.FriendsListModalOptions.ShowOnlineMembers">
            <summary>
            Show online (but not in-game) members
            </summary>
        </member>
        <member name="T:Sandbox.DelegateFunctionPointer">
            <summary>
            Helper to wrap <see cref="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)"/> while keeping
            a reference to the original delegate, so it won't be garbage collected. <see cref="M:Sandbox.DelegateFunctionPointer.Dispose"/>
            must be called to remove the reference.
            </summary>
        </member>
        <member name="M:Sandbox.DelegateFunctionPointer.op_Implicit(Sandbox.DelegateFunctionPointer)~System.IntPtr">
            <summary>
            Gets the raw function pointer.
            </summary>
        </member>
        <member name="M:Sandbox.DelegateFunctionPointer.Get``1(``0)">
            <inheritdoc cref="T:Sandbox.DelegateFunctionPointer"/>
        </member>
        <member name="M:Sandbox.DelegateFunctionPointer.Dispose">
            <summary>
            Removes the reference to the original delegate, and sets the function pointer to null.
            </summary>
        </member>
        <member name="T:Sandbox.IHandle">
            <summary>
            A base interface that all handles should use
            </summary>
        </member>
        <member name="T:Sandbox.HandleCreationData">
            <summary>
            This struct exists to differentiate the constructor of a handle object
            from the regular constructors. This way we can prevent clients creating
            the object manually, but still be able to create them at runtime.
            </summary>
        </member>
        <member name="T:Sandbox.HandleIndex">
            <summary>
            An index that can convert from a handle (int) to a class. This is
            usually a static on your Handle object called HandleIndex.
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetString(System.IntPtr)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetString(System.IntPtr,System.Int32)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetWString(System.IntPtr)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetWString(System.IntPtr,System.Int32)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetPointer(System.String)">
            <summary>
            Get a native friendly utf8 pointer
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetWPointer(System.String)">
            <summary>
            Get a native friendly unicode pointer
            </summary>
        </member>
        <member name="M:Sandbox.Interop.BindingException(System.String,System.String,System.Exception)">
            <summary>
            Called by the binding system to log an exception when calling a binding
            </summary>
        </member>
        <member name="P:Sandbox.Map.PhysicsGroup">
            <summary>
            The world physics objects
            </summary>
        </member>
        <member name="P:Sandbox.Map.SceneMap">
            <summary>
            The world geometry;
            </summary>
        </member>
        <member name="T:Sandbox.MapLoader.ObjectEntry">
            <summary>
            Holds key values for the map object
            </summary>
        </member>
        <member name="M:Sandbox.MapLoader.CreateObject(Sandbox.MapLoader.ObjectEntry)">
            <summary>
            Create an object from a serialized object entry
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBodyType.Static">
            <inheritdoc cref="F:Sandbox.PhysicsMotionType.Static"/>
        </member>
        <member name="F:Sandbox.PhysicsBodyType.Keyframed">
            <inheritdoc cref="F:Sandbox.PhysicsMotionType.Keyframed"/>
        </member>
        <member name="F:Sandbox.PhysicsBodyType.Dynamic">
            <inheritdoc cref="F:Sandbox.PhysicsMotionType.Dynamic"/>
        </member>
        <member name="T:Sandbox.PhysicsMotionType">
            <summary>
            Represents <see cref="T:Sandbox.PhysicsBody">Physics body's</see> motion type.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsMotionType.Invalid">
            <summary>
            Invalid type.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsMotionType.Dynamic">
            <summary>
            Physically simulated body.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsMotionType.Static">
            <summary>
            Cannot move at all.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsMotionType.Keyframed">
            <summary>
            No physics simulation, but can be moved via setting position/rotation.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ServerInfo.IsDeveloperHost">
            <summary>
            If true then this host is being run from an editor, as such the assemblies
            are sent via network tables and loading assemblies from the package is not required.
            </summary>
        </member>
        <member name="M:Sandbox.Network.ConnectionInfoManager.Get(System.Guid)">
            <summary>
            Get info for this connection
            </summary>
        </member>
        <member name="T:Sandbox.Network.ConnectionInfo">
            <summary>
            Information about a connection. The difference between this and the actual connections is that
            this can be networked between clients, so all clients have the same information about each other.
            This is going to be required in p2p games, where players need to take over hosting from each other.
            In a game like Rust, with a dedicated server, this won't need to be networked to other clients.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionInfo.UserData">
            <summary>
            Key values that come straight from the user. Can't be trusted, they could send anything. Used
            for things like preferences, avatar clothing etc.
            </summary>
        </member>
        <member name="F:Sandbox.Network.ConnectionInfo._localMock">
            <summary>
            When a user isn't connected to a server, or hosting a server, the 
            client info table doesn't exist. So we provide info here for the 
            local connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.Ping">
            <summary>
            Current ping for this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.OutPacketsPerSecond">
            <summary>
            How many packets per second we're sending to this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.OutBytesPerSecond">
            <summary>
            How many bytes per second we're sending to this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.InPacketsPerSecond">
            <summary>
            How many packets per second we're receiving from this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.InBytesPerSecond">
            <summary>
            How many bytes per second we're receiving from this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.SendRateBytesPerSecond">
            <summary>
            Estimate rate that we believe we can send data to this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Network.ConnectionStats.ConnectionQuality">
            <summary>
            From 0 to 1 how good is our connection to this?
            </summary>
        </member>
        <member name="T:Sandbox.Network.GameNetworkSystem">
            <summary>
            An instance of this is created by the NetworkSystem when a server is joined, or created.
            You should not try to create this manually.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnConnected(Sandbox.Connection)">
            <summary>
            Connected to the server, but isn't joined yet
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnJoined(Sandbox.Connection)">
            <summary>
            Fully joined the server. Can be called when changing the map too.
            The game should usually create some object for the player to control here.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnLeave(Sandbox.Connection)">
            <summary>
            Has left the server
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnBecameHost(Sandbox.Connection)">
            <summary>
            The host left the server and you are now in charge
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.Push">
            <summary>
            Allows to push some kind of scope when reading network messages. This is useful if you
            need to adjust Time.Now etc.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.Tick">
            <summary>
            Called every frame
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnHeartbeat(System.Single,System.Single)">
            <summary>
            A heartbeat has been received from the host. We should make sure our times are in sync.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnChangingLevel">
            <summary>
            Called when we are changing level
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.MapName">
            <summary>
            To update the current map's name, which will show on the server listing.
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.IsHost">
            <summary>
            True if we can be considered the host of this session. Either we're not connected to a server, or we are and we are the host.
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.IsClient">
            <summary>
            True if we're connected to a server and not the host.
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.IsConnecting">
            <summary>
            True if we're currently connecting to the server
            </summary>
        </member>
        <member name="P:Sandbox.Network.GameNetworkSystem.IsActive">
            <summary>
            True if we're currently connected etc
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.Disconnect">
            <summary>
            Disconnect from current multiplayer session
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.TryConnect(System.String,System.Int32)">
            <summary>
            Tries to join a networked game, and tries a set amount of times before giving up.
            </summary>
            <param name="target"></param>
            <param name="retries"></param>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.Connect(System.String)">
            <summary>
            Will try to determine the right method for connection, and then try to connect.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.TryConnectSteamId(System.UInt64)">
            <summary>
            Will try to connect to a server. Will return false if failed to connect.
            </summary>
        </member>
        <member name="M:Sandbox.Network.GameNetworkSystem.OnChangingScene">
            <summary>
            Called before changing scene, to allow us the opportunity to disconnect from the server (or stop hosting).
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyInformation.IsFull">
            <summary>
            True if this lobby is full (members >= maxmembers)
            </summary>
        </member>
        <member name="P:Sandbox.Network.LobbyInformation.ContainsFriends">
            <summary>
            Return true if this lobby contains a friend
            </summary>
        </member>
        <member name="T:Sandbox.Network.InternalMessageType">
            <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.HeartbeatPing">
            <summary>
            A small message sent from the host to the client, and then returned to measure latency and keep
            everything in sync.
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.Chunk">
            <summary>
            Is multiple chunks of the same message
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.Packed">
            <summary>
            Is a struct packed using TypeLibrary
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.Request">
            <summary>
            A request, this is a guid, then another message
            </summary>
        </member>
        <member name="F:Sandbox.Network.InternalMessageType.Response">
            <summary>
            A response, this is a guid, then another message
            </summary>
        </member>
        <member name="F:Sandbox.Network.NetTransmission.Unreliable">
            <summary>
            Message will be sent unreliably. It may not arrive and it may be received out of order.
            </summary>
        </member>
        <member name="F:Sandbox.Network.NetTransmission.Reliable">
            <summary>
            Message will be sent reliably. Multiple attempts will be made until the recipient has received it.
            </summary>
        </member>
        <member name="F:Sandbox.Network.NetTransmission.NoNagle">
            <summary>
            Message will not be grouped up with other messages.
            </summary>
        </member>
        <member name="F:Sandbox.Network.NetTransmission.NoDelay">
            <summary>
            Message will be dropped if it can't be sent quickly. Only applicable to unreliable messages.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.Initialize(Sandbox.Network.NetworkSystem)">
            <summary>
            Called when everything has just been hooked up to the network system.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.OnConnectionInfoUpdated(Sandbox.Network.NetworkSystem)">
            <summary>
            ConnectionInfo table has been updated
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSocket.Tick(Sandbox.Network.NetworkSystem)">
            <summary>
            Called once a second
            </summary>
        </member>
        <member name="T:Sandbox.Network.NetworkSystem">
            <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
            <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
            <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSystem.IsConnecting">
            <summary>
            True if we're currently connecting to the server. We're not yet spawned etc.
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSystem.ConnectionString">
            <summary>
            The string used to connect to this server.
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSystem.IsDeveloperHost">
            <summary>
            If true then this host is sending assemblies and other files via network tables
            and as such, does not need to load assemblies from the package (if it even exists).
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.FindConnection(System.Guid)">
            <summary>
            Find a connection by its unique id.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.AddConnection(Sandbox.Connection,Sandbox.UserInfo)">
            <summary>
            Called from the host to add a connection to the ConnectionInfo table
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnConnectionInfoUpdated">
            <summary>
            Called any time we suspect the connection info might have changed, which
            lets us tell the sockets/connections to update any information they hold.
            </summary>
        </member>
        <member name="P:Sandbox.Network.NetworkSystem.IsHost">
            <summary>
            Are we the owner of this network system? True if we're hosting
            the server, or we're the current owner of a p2p system.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.OnTargetedMessage(Sandbox.Network.TargetedMessage,Sandbox.Connection,System.Guid)">
            <summary>
            We have received a message intended for a different connection
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.Tick">
            <summary>
            Called to read and process incoming messages
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.On_Handshake_ServerInfo(Sandbox.Network.ServerInfo,Sandbox.Connection,System.Guid)">
            <summary>
            Server says hello to the client. It tells the client some basic information about itself. 
            The client can determine here whether they still want to join or not.
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.Broadcast(Sandbox.ByteStream,Sandbox.Connection.ChannelState,System.Nullable{Sandbox.Connection.Filter},Sandbox.Network.NetTransmission)">
            <summary>
            Send a message to all connections. You can optionally pass in a filter to determine who actually receives the message.
            </summary>
            <param name="msg">The message to send.</param>
            <param name="minimumState">The minumum state the connection must be to receive the message.</param>
            <param name="filter">If specified, the connection must pass this filter to receive the message.</param>
            <param name="flags">Network message flags that may dictate how the message is sent.</param>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.InstallStringTables(System.Boolean)">
            <summary>
            String tables should all get installed at this point
            </summary>
        </member>
        <member name="M:Sandbox.Network.NetworkSystem.InstallTable(Sandbox.Network.StringTable)">
            <summary>
            Install a network table. If we're the host then this table will
            be sent to all clients.. but only if they have the same named network
            table installed.
            </summary>
        </member>
        <member name="F:Sandbox.Network.StringTable.OnChangeOrAdd">
            <summary>
            Called when a table entry is changed or added from the network
            </summary>
        </member>
        <member name="F:Sandbox.Network.StringTable.OnSnapshot">
            <summary>
            The table has been fully replaced. Anything or everything could have changed.
            </summary>
        </member>
        <member name="F:Sandbox.Network.StringTable.OnRemoved">
            <summary>
            Called when a table entry is removed by the network
            </summary>
        </member>
        <member name="F:Sandbox.Network.StringTable.PostNetworkUpdate">
            <summary>
            Called after a network update of the table is complete. Not called after snapshots!
            </summary>
        </member>
        <member name="M:Sandbox.Network.StringTable.Entry.Read``1">
            <summary>
            Read an unmanaged struct from the data
            </summary>
        </member>
        <member name="T:Sandbox.Network.LocalConnection">
            <summary>
            A mock channel. Allows passing this to RPCs when they're being called locally
            </summary>
        </member>
        <member name="T:Sandbox.Network.MockConnection">
            <summary>
            A mock channel. Allows passing this to RPCs when they're being called locally
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamLobbyConnection">
            <summary>
            A direct connection to a peer in a lobby
            </summary>
        </member>
        <member name="F:Sandbox.Network.SteamLobbyConnection.ConnectionState.Dead">
            Connection is completely inactive and ready to be destroyed
        </member>
        <member name="T:Sandbox.Network.SteamLobbySocket">
            <summary>
            A lobby "server"
            </summary>
        </member>
        <member name="P:Sandbox.Network.SteamLobbySocket.HostSteamId">
            <summary>
            The SteamId of the host of this lobby
            </summary>
        </member>
        <member name="P:Sandbox.Network.SteamLobbySocket.LobbySteamId">
            <summary>
            The SteamId of the host of this lobby
            </summary>
        </member>
        <member name="P:Sandbox.Network.SteamLobbySocket.LobbyMemberCount">
            <summary>
            How many cunts are in this lobby
            </summary>
        </member>
        <member name="F:Sandbox.Network.SteamLobbySocket.owner">
            <summary>
            Current owner of this lobby, if they leave this gets updated to someone else
            </summary>
        </member>
        <member name="M:Sandbox.Network.SteamLobbySocket.Initialize(Sandbox.Network.NetworkSystem)">
            <summary>
            Called when everything has just been hooked up to the network system.
            </summary>
        </member>
        <member name="M:Sandbox.Network.SteamLobbySocket.SetConnectionId(System.UInt64,Sandbox.Network.ConnectionInfo)">
            <summary>
            Make sure this steamid has this connection id
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.IdConnection">
            <summary>
            A connection to a SteamId
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.IpConnection">
            <summary>
            A connection to an IP and port
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.SocketConnection">
            <summary>
            A connection from a listen socket
            </summary>
        </member>
        <member name="F:Sandbox.Network.SteamNetwork.Connection.ConnectionState.Dead">
            Connection is completely inactive and ready to be destroyed
        </member>
        <member name="M:Sandbox.Network.SteamNetwork.RunCallbacks">
            <summary>
            This gets called by the steamapi, so only really need to call this in unit tests
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.IdListenSocket">
            <summary>
            A socket that listens on a steamid and virtual port
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.IpListenSocket">
            <summary>
            A socket that listens on an ip address and port
            </summary>
        </member>
        <member name="T:Sandbox.Network.SteamNetwork.Socket">
            <summary>
            A listen socket, one socket to many. We should really use this just dedicated servers imo.
            </summary>
        </member>
        <member name="T:Sandbox.Network.HSteamNetConnection">
            <summary>
            A handle to a connection.
            </summary>
        </member>
        <member name="T:Sandbox.Network.HSteamListenSocket">
            <summary>
            A handle to a listen socket
            </summary>
        </member>
        <member name="T:Sandbox.Network.HSteamNetPollGroup">
            <summary>
            A handle to a poll group
            </summary>
        </member>
        <member name="T:Sandbox.Network.TcpChannel">
            <summary>
            A listen socket, one socket to many. We should really use this just dedicated servers imo.
            </summary>
        </member>
        <member name="M:Sandbox.Network.TcpChannel.SendThread(System.Threading.CancellationToken)">
            <summary>
            Send the network data in a thread. This prevents the client from freezing
            up when running a client and server in the same process. In reality this only
            really happens in unit tests, but better safe than sorry.
            </summary>
        </member>
        <member name="T:Sandbox.Network.TcpSocket">
            <summary>
            A listen socket over TCP. For testing locally.
            </summary>
        </member>
        <member name="T:Sandbox.Networking">
            <summary>
            Global manager to hold and tick the singleton instance of NetworkSystem.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.IsHost">
            <summary>
            True if we can be considered the host of this session. Either we're not connected to a server, or we are host of a server.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.HostConnection">
            <summary>
            The connection of the current network host.
            </summary>
        </member>
        <member name="P:Sandbox.Networking.Connections">
            <summary>
            A list of connections that are currently on this server. If you're not on a server
            this will return only one connection (Connection.Local). Some games restrict the 
            connection list - in which case you will get an empty list.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.JoinBestLobby(System.String)">
            <summary>
            Try to join the best lobby. Return true on success.
            </summary>
        </member>
        <member name="M:Sandbox.Networking.QueryLobbies">
            <summary>
            Get all lobbies
            </summary>
        </member>
        <member name="M:Sandbox.Networking.QueryLobbies(System.String)">
            <summary>
            Get all lobbies for game
            </summary>
        </member>
        <member name="M:Sandbox.Networking.QueryLobbies(System.String,System.String)">
            <summary>
            Get all lobbies for game, with map
            </summary>
        </member>
        <member name="P:Sandbox.UserInfo.Local">
            <summary>
            Build info for the local user, which will then get sent to the server and possibly shared between all clients
            </summary>
        </member>
        <member name="T:Sandbox.Connection">
            <summary>
            A connection, usually to a server or a client.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.Id">
            <summary>
            This connection's unique identifier.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.CanSpawnObjects">
            <summary>
            Can this connection spawn networked objects?
            </summary>
        </member>
        <member name="P:Sandbox.Connection.CanRefreshObjects">
            <summary>
            Can this connection refresh networked objects that they own?
            </summary>
        </member>
        <member name="P:Sandbox.Connection.IsConnecting">
            <summary>
            True if this channel is still currently connecting.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.IsActive">
            <summary>
            True if this channel is fully connnected and fully logged on.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.SendMessage``1(``0)">
            <summary>
            Send a message to this connection.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.State">
            <summary>
            Current internal progression of this connection.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.GenerateConnectionId">
            <summary>
            Generate an ID for this connection. This is called by the server to allocate
            the connection an identifier. We're avoiding sequential, allocated ids because
            who needs to deal with that bullshit.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.UpdateFrom(Sandbox.Network.ChannelInfo)">
            <summary>
            Update this channel's info. Usually called from the host.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.Tick(Sandbox.Network.NetworkSystem)">
            <summary>
            Called once a second.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.Ping">
            <summary>
            The ping of this connection.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.UpdateRtt(System.Single)">
            <summary>
            The server has worked out the round trip time on a connection using the heartbeat.
            We want to keep a sliding window of this timing and use it to predict the latency.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.PartyId">
            <summary>
            The Id of the party that this user is a part of. This can be used to compare to other users to 
            group them into parties.
            </summary>
        </member>
        <member name="F:Sandbox.Connection.Filter.FilterType.Include">
            <summary>
            Only include the connections in the filter when sending a message.
            </summary>
        </member>
        <member name="F:Sandbox.Connection.Filter.FilterType.Exclude">
            <summary>
            Exclude the connections in the filter when sending a message.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.Filter.IsRecipient(Sandbox.Connection)">
            <summary>
            Is the specified <see cref="T:Sandbox.Connection"/> a valid recipient?
            </summary>
        </member>
        <member name="M:Sandbox.Connection.SendRequest``1(``0)">
            <summary>
            Send a message to this connection, wait for a response
            </summary>
        </member>
        <member name="M:Sandbox.Connection.SendResponse``1(System.Guid,``0)">
            <summary>
            Send a response message to this connection.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.OnResponse(System.Guid,System.Object)">
            <summary>
            A response to a message has arrived, route it to the correct async function
            </summary>
        </member>
        <member name="P:Sandbox.Connection.Local">
            <summary>
            This is a "fake" connection for the local player. It is passed to RPCs when calling them
            locally etc.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.All">
            <summary>
            A list of connections that are currently on this server. If you're not on a server
            this will return only one connection (Connection.Local). Some games restrict the 
            connection list - in which case you will get an empty list.
            </summary>
        </member>
        <member name="P:Sandbox.Connection.Host">
            <summary>
            The connection of the current network host
            </summary>
        </member>
        <member name="M:Sandbox.Connection.Find(System.Guid)">
            <summary>
            Find a <see cref="T:Sandbox.Connection"/> for a Connection Id.
            </summary>
        </member>
        <member name="M:Sandbox.Connection.Reset">
            <summary>
            Reset any static members to their defaults or clear them.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.CollisionRules">
            <summary>
            This is a JSON serializable description of the physics's collision rules. This allows us to send it
            to the engine - and store it in a string table (which is networked to the client). You shouldn't really
            ever have to mess with this, it's just used internally.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.CollisionRules.Result">
            <summary>
            Result of a collision between <see cref="T:Sandbox.Physics.CollisionRules.Pair">two objects</see>.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.CollisionRules.Result.Unset">
            <summary>
            Fallback to default behavior.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.CollisionRules.Result.Collide">
            <summary>
            Collide.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.CollisionRules.Result.Trigger">
            <summary>
            Do not collide, but trigger touch callbacks.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.CollisionRules.Result.Ignore">
            <summary>
            Do not collide.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.CollisionRules.Pair">
            <summary>
            A pair of case- and order-insensitive tags, used as a key to look up a <see cref="T:Sandbox.Physics.CollisionRules.Result"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.op_Implicit(System.ValueTuple{System.String,System.String})~Sandbox.Physics.CollisionRules.Pair">
            <summary>
            Initializes from a pair of tags.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Pair.Left">
            <summary>
            First of the two tags.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Pair.Right">
            <summary>
            Second of the two tags.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.#ctor(System.String,System.String)">
            <summary>
            Initializes from a pair of tags.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.Contains(System.String)">
            <summary>
            Returns true if either <see cref="P:Sandbox.Physics.CollisionRules.Pair.Left"/> or <see cref="P:Sandbox.Physics.CollisionRules.Pair.Right"/> matches the given tag.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.Equals(Sandbox.Physics.CollisionRules.Pair)">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Pair.GetHashCode">
            <inheritdoc />
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Defaults">
            <summary>
            If no pair matching is found, this is what we'll use
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Pairs">
            <summary>
            What happens when a pair collides
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.Tags">
            <summary>
            All tags with either an entry in <see cref="P:Sandbox.Physics.CollisionRules.Defaults"/> or <see cref="P:Sandbox.Physics.CollisionRules.Pairs"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.CollisionRules.SerializedPairs">
            <summary>
            Gets or sets <see cref="P:Sandbox.Physics.CollisionRules.Pairs"/> in its serialized form for JSON.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.LeastColliding(Sandbox.Physics.CollisionRules.Result,Sandbox.Physics.CollisionRules.Result)">
            <summary>
            Selects the result with the highest precedence (least colliding).
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.GetCollisionRule(System.String,System.String)">
            <summary>
            Gets the specific collision rule for a pair of tags.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.GetCollisionRules(System.String)">
            <summary>
            For each known tag, what result does it have when tested against the given <paramref name="tag"/>?
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.GetCollisionRules(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            For each known tag, what result does it have when tested against the given set of <paramref name="tags"/>?
            </summary>
        </member>
        <member name="M:Sandbox.Physics.CollisionRules.Clean">
            <summary>
            Remove duplicates etc
            </summary>
        </member>
        <member name="T:Sandbox.Physics.BallSocketJoint">
            <summary>
            A ballsocket constraint.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.BallSocketJoint.Friction">
            <summary>
            Constraint friction.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.BallSocketJoint.SwingLimit">
            <summary>
            Maximum angle it should be allowed to swing to
            </summary>
        </member>
        <member name="T:Sandbox.Physics.FixedJoint">
            <summary>
            A generic "rope" type constraint.
            </summary>
            <remarks>
            TODO: How is this different from <see cref="T:Sandbox.Physics.SpringJoint"/>? Should they be merged?
            </remarks>
        </member>
        <member name="P:Sandbox.Physics.FixedJoint.SpringLinear">
            <summary>
            How springy and tight the joint will be in its movement.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.FixedJoint.SpringAngular">
            <summary>
            How springy and tight the joint will be in its rotation.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.HingeJoint">
            <summary>
            A hinge-like constraint.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.HingeJoint.MaxAngle">
            <summary>
            Maximum angle it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.HingeJoint.MinAngle">
            <summary>
            Minimum angle it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.HingeJoint.Friction">
            <summary>
            Hinge friction.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.PulleyJoint">
             <summary>
             A pulley constraint. Consists of 2 ropes which share same length, and the ratio changes via physics interactions.
            
             Typical setup looks like this:
             <code>
                @-----------------@
                |                 |
                |                 |
             Object A          Object B
             </code>
             </summary>
        </member>
        <member name="T:Sandbox.Physics.SliderJoint">
            <summary>
            A slider constraint, basically allows movement only on the arbitrary axis between the 2 constrained objects on creation.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SliderJoint.MaxLength">
            <summary>
            Maximum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SliderJoint.MinLength">
            <summary>
            Minimum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SliderJoint.Friction">
            <summary>
            Slider friction.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.SpringJoint">
            <summary>
            A rope-like constraint that is has springy/bouncy.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SpringJoint.SpringLinear">
            <summary>
            How springy and tight the joint will be
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SpringJoint.MaxLength">
            <summary>
            Maximum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SpringJoint.MinLength">
            <summary>
            Minimum length it should be allowed to go. At which point it acts a bit like a rod.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.SpringJoint.ReferenceMass">
            <summary>
            You shouldn't really ever need to change this, the default works out
            what the reference mass should be based on actual physics.
            </summary>
        </member>
        <member name="T:Sandbox.Physics.PhysicsJoint">
            <summary>
            A physics constraint.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.Remove">
            <summary>
            Removes this joint.
            </summary>
        </member>
        <member name="E:Sandbox.Physics.PhysicsJoint.OnBreak">
            <summary>
            Called when the joint breaks.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.World">
            <summary>
            The <see cref="T:Sandbox.PhysicsWorld"/> this joint belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Body1">
            <summary>
            The source physics body this joint is attached to.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Body2">
            <summary>
            The target physics body this joint is constraining.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Point1">
            <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Physics.PhysicsJoint.Body1"/>
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Point2">
            <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Physics.PhysicsJoint.Body2"/>
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.IsActive">
            <summary>
            Whether this constraint is active. (i.e. is enabled, is not broken)
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Collisions">
            <summary>
            Enables or disables collisions between the 2 constrained physics bodies.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.Strength">
            <summary>
            Strength of the linear constraint. If it takes any more energy than this, it'll break.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsJoint.AngularStrength">
            <summary>
            Strength of the angular constraint. If it takes any more energy than this, it'll break.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateFixed(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint)">
            <summary>
            Creates an almost solid constraint between two physics bodies.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateLength(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint,System.Single)">
            <summary>
            Creates a constraint like a rope, where it has no minimum length but its max length is restrained.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateSpring(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint,System.Single,System.Single)">
            <summary>
            Creates a constraint that will try to stay the same length, like a spring, or a rod.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateHinge(Sandbox.PhysicsBody,Sandbox.PhysicsBody,Vector3,Vector3)">
            <summary>
            Creates a hinge constraint.
            </summary>
            <param name="body1">The source physics body.</param>
            <param name="body2">The target physics body to constrain to.</param>
            <param name="center">The center of the hinge in world coordinates. The 2 bodies will rotate around this point.</param>
            <param name="axis">The axis of the hinge. A normal/unit vector representing a direction.</param>
            <returns>The created hinge.</returns>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateSlider(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint,System.Single,System.Single)">
            <summary>
            Creates a slider constraint between two physics bodies via <see cref="T:Sandbox.Physics.PhysicsPoint"/>s.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateSlider(Sandbox.PhysicsBody,Sandbox.PhysicsBody,Vector3,Vector3,Vector3,System.Single,System.Single)">
            <summary>
            Creates a slider constraint between two physics bodies.
            </summary>
            <param name="body1">The source physics body.</param>
            <param name="body2">The target physics body to constrain to.</param>
            <param name="origin1">A origin in world space</param>
            <param name="origin2">A origin in world space</param>
            <param name="axis">A normal/unit vector representing the directionof the slider.</param>
            <param name="minLength">The minimum length of the slider.</param>
            <param name="maxLength">The maximum length of the slider. If set to the value of <paramref name="minLength"/>, the limit will be disabled.</param>
            <returns>The created slider joint.</returns>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateBallSocket(Sandbox.PhysicsBody,Sandbox.PhysicsBody,Vector3)">
            <summary>
            Creates a ball socket constraint.
            </summary>
            <param name="body1">The source physics body.</param>
            <param name="body2">The target physics body to constrain to.</param>
            <param name="origin">The origin of the hinge in world coordinates. The 2 bodies will rotate around this point.</param>
            <returns>The created ball socket joint.</returns>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreateBallSocket(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint)">
            <summary>
            Creates a ball socket constraint.
            </summary>
            <param name="a">The source physics body.</param>
            <param name="b">The target physics body to constrain to.</param>
            <returns>The created ball socket joint.</returns>
        </member>
        <member name="M:Sandbox.Physics.PhysicsJoint.CreatePulley(Sandbox.PhysicsBody,Sandbox.PhysicsBody,Vector3,Vector3,Vector3,Vector3)">
            <summary>
            Creates a pulley constraint, imagine it as a virtual rope connected to two objects through two anchor points.
            </summary>
            <param name="body1">The source physics body.</param>
            <param name="body2">The target physics body to constrain to.</param>
            <param name="anchor1">Position at the <paramref name="body1"/> to attach at, in world coordinates.</param>
            <param name="ground1">The position of the pulley above <paramref name="body1"/> in world coordinates.</param>
            <param name="anchor2">Position at the <paramref name="body2"/> to attach at, in world coordinates.</param>
            <param name="ground2">The position of the pulley above <paramref name="body2"/> in world coordinates.</param>
            <returns>The created pulley joint.</returns>
        </member>
        <member name="T:Sandbox.Physics.PhysicsPoint">
            <summary>
            Used to describe a point on a physics body. This is used for things like joints where
            you want to pass in just a body, or sometimes you want to pass in a body with a specific
            location and rotation to attach to.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsPoint.Body">
            <summary>
            The physics body this point is attached to.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsPoint.LocalPosition">
            <summary>
            Position offset from the body's position.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsPoint.LocalRotation">
            <summary>
            Rotation offset from the body's position.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsPoint.LocalTransform">
            <summary>
            A transform relative to <see cref="F:Sandbox.Physics.PhysicsPoint.Body"/>, containing <see cref="F:Sandbox.Physics.PhysicsPoint.LocalPosition"/> and <see cref="F:Sandbox.Physics.PhysicsPoint.LocalRotation"/> with scale of 1.
            </summary>
        </member>
        <member name="P:Sandbox.Physics.PhysicsPoint.Transform">
            <summary>
            Transform of this point in world space.
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsPoint.Local(Sandbox.PhysicsBody,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Describe an attachment using a position/rotation local to the body
            </summary>
        </member>
        <member name="M:Sandbox.Physics.PhysicsPoint.World(Sandbox.PhysicsBody,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Describe an attachment using a position/rotation from the world
            </summary>
        </member>
        <member name="T:Sandbox.Physics.PhysicsSpring">
            <summary>
            Spring related settings for joints such as <see cref="T:Sandbox.Physics.FixedJoint"/>.
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsSpring.Frequency">
            <summary>
            The stiffness of the spring
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsSpring.Damping">
            <summary>
            The damping ratio of the spring, usually between 0 and 1
            </summary>
        </member>
        <member name="F:Sandbox.Physics.PhysicsSpring.Maximum">
            <summary>
            For weld joints only, maximum force. Not for breaking.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsBody">
            <summary>
            Represents a physics object. An entity can have multiple physics objects. See <see cref="P:Sandbox.PhysicsBody.PhysicsGroup">PhysicsGroup</see>.
            A physics objects consists of one or more <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
            <summary>
            Represents a physics object. An entity can have multiple physics objects. See <see cref="P:Sandbox.PhysicsBody.PhysicsGroup">PhysicsGroup</see>.
            A physics objects consists of one or more <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GameObject">
            <summary>
            The GameObject that created this body
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Component">
            <summary>
            The component that created this body
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Hitbox">
            <summary>
            The Hitbox that this physics body represents
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Position">
            <summary>
            Position of this body in world coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.World">
            <summary>
            The physics world this body belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Rotation">
            <summary>
            Rotation of the physics body in world space.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Scale">
            <summary>
            Returns the scale of this object. (Most of the time inherited from owning entity's scale)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Velocity">
            <summary>
            Linear velocity of this body in world space.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.AngularVelocity">
            <summary>
            Angular velocity of this body in world space.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.MassCenter">
            <summary>
            Center of mass for this physics body in world space coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.LocalMassCenter">
            <summary>
            Center of mass for this physics body relative to its <see cref="P:Sandbox.PhysicsBody.Position">origin</see>.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Mass">
            <summary>
            Mass of this physics body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GravityEnabled">
            <summary>
            Whether gravity is enabled for this body or not.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableCollisionSounds">
            <summary>
            Whether to play collision sounds 
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GravityScale">
            <summary>
            Scale the gravity relative to <see cref="P:Sandbox.PhysicsWorld.Gravity"/>. 2 is double the gravity, etc.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.UseController">
            <summary>
            If true we'll create a controller for this physics body. This is useful
            for keyframed physics objects that need to push things. The controller will
            sweep as the entity moves, rather than teleporting the object.. which works better
            when pushing dynamic objects etc.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableTouch">
            <summary>
            Enables Touch callbacks on all <see cref="T:Sandbox.PhysicsShape">PhysicsShapes</see> of this body.
            Returns true if ANY of the physics shapes have touch events enabled.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableTouchPersists">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsShape.EnableTouchPersists"/> on all shapes of this body.
            <br/><br/>
            Returns true if ANY of the physics shapes have persistent touch events enabled.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableSolidCollisions">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsShape.EnableSolidCollisions"/> on all shapes of this body.
            <br/><br/>
            Returns true if ANY of the physics shapes have solid collisions enabled.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.BodyType">
            <summary>
            Movement type of physics body, either Static, Keyframed, Dynamic
            Note: If this body is networked and dynamic, it will return Keyframed on the client
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.AutoSleep">
            <summary>
            Whether this body is allowed to automatically go into "sleep" after a certain amount of time of inactivity.
            <see cref="P:Sandbox.PhysicsBody.Sleeping"/> for more info on the sleep mechanic.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Transform">
            <summary>
            Transform of this physics body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.Move(Transform,System.Single)">
            <summary>
            Move to a new position. Unlike Transform, if you have `UseController` enabled, this will sweep the shadow
            to the new position, rather than teleporting there.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.ShapeCount">
            <summary>
            How many shapes belong to this body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Shapes">
            <summary>
            All shapes that belong to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddSphereShape(Vector3,System.Single,System.Boolean)">
            <summary>
            Add a sphere shape to this body.
            </summary>
            <param name="center">Center of the sphere, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="radius">Radius of the sphere.</param>
            <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
            <returns>The newly created shape, if any.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddSphereShape(Sandbox.Sphere@,System.Boolean)">
            <summary>
            Add a sphere shape to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddCapsuleShape(Vector3,Vector3,System.Single,System.Boolean)">
            <summary>
            Add a capsule shape to this body.
            </summary>
            <param name="center">Point A of the capsule, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="center2">Point B of the capsule, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="radius">Radius of the capsule end caps.</param>
            <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
            <returns>The newly created shape, or null on failure.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddBoxShape(Vector3,Rotation,Vector3,System.Boolean)">
            <summary>
            Add a box shape to this body.
            </summary>
            <param name="position">Center of the box, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="rotation">Rotation of the box, relative to <see cref="P:Sandbox.PhysicsBody.Rotation"/> of this body.</param>
            <param name="extent">The extents of the box. The box will extend from its center by this much in both negative and positive directions of each axis.</param>
            <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
            <returns>The newly created shape, or null on failure.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddBoxShape(BBox,Rotation,System.Boolean)">
            <summary>
            Add a box shape to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddHullShape(Vector3,Rotation,System.Collections.Generic.List{Vector3},System.Boolean)">
            <inheritdoc cref="M:Sandbox.PhysicsBody.AddHullShape(Vector3,Rotation,System.Span{Vector3},System.Boolean)"/>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddHullShape(Vector3,Rotation,System.Span{Vector3},System.Boolean)">
            <summary>
            Add a convex hull shape to this body.
            </summary>
            <param name="position">Center of the hull, relative to <see cref="P:Sandbox.PhysicsBody.Position"/> of this body.</param>
            <param name="rotation">Rotation of the hull, relative to <see cref="P:Sandbox.PhysicsBody.Rotation"/> of this body.</param>
            <param name="points">Points for the hull. They will be used to generate a convex shape.</param>
            <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
            <returns>The newly created shape, or null on failure.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddCylinderShape(Vector3,Rotation,System.Single,System.Single,System.Int32)">
            <summary>
            Add a cylinder shape to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddConeShape(Vector3,Rotation,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Add a cone shape to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddMeshShape(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
            <inheritdoc cref="M:Sandbox.PhysicsBody.AddMeshShape(System.Span{Vector3},System.Span{System.Int32})"/>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddMeshShape(System.Span{Vector3},System.Span{System.Int32})">
            <summary>
            Adds a mesh type shape to this physics body. Mesh shapes cannot be physically simulated!
            </summary>
            <param name="vertices">Vertices of the mesh.</param>
            <param name="indices">Indices of the mesh.</param>
            <returns>The created shape, or null on failure.</returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddCloneShape(Sandbox.PhysicsShape)">
            <summary>
            Clones given shape and adds it to this body.
            </summary>
            <param name="shape">The shape to clone.</param>
            <returns>The cloned shape.</returns>
            <exception cref="T:System.ArgumentException">Thrown when given invalid shape.</exception>
        </member>
        <member name="M:Sandbox.PhysicsBody.ClearShapes">
            <summary>
            Remove all physics shapes, but not the physics body itself.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.RemoveShape(Sandbox.PhysicsShape)">
            <summary>
            Called from Shape.Remove()
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.RebuildMass">
            <summary>
            Meant to be only used on <b>dynamic</b> bodies, rebuilds mass from all shapes of this body based on their volume and <see cref="P:Sandbox.PhysicsBody.Surface">physics properties</see>, for cases where they may have changed.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.Remove">
            <summary>
            Completely removes this physics body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyImpulse(Vector3)">
            <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body at its center of mass.
            For continuous force (i.e. a moving car), use <see cref="M:Sandbox.PhysicsBody.ApplyForce(Vector3)"/>
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyImpulseAt(Vector3,Vector3)">
            <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body at given position.
            For continuous force (i.e. a moving car), use <see cref="M:Sandbox.PhysicsBody.ApplyForceAt(Vector3,Vector3)"/>
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyAngularImpulse(Vector3)">
            <summary>
            Applies instant angular impulse (i.e. a bullet impact) to this body.
            For continuous force (i.e. a moving car), use <see cref="M:Sandbox.PhysicsBody.ApplyTorque(Vector3)"/>
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyForce(Vector3)">
            <summary>
            Applies force to this body at the center of mass.
            This force will only be applied on the next physics frame and is scaled with physics timestep.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyForceAt(Vector3,Vector3)">
            <summary>
            Applies force to this body at given position.
            This force will only be applied on the next physics frame and is scaled with physics timestep.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ApplyTorque(Vector3)">
            <summary>
            Applies angular velocity to this body.
            This force will only be applied on the next physics frame and is scaled with physics timestep.
            </summary>
            <param name="force"></param>
        </member>
        <member name="M:Sandbox.PhysicsBody.ClearForces">
            <summary>
            Clear accumulated linear forces (<see cref="M:Sandbox.PhysicsBody.ApplyForce(Vector3)"/> and <see cref="M:Sandbox.PhysicsBody.ApplyForceAt(Vector3,Vector3)"/>) during this physics frame that were not yet applied to the physics body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ClearTorque">
            <summary>
            Clear accumulated torque (angular force, <see cref="M:Sandbox.PhysicsBody.ApplyTorque(Vector3)"/>) during this physics frame that were not yet applied to the physics body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.GetVelocityAtPoint(Vector3)">
            <summary>
            Returns the world space velocity of a point of the object. This is useful for objects rotating around their own axis/origin.
            </summary>
            <param name="point">The point to test, in world coordinates.</param>
            <returns>Velocity at the given point.</returns>
        </member>
        <member name="P:Sandbox.PhysicsBody.Enabled">
            <summary>
            Whether this body is enabled or not. Disables collisions, physics simulation, touch events, trace queries, etc.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.MotionEnabled">
            <summary>
            Controls physics simulation on this body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Sleeping">
            <summary>
            Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            You can use this to wake the body up, or prematurely send it to sleep.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.SpeculativeContactEnabled">
            <summary>
            If enabled, this physics body will move slightly ahead each frame based on its velocities.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Parent">
            <summary>
            The physics body we are attached to, if any
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.SelfOrParent">
            <summary>
            A convenience property, returns <see cref="P:Sandbox.PhysicsBody.Parent">Parent</see>, or if there is no parent, returns itself.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.PhysicsGroup">
            <summary>
            The physics group we belong to.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.FindClosestPoint(Vector3)">
            <summary>
            Returns the closest point to the given one between all convex shapes of this body.
            </summary>
            <param name="vec">Input position.</param>
            <returns>The closest possible position on the surface of the physics body to the given position.</returns>
        </member>
        <member name="P:Sandbox.PhysicsBody.LinearDamping">
            <summary>
            Generic linear damping, i.e. how much the physics body will slow down on its own.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.AngularDamping">
            <summary>
            Generic angular damping, i.e. how much the physics body will slow down on its own.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.LinearDrag">
            <summary>
            Amount of air drag to be applied to linear movement (i.e. not rotational movement). Default is 1.
            This should take into account object's rotation and surface area in direction of movement, unlike <see cref="P:Sandbox.PhysicsBody.LinearDamping"/>.
            See <see cref="P:Sandbox.PhysicsWorld.AirDensity"/> and <see cref="P:Sandbox.PhysicsBody.DragEnabled"/>.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.AngularDrag">
            <summary>
            Amount of air drag to be applied to angular movement/rotation. Default is 1.
            This should take into account object's rotation and surface area in direction of rotation, unlike <see cref="P:Sandbox.PhysicsBody.AngularDamping"/>.
            See <see cref="P:Sandbox.PhysicsWorld.AirDensity"/> and <see cref="P:Sandbox.PhysicsBody.DragEnabled"/>.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.DragEnabled">
            <summary>
            Whether air drag forces are enabled for this body.
            See <see cref="P:Sandbox.PhysicsWorld.AirDensity"/>, <see cref="P:Sandbox.PhysicsBody.AngularDrag"/> and <see cref="P:Sandbox.PhysicsBody.LinearDrag"/>.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Inertia">
            <summary>
            The diagonal elements of the inertia tensor matrix.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.InertiaRotation">
            <summary>
            The orientation of the principal axes of inertia tensor matrix.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.GetBounds">
            <summary>
            Returns Axis-Aligned Bounding Box (AABB) of this physics body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Density">
            <summary>
            Returns average of densities for all physics shapes of this body. This is based on <see cref="P:Sandbox.PhysicsShape.SurfaceMaterial"/> of each shape.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.LastWaterEffect">
            <summary>
            Time since last water splash effect. Used internally.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.SurfaceMaterial">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsShape.SurfaceMaterial"/> on all child <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
            <returns>
            The most commonly occurring surface name between all <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s of this <see cref="T:Sandbox.PhysicsShape">PhysicsBody</see>.
            </returns>
        </member>
        <member name="M:Sandbox.PhysicsBody.LocalPoint(Vector3)">
            <summary>
            Convenience function that returns a <see cref="T:Sandbox.Physics.PhysicsPoint"/> from a position relative to this body.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.WorldPoint(Vector3)">
            <summary>
            Convenience function that returns a <see cref="T:Sandbox.Physics.PhysicsPoint"/> for this body from a world space position.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.MassCenterPoint">
            <summary>
            Returns a <see cref="T:Sandbox.Physics.PhysicsPoint"/> at the center of mass of this body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GroupName">
            <summary>
            What is this body called in the group?
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GroupIndex">
            <summary>
            Return the index of this body in its PhysicsGroup
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.CheckOverlap(Sandbox.PhysicsBody)">
            <summary>
            Checks if another body overlaps us, ignoring all collision rules
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.CheckOverlap(Sandbox.PhysicsBody,Transform)">
            <summary>
            Checks if another body overlaps us at a given transform, ignoring all collision rules
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddShape(Sandbox.PhysicsGroupDescription.BodyPart.HullPart,Transform,System.Boolean)">
            <summary>
            Add a shape from a physics hull
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.AddShape(Sandbox.PhysicsGroupDescription.BodyPart.MeshPart,Transform,System.Boolean,System.Boolean)">
            <summary>
            Add a shape from a mesh hull
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBody.prevStepTransform">
            <summary>
            Transform, on previous step
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBody.stepTransform">
            <summary>
            Transform on current step
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.OnActive(Transform@,Vector3@,Vector3@)">
            <summary>
            Called on each active body after a "step"
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.GetLerpedTransform(System.Single)">
            <summary>
            When the physics world is run at a fixed timestep, getting the positions of bodies will not be smooth.
            You can use this function to get the lerped position between steps, to make things super awesome.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.SmoothMove(Vector3@,System.Single,System.Single)">
            <summary>
            Move body to this position in a way that cooperates with the physics system. This is quite
            good for things like grabbing and moving objects.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.SmoothMove(Transform@,System.Single,System.Single)">
            <summary>
            Move body to this position in a way that cooperates with the physics system. This is quite
            good for things like grabbing and moving objects.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.SmoothRotate(Rotation@,System.Single,System.Single)">
            <summary>
            Rotate the body to this position in a way that cooperates with the physics system.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsBody.OnDirty">
            <summary>
            Called when anything significant changed about this physics object. Like its position,
            or its enabled status.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsGroup">
            <summary>
            Represents a set of <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> objects. Think ragdoll.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.World">
            <summary>
            The world in which this group belongs
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Pos">
            <summary>
            Returns position of the first physics body of this group, or zero vector if it has none.
            </summary>
            <remarks>
            TODO: How useful is this in its current form? Should it be removed, or at least renamed to Position?
            </remarks>
        </member>
        <member name="P:Sandbox.PhysicsGroup.MassCenter">
            <summary>
            Returns the center of mass for this group of physics bodies.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.AddVelocity(Vector3)">
            <summary>
            Adds given amount of velocity (<see cref="M:Sandbox.PhysicsBody.ApplyForce(Vector3)"/>) to all physics bodies in this group.
            </summary>
            <param name="vel">How much linear force to add?</param>
        </member>
        <member name="M:Sandbox.PhysicsGroup.AddAngularVelocity(Vector3)">
            <summary>
            Adds given amount of angular velocity to all physics bodies in this group.
            </summary>
            <param name="vel">How much angular force to add?</param>
        </member>
        <member name="M:Sandbox.PhysicsGroup.ApplyImpulse(Vector3,System.Boolean)">
            <summary>
            Adds given amount of linear impulse (<see cref="M:Sandbox.PhysicsBody.ApplyImpulse(Vector3)"/>) to all physics bodies in this group.
            </summary>
            <param name="vel">Velocity to apply.</param>
            <param name="withMass">Whether to multiply the velocity by mass of the <see cref="T:Sandbox.PhysicsBody"/> on a per-body basis.</param>
        </member>
        <member name="M:Sandbox.PhysicsGroup.ApplyAngularImpulse(Vector3,System.Boolean)">
            <summary>
            Adds given amount of angular linear impulse (<see cref="M:Sandbox.PhysicsBody.ApplyAngularImpulse(Vector3)"/>) to all physics bodies in this group.
            </summary>
            <param name="vel">Angular velocity to apply.</param>
            <param name="withMass">Whether to multiply the velocity by mass of the <see cref="T:Sandbox.PhysicsBody"/> on a per-body basis.</param>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Velocity">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.Velocity"/> on all bodies of this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.AngularVelocity">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.AngularVelocity"/> on all bodies of this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Sleeping">
            <summary>
            Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            You can use this to wake the body up, or prematurely send it to sleep.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.RebuildMass">
            <summary>
            Calls <see cref="M:Sandbox.PhysicsBody.RebuildMass"/> on all bodies of this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Mass">
            <summary>
            The total mass of all the <b>dynamic</b> <see cref="T:Sandbox.PhysicsBody">PhysicsBodies</see> in this group.
            When setting the total mass, it will be set on each body proportionally to each of their old masses,
            i.e. if a body had 25% of previous total mass, it will have 25% of new total mass.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.LinearDamping">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.LinearDamping"/> on all bodies in this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.AngularDamping">
            <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.AngularDamping"/> on all bodies in this group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Bodies">
            <summary>
            Returns all physics bodies that belong to this physics group.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.BodyCount">
            <summary>
            Returns amount of physics bodies that belong to this physics group.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.GetBody(System.Int32)">
            <summary>
            Gets a <see cref="T:Sandbox.PhysicsBody"/> at given index within this physics group. See <see cref="P:Sandbox.PhysicsGroup.BodyCount"/>.
            </summary>
            <param name="groupIndex">Index for the body to look up, in range from 0 to <see cref="P:Sandbox.PhysicsGroup.BodyCount"/>.</param>
        </member>
        <member name="M:Sandbox.PhysicsGroup.GetBody(System.String)">
            <summary>
            Returns a <see cref="T:Sandbox.PhysicsBody"/> by its <see cref="P:Sandbox.PhysicsBody.GroupName"/> within this group.
            </summary>
            <param name="groupName">Name of the physics body to look up.</param>
            <returns>The physics body, or null if body with given name is not found.</returns>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Joints">
            <summary>
            Any and all joints that are attached to any body in this group.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.SetSurface(System.String)">
            <summary>
            Sets the physical properties of each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of this group.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.Remove">
            <summary>
            Delete this group, and all of its bodies
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsShape">
            <summary>
            Represents a basic, convex shape. A <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> consists of one or more of these.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Body">
            <summary>
            The physics body we belong to.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Scale">
            <summary>
            Returns the scale of this object. (Most of the time inherited from owning entity's scale)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Collider">
            <summary>
            The collider object that created / owns this shape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsTrigger">
            <summary>
            This is a trigger (!)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.EnableAllCollision">
            <summary>
            Enable contact, trace and touch
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.DisableAllCollision">
            <summary>
            Disable contact, trace and touch
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.EnableSolidCollisions">
            <summary>
            Controls whether this shape has solid collisions.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.EnableTouch">
            <summary>
            Controls whether this shape can fire touch events for its owning entity. (Entity.StartTouch, Touch and EndTouch)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.EnableTouchPersists">
            <summary>
            Controls whether this shape can fire continuous touch events for its owning entity (i.e. calling Entity.Touch every frame)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsMeshShape">
            <summary>
            Is this a MeshShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsHullShape">
            <summary>
            Is this a HullShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsSphereShape">
            <summary>
            Is this a SphereShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsCapsuleShape">
            <summary>
            Is this a CapsuleShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsHeightfieldShape">
            <summary>
            Is this a HeightfieldShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Sphere">
            <summary>
            Get sphere properties if we're a sphere type
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Capsule">
            <summary>
            Get capsule properties if we're a capsule type
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
            <summary>
            Recreate the collision mesh (Only if this physics shape is type Mesh)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Span{Vector3},System.Span{System.Int32})">
            <summary>
            Recreate the mesh of the shape (Only if this physics shape is type Mesh)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateHull(Vector3,Rotation,System.Span{Vector3})">
            <summary>
            Recreate the hull of the shape (Only if this physics shape is type Hull)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.SurfaceMaterial">
            <summary>
            Controls physical properties of this shape.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Surfaces">
            <summary>
            Multiple surfaces referenced by mesh or heightfield collision.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.Remove">
            <summary>
            Remove this shape. After calling this the shape should be considered released and not used again.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.Triangulate(Vector3[]@,System.UInt32[]@)">
            <summary>
            Triangulate this shape.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.HasTag(System.String)">
            <summary>
            Does this shape have a specific tag?
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.AddTag(System.String)">
            <summary>
            Add a tag to this shape.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.RemoveTag(System.String)">
            <summary>
            Remove a tag from this shape.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.ClearTags">
            <summary>
            Clear all tags from this shape.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceBuilder.filterCallback">
            <summary>
            Do not expose! We want to force this whole thing into as tight of a box as possible!
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Sphere(System.Single,Vector3@,Vector3@)">
            <summary>
            Casts a sphere from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Sphere(System.Single,Ray@,System.Single@)">
            <summary>
            Casts a sphere from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Box(Vector3,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Box(Vector3,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Box(BBox,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Box(BBox,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Capsule(Capsule)">
            <summary>
            Casts a capsule
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Capsule(Capsule,Vector3@,Vector3@)">
            <summary>
            Casts a capsule from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Capsule(Capsule,Ray@,System.Single@)">
            <summary>
            Casts a capsule from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Ray(Vector3@,Vector3@)">
            <summary>
            Casts a ray from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Ray(Ray@,System.Single@)">
            <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Body(Sandbox.PhysicsBody,Vector3@)">
            <summary>
            Casts a PhysicsBody from its current position and rotation to desired end point.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Body(Sandbox.PhysicsBody,Transform@,Vector3@)">
            <summary>
            Casts a PhysicsBody from a position and rotation to desired end point.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Sweep(Sandbox.PhysicsBody@,Transform@,Transform@)">
            <summary>
            Sweeps each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of given PhysicsBody and returns the closest collision. Does not support Mesh PhysicsShapes.
            Basically 'hull traces' but with physics shapes.
            Same as tracing a body but allows rotation to change during the sweep.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Sweep(Sandbox.PhysicsBody@,Transform@)">
            <summary>
            Creates a Trace.Sweep using the <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see>'s position as the starting position.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.FromTo(Vector3@,Vector3@)">
            <summary>
            Sets the start and end positions of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.FromTo(Transform@,Vector3@)">
            <summary>
            Sets the start transform and end position of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.HitTriggers">
            <summary>
            Include triggers in the trace
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.HitTriggersOnly">
            <summary>
            Only hit triggers
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.IgnoreStatic">
            <summary>
            Ignore static objects in the trace
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.IgnoreDynamic">
            <summary>
            Ignore dynamic objects in the trace
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.IgnoreKeyframed">
            <summary>
            Ignore keyframed objects in the trace
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Size(BBox@)">
            <summary>
            Makes this trace an axis aligned box of given size. Extracts mins and maxs from the Bounding Box.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Size(Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size. Calculates mins and maxs by assuming given size is (maxs-mins) and the center is in the middle.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Size(Vector3@,Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Radius(System.Single)">
            <summary>
            Makes this trace a sphere of given radius.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.Run">
            <summary>
            Run the trace and return the result. The result will return the first hit.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.RunAll">
            <summary>
            Run the trace and return all hits as a result.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithTag(System.String)">
            <summary>
            Only return entities with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the entity will need all tags).
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithAllTags(System.String[])">
            <summary>
            Only return with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithAllTags(Sandbox.ITagSet)">
            <summary>
            Only return with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithAnyTags(System.String[])">
            <summary>
            Only return entities with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithAnyTags(Sandbox.ITagSet)">
            <summary>
            Only return with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithoutTag(System.String)">
            <summary>
            Only return with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithoutTags(System.String[])">
            <summary>
            Only return without any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithoutTags(Sandbox.ITagSet)">
            <summary>
            Only return without any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithCollisionRules(System.String,System.Boolean)">
            <summary>
            Use the collision rules of the given tag.
            </summary>
            <param name="tag">Which tag this trace will adopt the collision rules of.</param>
            <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
        </member>
        <member name="M:Sandbox.PhysicsTraceBuilder.WithCollisionRules(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Use the collision rules for the given set of tags.
            </summary>
            <param name="tags">Which tags this trace will adopt the collision rules of.</param>
            <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Hit">
            <summary>
            Whether the trace hit something or not
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.StartedSolid">
            <summary>
            Whether the trace started in a solid
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.StartPosition">
            <summary>
            The start position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.EndPosition">
            <summary>
            The end or hit position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.HitPosition">
            <summary>
            The hit position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Normal">
            <summary>
            The hit surface normal (direction vector)
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Fraction">
            <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Body">
            <summary>
            The physics object that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Shape">
            <summary>
            The physics shape that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Surface">
            <summary>
            The physical properties of the hit surface
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Bone">
            <summary>
            The id of the hit bone (either from hitbox or physics shape)
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Direction">
            <summary>
            The direction of the trace ray
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Triangle">
            <summary>
            The triangle index hit, if we hit a mesh <see cref="T:Sandbox.PhysicsShape">physics shape</see>
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsTraceResult.Tags">
            <summary>
            The tags that the hit shape had
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsTraceResult.Distance">
            <summary>
            The distance between start and end positions.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsSimulationMode">
            <summary>
            Physics simulation mode. For use with <see cref="P:Sandbox.PhysicsWorld.SimulationMode"/>.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsSimulationMode.Discrete">
            <summary>
            Discrete collision detection.
            In this mode physics bodies can fly through thin walls when moving very quickly, but it is has better performance.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsSimulationMode.Continuous">
            <summary>
            Continuous collision detection. This is the default mode.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsWorld">
            <summary>
            A world in which physics objects exist. You can create your own world but you really don't need to. A world for the map is created clientside and serverside automatically.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Bodies">
            <summary>
            All bodies in the world
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.CollisionRules">
            <summary>
            Set or retrieve the collision rules for this <see cref="T:Sandbox.PhysicsWorld"/>.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.#ctor">
            <summary>
            Create a new physics world. You should only do this if you want to simulate an extra world for some reason.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.SetupPhysicsFromModel(Sandbox.Model,Sandbox.PhysicsMotionType)">
            <summary>
            Temp function for creating model physics until entity system handles it
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.SetupPhysicsFromModel(Sandbox.Model,Transform,Sandbox.PhysicsMotionType)">
            <summary>
            Temp function for creating model physics until entity system handles it
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.Delete">
            <summary>
            Delete this world and all objects inside. Will throw an exception if you try to delete a world that you didn't manually create.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.Step(System.Single)">
            <summary>
            Step simulation of this physics world. You can only do this on physics worlds that you manually create.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.Step(System.Single,System.Int32)">
            <summary>
            Step simulation of this physics world. You can only do this on physics worlds that you manually create.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.Step(System.Single,System.Single,System.Int32)">
            <summary>
            Step simulation of this physics world. You can only do this on physics worlds that you manually create.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.DebugSceneWorld">
            <summary>
            A SceneWorld where debug SceneObjects exist.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.DebugDraw">
            <summary>
            Updates all the SceneObjects in the <see cref="P:Sandbox.PhysicsWorld.DebugSceneWorld"/>, call once per tick or frame.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Gravity">
            <summary>
            Access the world's current gravity.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.AirDensity">
            <summary>
            Air density of this physics world, for things like air drag.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Body">
            <summary>
            The body of this physics world.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Group">
            <summary>
            The physics group of this physics world. A physics world will contain only 1 body.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.SleepingEnabled">
            <summary>
            If true then bodies will be able to sleep after a period of inactivity
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.SimulationMode">
            <summary>
            Physics simulation mode. See <see cref="T:Sandbox.PhysicsSimulationMode"/> for explanation of each mode.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.PositionIterations">
            <summary>
            Used for constraints (joints). Higher values should result in more accurate simulation (TODO: Confirm this)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.VelocityIterations">
            <summary>
            Used for constraints (joints). Higher values should result in more accurate simulation (TODO: Confirm this)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.SubSteps">
            <summary>
            If you're seeing objects go through other objects or you have a low tickrate, you might want to increase the number of physics substeps.
            This breaks physics steps down into this many substeps. The default is 1 and works pretty good.
            Be aware that the number of physics ticks per second is going to be tickrate * substeps.
            So if you're ticking at 90 and you have SubSteps set to 1000 then you're going to do 90,000 steps per second. So be careful here.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.TimeScale">
            <summary>
            Physics time scale. 0.5 is half speed, 1 is full speed, etc.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.SetCollisionRules(Sandbox.Physics.CollisionRules)">
            <summary>
            Used internally to set collision rules from gamemode's project settings.
            You shouldn't need to call this yourself.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.GetCollisionRule(System.String,System.String)">
            <summary>
            Gets the specific collision rule for a pair of tags.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsWorld.Trace">
            <summary>
            Raytrace against this world
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsWorld.RunTrace(Sandbox.PhysicsTraceBuilder@)">
            <summary>
            Like calling PhysicsTraceBuilder.Run, except will re-target this world if it's not already the target
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Duration">
            <summary>
            The duration of the currently playing sequence (seconds)
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.IsFinished">
            <summary>
            Get whether the current animation sequence has finished
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Name">
            <summary>
            The name of the currently playing animation sequence
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.TimeNormalized">
            <summary>
            The normalized (between 0 and 1) elapsed time of the currently playing
            animation sequence
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Time">
            <summary>
            The elapsed time of the currently playing animation sequence (seconds)
            </summary>
        </member>
        <member name="T:Sandbox.AnimGraphDirectPlayback">
            <summary>
            For communicating with a Direct Playback Anim Node, which allows code to tell it to play a given sequence
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.StartTime">
            <summary>
            Set the time at which the currently playing sequence should have had a cycle of zero.
            This will adjust the current cycle of the sequence to match.
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.TimeNormalized">
            <summary>
            Get the cycle of the currently playing sequence.  Will return 0 if no sequence is playing.
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.Duration">
            <summary>
            The duration of the currently playing sequence (seconds)
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.Time">
            <summary>
            The elapsed time of the currently playing animation sequence (seconds)
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.Name">
            <summary>
            Returns the currently playing sequence.
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.AnimationCount">
            <summary>
            Get the number of animations that can be used.
            </summary>
        </member>
        <member name="P:Sandbox.AnimGraphDirectPlayback.Animations">
            <summary>
            Get the list of animations that can be used.
            </summary>
        </member>
        <member name="M:Sandbox.AnimGraphDirectPlayback.Play(System.String)">
            <summary>
            Play the given sequence until it ends, then blend back.
            Calling this function with a new sequence while another one is playing will immediately start blending from the old one to the new one.  
            </summary>
        </member>
        <member name="M:Sandbox.AnimGraphDirectPlayback.Play(System.String,Vector3,System.Single,System.Single)">
            <summary>
            Same as the other Play function, but also sets a target position and heading for the sequence.
            Over interpTime seconds, the entity's root motion will be augmented to move it to target and rotate it to heading. 
            </summary>
        </member>
        <member name="M:Sandbox.AnimGraphDirectPlayback.Cancel">
            <summary>
            Stop playing the override sequence.
            </summary>
        </member>
        <member name="F:Sandbox.ComputeBufferType.Structured">
            <summary>
            Structured Buffer (HLSL RWStructuredBuffer)
            </summary>
        </member>
        <member name="F:Sandbox.ComputeBufferType.ByteAddress">
            <summary>
            Byte Address Buffer (HLSL RWByteAddressBuffer)
            </summary>
        </member>
        <member name="F:Sandbox.ComputeBufferType.Append">
            <summary>
            Append Structured Buffer (HLSL AppendStructuredBuffer)
            </summary>
        </member>
        <member name="T:Sandbox.ComputeBuffer`1">
             <summary>
             A GPU data buffer intended for use with a <see cref="T:Sandbox.ComputeShader"/>.
             
             You can read and write arbitrary data to and from the CPU and GPU.
             This allows for efficient parallel data processing on the GPU.
             
             Different GPU buffer types can be used depending on the provided <see cref="T:Sandbox.ComputeBufferType"/>.
             Using the default <see cref="F:Sandbox.ComputeBufferType.Structured"/> type buffers map to StructuredBuffer&lt;T&gt; and RWStructuredBuffer&lt;T&gt; in HLSL.
             </summary>
            
             <typeparam name="T">
             The type of data that the ComputeBuffer will store.
             Must be a <see href="https://docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types">blittable</see> value type.
             </typeparam>
            
             <example>
             This example shows how to use the ComputeBuffer class to send data to a compute shader:
             <code>
             struct MyData
             {
                 public float Value;
             }
             
             // Allocate the GPU buffer
             using (var buffer = new ComputeBuffer&lt;MyData&gt;( 2 ))
             {
            		// Upload data to the GPU buffer
            		var data = new MyData[] { new MyData { Value = 1.0f }, new MyData { Value = 2.0f } };
            		buffer.SetData( data );
             
                 // Pass the buffer to a compute shader
                 ComputeShader.Attributes.Set( "myData", buffer );
                 
                 // Dispatch the shader
                 ComputeShader.Dispatch();
             }
             </code>
             </example>
             
             <example>
             This example shows how to retrieve data from a GPU using the ComputeBuffer class:
             <code>
             struct MyData
             {
                 public float Value;
             }
             
             using (var buffer = new ComputeBuffer&lt;MyData&gt;( 8 ))
             {
                 // Pass the buffer to a compute shader
                 ComputeShader.Attributes.Set( "myData", buffer );
                 
                 // Dispatch the shader
                 ComputeShader.Dispatch();
                 
            		// Retrieve the data from the GPU
            		var data = new MyData[ 8 ];
            		buffer.GetData( data, 0, 8 );
             }
             </code>
             </example>
            
             <seealso cref="T:Sandbox.ComputeShader"/>
             <seealso cref="M:Sandbox.RenderAttributes.Set``1(Sandbox.StringToken@,Sandbox.ComputeBuffer{``0}@)"/>
        </member>
        <member name="M:Sandbox.ComputeBuffer`1.#ctor(System.Int32,Sandbox.ComputeBufferType)">
            <summary>
            Creates a new GPU buffer with a specified number of elements and a specific buffer type.
            </summary>
            <param name="elementCount">The total number of elements that the ComputeBuffer can hold. This represents the buffer's size in terms of elements, not bytes.</param>
            <param name="type">Defines the usage pattern of the GPU buffer. This can affect performance depending on how the buffer is utilized. Default is ComputeBufferType.Structured, indicating a buffer that supports read and write operations in a shader.</param>
        </member>
        <member name="M:Sandbox.ComputeBuffer`1.Dispose">
            <summary>
            Destroys the GPU buffer, don't use it no more
            </summary>
        </member>
        <member name="M:Sandbox.ComputeBuffer`1.GetData(System.Span{`0})">
            <summary>
            Retrieves the GPU buffer and copies them into a provided Span.
            </summary>
            <remarks>
            This operation is synchronous and will block until the data has been fully downloaded from the GPU.
            </remarks>
            <param name="data">A Span of type T which the GPU buffer's contents will be copied into.</param>
        </member>
        <member name="M:Sandbox.ComputeBuffer`1.GetData(System.Span{`0},System.Int32,System.Int32)">
            <summary>
            Retrieves a number of elements from the GPU buffer and copies them into a provided Span.
            </summary>
            <remarks>
            This operation is synchronous and will block until the specified range of data has been fully downloaded from the GPU.
            </remarks>
            <param name="data">A Span of type T which the GPU buffer's contents will be copied into.</param>
            <param name="start">The starting index from which to begin retrieving data. This index is in terms of elements, not bytes.</param>
            <param name="count">The number of elements to retrieve from the GPU buffer. This count is also in terms of elements, not bytes.</param>
        </member>
        <member name="M:Sandbox.ComputeBuffer`1.SetData(System.Collections.Generic.List{`0},System.Int32)">
            <summary>
            Synchronously uploads data from a List to the GPU, replacing the existing data in this ComputeBuffer.
            </summary>
            <remarks>
            This operation is synchronous; it will block until the data has been fully uploaded to the GPU.
            </remarks>
            <param name="data">The List of data to upload. It should contain items of type T, which is a struct.</param>
            <param name="elementOffset">The offset in terms of elements (not bytes) at which to start uploading data (default is 0).</param>
        </member>
        <member name="M:Sandbox.ComputeBuffer`1.SetData(System.Span{`0},System.Int32)">
            <summary>
            Synchronously uploads data from a Span to the GPU, replacing the existing data in this ComputeBuffer.
            </summary>
            <remarks>
            This operation is synchronous; it will block until the data has been fully uploaded to the GPU.
            </remarks>
            <param name="data">The Span of data to upload. It should contain items of type T, which is a struct.</param>
            <param name="elementOffset">The offset in terms of elements (not bytes) at which to start uploading data (default is 0).</param>
        </member>
        <member name="M:Sandbox.ComputeBuffer`1.CopyStructureCount``1(Sandbox.ComputeBuffer{``0},System.Int32)">
            <summary>
            For <see cref="F:Sandbox.ComputeBufferType.Append"/> buffers there is a hidden uint 32-bit atomic counter in the buffer that contains the number of 
            writes to the buffer after invocation of the compute shader.  In order to get the value of the counter, the data needs to be copied to
            another GPU buffer that can be used.
            </summary>
        </member>
        <member name="T:Sandbox.ComputeShader">
            <summary>
            A compute shader is a program that runs on the GPU, often with data provided to/from the CPU by means of a <see cref="T:Sandbox.ComputeBuffer`1"/> or a <see cref="T:Sandbox.Texture"/>.
            </summary>
            <seealso cref="T:Sandbox.ComputeBuffer`1"/>
        </member>
        <member name="P:Sandbox.ComputeShader.Attributes">
            <summary>
            Attributes that are passed to the compute shader on dispatch.
            </summary>
        </member>
        <member name="M:Sandbox.ComputeShader.#ctor(System.String)">
            <summary>
            Create a compute shader from the specified path.
            </summary>
        </member>
        <member name="M:Sandbox.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32)">
            <summary>
            Dispatch this compute shader. This can be called outside of a graphics context.
            </summary>
            <remarks>
            Internally it will divide by the thread group size to get the thread group count to dispatch.
            </remarks>
        </member>
        <member name="T:Sandbox.Graphics">
            <summary>
            Used to render to the screen using your Graphics Card, or whatever you
            kids are using in your crazy future computers. Whatever it is I'm sure
            it isn't fungible and everyone has free money and no-one has to ever work.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.IsActive">
            <summary>
            If true then we're currently rendering and
            you are safe to use the contents of this class
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.LayerType">
            <summary>
            The current layer type. This is useful to tell whether you're meant to be drawing opaque, transparent or shadow. You mainly
            don't need to think about this, but when you do, it's here.
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.grabbedTextures">
            <summary>
            When Frame grabbing, we store the result in this pooled render target. It stays checked out
            until the end of this render scope.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.Viewport">
            <summary>
            In pixel size, where are we rendering to?
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.Attributes">
            <summary>
            Access to the current render context's attributes. These will be used
            to set attributes in materials/shaders.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.CameraPosition">
            <summary>
            The camera position of the currently rendering view
            </summary>
        </member>
        <member name="T:Sandbox.Graphics.Scope">
            <summary>
            Creates a scope where Graphics is safe to use.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.SetupLighting(Sandbox.SceneObject,Sandbox.RenderAttributes)">
            <summary>
            Setup the lighting attributes for this current object. Place them in the targetAttributes
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.GrabFrameTexture(System.String,Sandbox.RenderAttributes,System.Boolean)">
            <summary>
            Grabs the current viewport's color texture and stores it in targetName on renderAttributes.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.GrabDepthTexture(System.String,Sandbox.RenderAttributes,System.Boolean)">
            <summary>
            Grabs the current depth texture and stores it in targetName on renderAttributes.
            </summary>
        </member>
        <member name="P:Sandbox.Graphics.RenderTarget">
            <summary>
            Get or set the current render target. Setting this will bind the render target and change the viewport to match it.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Clear(Color,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Clear the current drawing context to given color.
            </summary>
            <param name="color">Color to clear to.</param>
            <param name="clearColor">Whether to clear the color buffer at all.</param>
            <param name="clearDepth">Whether to clear the depth buffer.</param>
            <param name="clearStencil">Whether to clear the stencil buffer.</param>
        </member>
        <member name="M:Sandbox.Graphics.Clear(System.Boolean,System.Boolean)">
            <summary>
            Clear the current drawing context to given color.
            </summary>
            <param name="clearColor">Whether to clear the color buffer to transparent color.</param>
            <param name="clearDepth">Whether to clear the depth buffer.</param>
        </member>
        <member name="M:Sandbox.Graphics.RenderToTexture(Sandbox.SceneCamera,Sandbox.Texture)">
            <summary>
            Render this camera to the specified texture target
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.CopyTexture(Sandbox.Texture,Sandbox.Texture)">
            <summary>
            Copies pixel data from one texture to another on the GPU.
            This does not automatically resize or scale the texture, format and size should be equal.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.CopyTexture(Sandbox.Texture,Sandbox.Texture,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies pixel data from one texture to another on the GPU.
            This does not automatically resize or scale the texture, format and size should be equal.
            This one lets you copy to/from arrays / specific mips.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawInternal``1(``0*,System.Int32,System.UInt16*,System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            This is our entry point into the engine for all draws
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw(System.Span{Sandbox.Vertex},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw``1(System.Span{``0},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            TODO: make this public
            TODO: Is this safe to be public
            TODO: Is VertexLayoutManager.Get Safe 
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw(System.Collections.Generic.List{Sandbox.Vertex},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw``1(System.Collections.Generic.List{``0},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            TODO: make this public
            TODO: Is this safe to be public
            TODO: Is VertexLayoutManager.Get Safe 
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Draw(System.Span{Sandbox.Vertex},System.Int32,System.Span{System.UInt16},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
            <summary>
            Draw a bunch of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Blit(Sandbox.Material,Sandbox.RenderAttributes)">
            <summary>
            Draw a screen space quad using the passed material. Your material should be using a
            screenspace shader so it will actually render to the screen and not in worldspace at 0,0,0
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.Render(Sandbox.SceneObject,System.Nullable{Transform},System.Nullable{Color},Sandbox.Material)">
            <summary>
            Render a SceneObject
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawQuad(Sandbox.Rect@,Sandbox.Material@,Color@,Sandbox.RenderAttributes)">
            <summary>
            Draw a quad in screenspace
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawQuad(Sandbox.Rect@,System.Single@,Sandbox.Material@,Color@,Sandbox.RenderAttributes)">
            <summary>
            Draw a rotated quad in screenspace
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawText(Sandbox.Rect@,System.String,Color,System.String,System.Single,System.Single,Sandbox.TextFlag)">
            <summary>
            Draws a text quad in screenspace using the Material.UI.Text material.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawText(Sandbox.Rect@,Sandbox.TextRendering.Scope@,Sandbox.TextFlag)">
            <summary>
            Draws a text quad in screenspace using the Material.UI.Text material.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawText(Sandbox.Rect@,System.Single,Sandbox.TextRendering.Scope@,Sandbox.TextFlag)">
            <summary>
            Draws a rotated text quad in screenspace using the Material.UI.Text material.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawText(Vector2@,System.String,Color,System.String,System.Single,System.Single)">
            <summary>
            Draws a text quad in screenspace using the Material.UI.Text material.
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.MeasureText(Sandbox.Rect@,System.String,System.String,System.Single,System.Single,Sandbox.TextFlag)">
            <summary>
            Measure how big some text will be, without having to render it
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.MeasureText(Sandbox.Rect@,Sandbox.TextRendering.Scope@,Sandbox.TextFlag)">
            <summary>
            Measure how big some text will be, without having to render it
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawIcon(Sandbox.Rect,System.String,Color,System.Single,Sandbox.TextFlag)">
            <summary>
            Calls DrawText with "Material Icons" font. You can get a list of icons here https://fonts.google.com/icons?selected=Material+Icons
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.DrawRoundedRectangle(Sandbox.Rect@,Color@,Vector4@,Vector4@,Color@)">
            <summary>
            Draw a rounded rectangle, with optional border, in Material.UI.Box
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.OnLayer(System.Int32,ManagedRenderSetup_t)">
            <summary>
            Called by the engine during pipeline. This could be rendering the scene from any camera.
            That means you can't assume this is the game view. This might be a tools view, or another view
            </summary>
        </member>
        <member name="T:Sandbox.Graphics.DownsampleMethod">
            <summary>
            Which method to use when downsampling a texture
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.Box">
            <summary>
            Uses a box filter to downsample the texture
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.GaussianBlur">
            <summary>
            Uses a gaussian filter to downsample the texture
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.GGX">
            <summary>
            Downsamples the texture using GGX normal distribution function, suitable for using with PBR materials
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.Max">
            <summary>
            Downsamples the texture using a max operator filter ( brightest pixel )
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.Min">
            <summary>
            Downsamples the texture using a min operator filter ( darkest pixel )
            </summary>
        </member>
        <member name="F:Sandbox.Graphics.DownsampleMethod.MinMax">
            <summary>
            Downsamples the texture in red and green channels using a Min/Max filter ( darkest and brightest pixel )
            </summary>
        </member>
        <member name="M:Sandbox.Graphics.GenerateMipMaps(Sandbox.Texture,Sandbox.Graphics.DownsampleMethod,System.Int32,System.Int32)">
            <summary>
            Generate the mip maps for this texture. Obviously the texture needs to support mip maps.
            </summary>
        </member>
        <member name="T:Sandbox.MorphCollection">
            <summary>
            Used to access and manipulate morphs.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.ResetAll">
            <summary>
            Reset all morphs to their default values.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Reset(System.Int32)">
            <summary>
            Reset morph number i to its default value.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Reset(System.String)">
            <summary>
            Reset named morph to its default value.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Set(System.Int32,System.Single)">
            <summary>
            Set indexed morph to this value.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Set(System.String,System.Single)">
            <summary>
            Set named morph to this value.
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Get(System.Int32)">
            <summary>
            Get indexed morph value (Note: Currently, this only gets the override morph value)
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.Get(System.String)">
            <summary>
            Get named morph value (Note: Currently, this only gets the override morph value)
            </summary>
        </member>
        <member name="M:Sandbox.MorphCollection.GetName(System.Int32)">
            <summary>
            Retrieve name of a morph at given index.
            </summary>
        </member>
        <member name="P:Sandbox.MorphCollection.Count">
            <summary>
            Amount of morphs.
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetPointer(Sandbox.StringToken@,System.IntPtr@)">
            <summary>
            Internal for a reason - don't expose!
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,System.Span{``0})">
            <summary>
            Set a constant buffer to a specific value
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,``0)">
            <summary>
            Set a constant buffer to a specific value
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,``0[])">
            <summary>
            Set a constant buffer to a specific value
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,System.Collections.Generic.List{``0})">
            <summary>
            Set a constant buffer to a specific value
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetBool(Sandbox.StringToken@,System.Boolean@)">
            <summary>
            Get a bool value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetVector(Sandbox.StringToken@,Vector3@)">
            <summary>
            Get a vector3 value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetVector4(Sandbox.StringToken@,Vector4@)">
            <summary>
            Get a vector4 value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetAngles(Sandbox.StringToken@,Angles@)">
            <summary>
            Get a vector4 value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetFloat(Sandbox.StringToken@,System.Single@)">
            <summary>
            Get a float value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetInt(Sandbox.StringToken@,System.Int32@)">
            <summary>
            Get a int value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetMatrix(Sandbox.StringToken@,Matrix@)">
            <summary>
            Get a matrix value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderAttributes.GetTexture(Sandbox.StringToken@,Sandbox.Texture@)">
            <summary>
            Get a texture value - else defaultValue if missing
            </summary>
        </member>
        <member name="M:Sandbox.RenderingWorldSession.AddSceneWorld(Sandbox.SceneWorld)">
            <summary>
            Add a world to this camera, along with any child worlds
            </summary>
        </member>
        <member name="T:Sandbox.RenderTarget">
            <summary>
            Essentially wraps a couple of textures that we're going to render to. The color texture and the depth texture.
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.GetTemporary(System.Int32,System.Int32,Sandbox.ImageFormat,Sandbox.ImageFormat,Sandbox.MultisampleAmount,System.Int32)">
            <summary>
            Get a temporary render target. You should dispose the returned handle when you're done to return the textures to the pool.
            </summary>
            <param name="width">Width of the render target you want.</param>
            <param name="height">Height of the render target you want.</param>
            <param name="colorFormat">The format for the color buffer. If set to default we'll use whatever the current pipeline is using.</param>
            <param name="depthFormat">The format for the depth buffer.</param>
            <param name="msaa">The number of msaa samples you'd like. Msaa render textures are a pain in the ass so you're probably gonna regret trying to use this.</param>
            <param name="numMips">Number of mips you want in this texture. You probably don't want this unless you want to generate mips in a second pass.</param>
            <returns>A RenderTarget that is ready to render to.</returns>
        </member>
        <member name="M:Sandbox.RenderTarget.GetTemporary(System.Int32,Sandbox.ImageFormat,Sandbox.ImageFormat,Sandbox.MultisampleAmount,System.Int32)">
            <summary>
            Get a temporary render target. You should dispose the returned handle when you're done to return the textures to the pool.
            </summary>
            <param name="sizeFactor">Divide the screen size by this factor. 2 would be half screen sized. 1 for full screen sized.</param>
            <param name="colorFormat">The format for the color buffer. If null we'll choose the most appropriate for where you are in the pipeline.</param>
            <param name="depthFormat">The format for the depth buffer.</param>
            <param name="msaa">The number of msaa samples you'd like. Msaa render textures are a pain in the ass so you're probably gonna regret trying to use this.</param>
            <param name="numMips">Number of mips you want in this texture. You probably don't want this unless you want to generate mips in a second pass.</param>
            <returns>A RenderTarget that is ready to render to.</returns>
        </member>
        <member name="M:Sandbox.RenderTarget.Tick">
            <summary>
            Tick regularly to remove unused render targets
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.Flush">
            <summary>
            Flush all the render targets out. Useful to do when screen size changes
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.Loaned">
            <summary>
            Is this currently loaned out (Active)
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.TimeSinceUsed">
            <summary>
            The amount of time since this texture was last used
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.CreationHash">
            <summary>
            The hash of the parameters used to create this
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.Width">
            <summary>
            Width of the render target
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.Height">
            <summary>
            Height of the render target
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.ColorTarget">
            <summary>
            The target colour texture
            </summary>
        </member>
        <member name="P:Sandbox.RenderTarget.DepthTarget">
            <summary>
            The target depth texture
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.Dispose">
            <summary>
            Stop using this texture, return it to the pool
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.Destroy">
            <summary>
            Destroy this buffer. It shouldn't be used anymore after this.
            </summary>
        </member>
        <member name="M:Sandbox.RenderTarget.From(Sandbox.Texture,Sandbox.Texture)">
            <summary>
            Create a render target from these textures
            </summary>
        </member>
        <member name="M:Sandbox.FontManager.GetBestTypeface(Topten.RichTextKit.IStyle)">
            <summary>
            Tries to get the best matching font for the given style.
            Will return a matching font family with the closest font weight and optionally slant.
            </summary>
        </member>
        <member name="M:Sandbox.TextRendering.GetOrCreateTexture(Sandbox.TextRendering.Scope@,Vector2,Sandbox.TextFlag,Sandbox.UI.FontSmooth)">
            <summary>
            Create a texture from the scope. The texture will either be a cached version or will be rendered immediately
            </summary>
        </member>
        <member name="M:Sandbox.TextRendering.GetOrCreateTextBlock(System.Int32,System.Boolean@)">
            <summary>
            We don't expose this because we don't want them to do something stupid like free
            a textblock that they're still using
            </summary>
        </member>
        <member name="M:Sandbox.TextRendering.Tick">
            <summary>
            Free old, unused textblocks (and their textures)
            </summary>
        </member>
        <member name="T:Sandbox.TextRendering.Scope">
            <summary>
            Defines a scope of text, all using the same style.
            </summary>
        </member>
        <member name="T:Sandbox.TextRendering.TextBlock">
            <summary>
            We'll expose this at some point, but will probably be as Sandbox.TextBlock - and then need to think about ownership and caching
            </summary>
        </member>
        <member name="T:Sandbox.VertexLayout">
            <summary>
            Allows for the definition of custom vertex layouts
            </summary>
        </member>
        <member name="M:Sandbox.VertexLayout.FreeAll">
            <summary>
            Should probably be calling this on hotload, when types are changed?
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.Enabled">
            <summary>
            Indicates whether the fog system is enabled.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.ForceNoClipmaps">
            <summary>
            Don't use clipmaps, laggier(?) but doesn't allocate massive fucking clipmap textures.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.ContinuousMode">
            <summary>
            Indicates if the fog system operates in continuous mode.
            This means the clipmaps update every frame. 
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.Anisotropy">
            <summary>
            Level of anisotropy.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.Scattering">
            <summary>
            Scattering value.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.DrawDistance">
            <summary>
            Draw distance.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.FadeInStart">
            <summary>
            Start distance where fading begins.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.FadeInEnd">
            <summary>
            End distance where fading concludes.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.IndirectStrength">
            <summary>
            Strength of indirect illumination.
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogParameters.BakedIndirectTexture">
            <summary>
            Provides indirect lighting from a baked volume texture.
            This gets compiled with your map and is provided by an env_volumetric_controller.
            </summary>
            <remarks>
            You shouldn't expect to be able to add new runtime fog volumes if using this.
            </remarks>
        </member>
        <member name="T:Sandbox.AnimParam`1">
            <summary>
            Anim param values contain any value for a limited set of types
            </summary>
        </member>
        <member name="P:Sandbox.AnimationGraph.IsError">
            <summary>
            Whether the animation graph is invalid, or has not yet loaded.
            </summary>
        </member>
        <member name="P:Sandbox.AnimationGraph.Name">
            <summary>
            Animation graph file name.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.#ctor(NativeEngine.HAnimationGraph)">
            <summary>
            Private constructor, use <see cref="M:Sandbox.AnimationGraph.FromNative(NativeEngine.HAnimationGraph)"/>
            </summary>
        </member>
        <member name="P:Sandbox.AnimationGraph.ParamCount">
            <summary>
            Number of parameters in this animgraph
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.GetParameterType(System.Int32)">
            <summary>
            Get value type of parameter at given index
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.GetParameterName(System.Int32)">
            <summary>
            Get name of parameter at given index
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.GetParameter``1(System.String)">
            <summary>
            Get parameter at given name
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.GetParameter``1(System.Int32)">
            <summary>
            Get parameter at given index
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.Load(System.String)">
            <summary>
            Load an animation graph from given file.
            </summary>
        </member>
        <member name="M:Sandbox.AnimationGraph.FromNative(NativeEngine.HAnimationGraph)">
            <summary>
            Try to make it so only one AnimationGraph class exists for each animation graph
            </summary>
        </member>
        <member name="T:Sandbox.DecalDefinition">
            <summary>
            A decal which can be applied to objects and surfaces.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.DecalEntry.Material">
            <summary>
            Material to use.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.DecalEntry.Width">
            <summary>
            Width of the decal.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.DecalEntry.Height">
            <summary>
            Height of the decal.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.DecalEntry.KeepAspect">
            <summary>
            Keep aspect ratio of the decal image when using randomly generating Width and Height.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.DecalEntry.Depth">
            <summary>
            TODO: Describe me
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.DecalEntry.Rotation">
            <summary>
            Rotation to apply when placing the decal.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.DecalEntry.FadeTime">
            <summary>
            How long until the decal starts to fade out.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.DecalEntry.FadeDuration">
            <summary>
            How long the decal takes to fade out.
            </summary>
        </member>
        <member name="P:Sandbox.DecalDefinition.Decals">
            <summary>
            A list of decals, from which an entry will be randomly selected when this decal is placed.
            </summary>
        </member>
        <member name="T:Sandbox.GameResource">
            <summary>
            Assets defined in C# and created through tools.
            You can define your own <a href="https://wiki.facepunch.com/sbox/Custom_Asset_Types">Custom Asset Types</a>.
            </summary>
        </member>
        <member name="P:Sandbox.GameResource.ProcessSerializedObject">
            <summary>
            Allows tools to post process the serialized json object
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.GetReferencedPackages">
            <summary>
            Get a list of packages that are needed to load this asset
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.PostLoad">
            <summary>
            Called when the asset is first loaded from disk.
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.PostReload">
            <summary>
            Called when the asset is recompiled/reloaded from disk.
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.GetPromise(System.Type,System.String)">
            <summary>
            Creates an instance of this type that will get loaded into later. This allows us to
            have resources that reference other resources that aren't loaded yet (or are missing).
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.Register(System.String)">
            <summary>
            Makes sure all properties are derived properly from filename, and then registered to ResourceLibrary
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.Load``1(System.String)">
            <summary>
            Loads a game resource from given file.
            </summary>
        </member>
        <member name="M:Sandbox.GameResource.JsonUpgrade(System.Text.Json.Nodes.JsonObject)">
            <summary>
            called to upgrade a bunch of json to the latest version
            </summary>
            <param name="node"></param>
        </member>
        <member name="P:Sandbox.GameResource.ResourceVersion">
            <summary>
            The version of the component. Used by <see cref="T:Sandbox.JsonUpgrader"/>.
            </summary>
        </member>
        <member name="T:Sandbox.GameResourceAttribute">
            <summary>
            Should be applied to a class that inherits from <see cref="T:Sandbox.GameResource"/>.
            Makes the class able to be stored as an asset on disk.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.Name">
            <summary>
            The title of this game resource.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.Description">
            <summary>
            Description of this game resource.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.Extension">
            <summary>
            File extension for this game resource.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.Icon">
            <summary>
            Icon to be used for this asset
            Can be an absolute path of a PNG
            Or a <a href="https://fonts.google.com/icons">material icon</a> for this game resource's thumbnail.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.IconBgColor">
            <summary>
            Background color for this resource's thumbnail.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.IconFgColor">
            <summary>
            Foreground color (icon color) for this resource's thumbnail.
            </summary>
        </member>
        <member name="P:Sandbox.GameResourceAttribute.Category">
            <summary>
            Category of this game resource, for grouping in UI.
            </summary>
        </member>
        <member name="T:Sandbox.Material">
            <summary>
            A material. Uses several <see cref="T:Sandbox.Texture"/>s and a <see cref="T:Sandbox.Shader"/> with specific settings for more interesting visual effects.
            </summary>
        </member>
        <member name="P:Sandbox.Material.Name">
            <summary>
            Name (or path) of the material.
            </summary>
        </member>
        <member name="P:Sandbox.Material.Attributes">
            <summary>
            Access to all of the attributes of this material.
            </summary>
        </member>
        <member name="M:Sandbox.Material.Create(System.String,System.String)">
            <summary>
            Create a new empty material at runtime.
            </summary>
            <param name="materialName">Name of the new material.</param>
            <param name="shader">Shader that the new material will use.</param>
            <returns>The new material.</returns>
        </member>
        <member name="M:Sandbox.Material.FromShader(Sandbox.Shader)">
            <summary>
            Get an empty material based on the specified shader. This will cache the material so that subsequent calls
            will return the same material.
            </summary>
        </member>
        <member name="M:Sandbox.Material.FromShader(System.String)">
            <summary>
            Get an empty material based on the specified shader. This will cache the material so that subsequent calls
            will return the same material.
            </summary>
        </member>
        <member name="M:Sandbox.Material.#ctor(NativeEngine.IMaterial)">
            <summary>
            Private constructor, use <see cref="M:Sandbox.Material.FromNative(NativeEngine.IMaterial)"/>
            </summary>
            <param name="native"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Sandbox.Material.CreateCopy">
            <summary>
            Create a copy of this material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Vector4)">
            <summary>
            Overrides/Sets an Vector4 within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Sandbox.Texture)">
            <summary>
            Override/Sets texture parameter (Color, Normal, etc)
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Color)">
            <summary>
            Overrides/Sets an color within the material as a color value within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Vector3)">
            <summary>
            Overrides/Sets an Vector3 within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,Vector2)">
            <summary>
            Overrides/Sets an Vector2 within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,System.Single)">
            <summary>
            Overrides/Sets an float within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,System.Int32)">
            <summary>
            Overrides/Sets an int within the material
            </summary>
        </member>
        <member name="M:Sandbox.Material.Set(System.String,System.Boolean)">
            <summary>
            Overrides/Sets an bool within the material
            </summary>
        </member>
        <member name="P:Sandbox.Material.ShaderName">
            <summary>
            Gets the underlying shader name for this material.
            </summary>
        </member>
        <member name="P:Sandbox.Material.Flags">
            <summary>
            Access flags on this material, which usually hint about the contents. These are generally added by 
            the shader procedurally - but developers can add these in material editor too.
            </summary>
        </member>
        <member name="M:Sandbox.Material.Load(System.String)">
            <summary>
            Load a material from disk. Has internal cache.
            </summary>
            <param name="filename">The filepath to load the material from.</param>
            <returns>The loaded material, or null</returns>
        </member>
        <member name="M:Sandbox.Material.LoadAsync(System.String)">
            <summary>
            Load a material from disk. Has internal cache.
            </summary>
            <param name="filename">The filepath to load the material from.</param>
            <returns>The loaded material, or null</returns>
        </member>
        <member name="M:Sandbox.Material.FromNative(NativeEngine.IMaterial)">
            <summary>
            Try to make it so only one Material class exists for each material
            </summary>
        </member>
        <member name="T:Sandbox.Material.UI">
            <summary>
            Static materials for UI rendering purposes.
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.Basic">
            <summary>
            As basic 2D drawing material. Supports Texture and vertex color.
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.Box">
            <summary>
            CSS Box rendering
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.BoxShadow">
            <summary>
            CSS Box Shadow rendering
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.Text">
            <summary>
            CSS Text Rendering
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.BorderWrap">
            <summary>
            For filter: border-wrap( ... );
            </summary>
        </member>
        <member name="P:Sandbox.Material.UI.DropShadow">
            <summary>
            For filter: drop-shadow( ... );
            </summary>
        </member>
        <member name="T:Sandbox.MeshPrimitiveType">
            <summary>
            Possible primitive types of a <see cref="T:Sandbox.Mesh"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Mesh">
             <summary>
             A <a href="https://en.wikipedia.org/wiki/Polygon_mesh">mesh</a> is a basic version of a <see cref="T:Sandbox.Model"/>,
             containing a set of vertices and indices which make up faces that make up a shape.
            
             <para>A set of meshes can be used to create a <see cref="T:Sandbox.Model"/> via the <see cref="T:Sandbox.ModelBuilder"/> class.</para>
             </summary>
        </member>
        <member name="P:Sandbox.Mesh.IsValid">
            <inheritdoc cref="P:Sandbox.IValid.IsValid"/>
        </member>
        <member name="P:Sandbox.Mesh.PrimitiveType">
            <summary>
            Sets the primitive type for this mesh.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.Material">
            <summary>
            Sets material for this mesh.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.Bounds">
            <summary>
            Sets AABB bounds for this mesh.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.UvDensity">
            <summary>
            Used to calculate texture size for texture streaming.
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexRange(System.Int32,System.Int32)">
            <summary>
            Set how many vertices this mesh draws (if there's no index buffer)
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexRange(System.Int32,System.Int32)">
            <summary>
            Set how many indices this mesh draws
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateBuffers(Sandbox.VertexBuffer,System.Boolean)">
            <summary>
            Create vertex and index buffers.
            </summary>
            <param name="vb">Input vertex buffer. If it is indexed (<see cref="P:Sandbox.VertexBuffer.Indexed"/>), then index buffer will also be created.</param>
            <param name="calculateBounds">Whether to recalculate bounds from the vertex buffer.</param>
        </member>
        <member name="M:Sandbox.Mesh.TriangulatePolygon(System.Span{Vector3})">
            <summary>
            Triangulate a polygon made up of points, returns triangle indices into the list of vertices.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.HasIndexBuffer">
            <summary>
            Whether this mesh has an index buffer.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.IndexCount">
            <summary>
            Number of indices this mesh has.
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer">
            <summary>
            Create an empty index buffer, it can be resized later
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Span{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Span{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferSize(System.Int32)">
            <summary>
            Resize the index buffer.
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.HasVertexBuffer">
            <summary>
            Whether this mesh has a vertex buffer.
            </summary>
        </member>
        <member name="P:Sandbox.Mesh.VertexCount">
            <summary>
            Number of vertices this mesh has.
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(Sandbox.VertexAttribute[])">
            <summary>
            Create an empty vertex buffer, it can be resized later
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Collections.Generic.List{``0})">
            <summary>
            Create a vertex buffer with a number of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Span{``0})">
            <summary>
            Create a vertex buffer with a number of vertices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Span{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferSize(System.Int32)">
            <summary>
            Resize the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.#ctor">
            <summary>
            Create an empty index buffer, it can be resized later
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.#ctor(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.#ctor(System.Int32,System.Span{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.SetData(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.SetData(System.Span{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.SetSize(System.Int32)">
            <summary>
            Resize the index buffer.
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.Lock(Sandbox.IndexBufferHandle.LockHandler)">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.Lock(System.Int32,Sandbox.IndexBufferHandle.LockHandler)">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.IndexBufferHandle.Lock(System.Int32,System.Int32,Sandbox.IndexBufferHandle.LockHandler)">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.SetSize(System.Int32)">
            <summary>
            Resize the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.SetData``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.SetData``1(System.Span{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.Lock``1(Sandbox.VertexBufferHandle.LockHandler{``0})">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.Lock``1(System.Int32,Sandbox.VertexBufferHandle.LockHandler{``0})">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle.Lock``1(System.Int32,System.Int32,Sandbox.VertexBufferHandle.LockHandler{``0})">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.#ctor(Sandbox.VertexAttribute[])">
            <summary>
            Create an empty vertex buffer, it can be resized later
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.#ctor(System.Int32,Sandbox.VertexAttribute[],System.Collections.Generic.List{`0})">
            <summary>
            Create a vertex buffer with a number of vertices
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.#ctor(System.Int32,Sandbox.VertexAttribute[],System.Span{`0})">
            <summary>
            Create a vertex buffer with a number of vertices
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.SetSize(System.Int32)">
            <summary>
            Resize the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.SetData(System.Collections.Generic.List{`0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.SetData(System.Span{`0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.Lock(Sandbox.VertexBufferHandle{`0}.LockHandler)">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.Lock(System.Int32,Sandbox.VertexBufferHandle{`0}.LockHandler)">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferHandle`1.Lock(System.Int32,System.Int32,Sandbox.VertexBufferHandle{`0}.LockHandler)">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="T:Sandbox.BoneCollection">
            <summary>
            A collection of bones. This could be from a model, or an entity
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Root">
            <summary>
            Root bone of the model.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.AllBones">
            <summary>
            List of all bones of our object.
            </summary>
        </member>
        <member name="M:Sandbox.BoneCollection.HasBone(System.String)">
            <summary>
            Whether the model or entity has a given bone by name.
            </summary>
        </member>
        <member name="M:Sandbox.BoneCollection.GetBone(System.String)">
            <summary>
            Retrieve a bone by name.
            </summary>
        </member>
        <member name="T:Sandbox.BoneCollection.Bone">
            <summary>
            A bone in a <see cref="T:Sandbox.BoneCollection"/>.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.Index">
            <summary>
            Numerical index of this bone.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.Name">
            <summary>
            Name of this bone.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.Parent">
            <summary>
            The parent bone.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.LocalTransform">
            <summary>
            Transform on this bone, relative to the root bone.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.HasChildren">
            <summary>
            Whether this bone has any child bones.
            </summary>
        </member>
        <member name="P:Sandbox.BoneCollection.Bone.Children">
            <summary>
            List of all bones that descend from this bone.
            </summary>
        </member>
        <member name="M:Sandbox.BoneCollection.Bone.IsNamed(System.String)">
            <summary>
            Whether this bone has given name or not.
            </summary>
        </member>
        <member name="T:Sandbox.Model">
            <summary>
            A model.
            </summary>
        </member>
        <member name="P:Sandbox.Model.AnimationCount">
            <summary>
            Number of animations this model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetAnimationName(System.Int32)">
            <summary>
            Returns name of an animation at given animation index.
            </summary>
            <param name="animationIndex">Animation index to get name of, starting at 0.</param>
            <returns>Name of the animation.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,AnimationCount-1]</exception>
        </member>
        <member name="P:Sandbox.Model.AnimGraph">
            <summary>
            Get the animgraph this model uses.
            </summary>
        </member>
        <member name="T:Sandbox.Model.BodyGroupMaskAttribute">
            <summary>
            Used to mark properties as a body group mask, so the correct editor can be used
            </summary>
        </member>
        <member name="P:Sandbox.Model.Bounds">
            <summary>
            Total bounds of all the meshes.
            </summary>
        </member>
        <member name="P:Sandbox.Model.PhysicsBounds">
            <summary>
            Total bounds of all the physics shapes.
            </summary>
        </member>
        <member name="P:Sandbox.Model.RenderBounds">
            <summary>
            Render view bounds.
            </summary>
        </member>
        <member name="M:Sandbox.Model.#ctor(NativeEngine.IModel,System.Boolean)">
            <summary>
            Private constructor, use <see cref="M:Sandbox.Model.FromNative(NativeEngine.IModel,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Sandbox.Model.OnReloaded">
            <summary>
            Called when the resource is reloaded. We should clear any cached values.
            </summary>
        </member>
        <member name="P:Sandbox.Model.IsError">
            <summary>
            Whether this model is an error model or invalid or not.
            </summary>
        </member>
        <member name="P:Sandbox.Model.Name">
            <summary>
            Name of the model, usually being its file path.
            </summary>
        </member>
        <member name="P:Sandbox.Model.IsProcedural">
            <summary>
            Whether this model is procedural, i.e. it was created at runtime via <see cref="M:Sandbox.ModelBuilder.Create"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetAttachment(System.String)">
            <summary>
            Retrieves attachment transform based on given attachment name.
            </summary>
            <param name="name">Name of the attachment to retrieve transform of.</param>
            <returns>The attachment transform, or null if attachment by given name is not found.</returns>
        </member>
        <member name="M:Sandbox.Model.GetAttachment(System.Int32)">
            <summary>
            Retrieves attachment transform based on given attachment index.
            </summary>
            <param name="index">>Index of the attachment to look up, starting at 0.</param>
            <returns>The attachment transform.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,AttachmentCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetAttachmentName(System.Int32)">
            <summary>
            Returns name of an attachment at given index.
            </summary>
            <param name="index">Index of the attachment to look up, starting at 0.</param>
            <returns>The name of the attachment at given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,AttachmentCount-1]</exception>
        </member>
        <member name="P:Sandbox.Model.AttachmentCount">
            <summary>
            Returns amount of attachment points this model has.
            </summary>
        </member>
        <member name="P:Sandbox.Model.MeshCount">
            <summary>
            Total number of meshes this model is made out of.
            </summary>
        </member>
        <member name="P:Sandbox.Model.Trace">
            <summary>
            Trace against the triangles in this mesh
            </summary>
        </member>
        <member name="M:Sandbox.Model.TryGetData``1(``0@)">
            <summary>
            Tries to extract data from model based on the given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
            <param name="data">The extracted data, or default on failure.</param>
            <returns>true if data was extracted successfully, false otherwise.</returns>
        </member>
        <member name="M:Sandbox.Model.TryGetData(System.Type,System.Object@)">
            <summary>
            Tries to extract data from model based on the given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
            <param name="data">The extracted data, or default on failure.</param>
            <param name="t">The class with <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.</param>
            <returns>true if data was extracted successfully, false otherwise.</returns>
        </member>
        <member name="M:Sandbox.Model.HasData``1">
            <summary>
            Tests if this model has generic data based on given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            This will be faster than testing this via GetData<![CDATA[<>]]>()
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetData``1">
            <summary>
            Extracts data from model based on the given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetBreakCommands">
            <summary>
            Internal function used to get a list of break commands the model has.
            </summary>
        </member>
        <member name="P:Sandbox.Model.HitboxSet">
            <summary>
            Access to default hitbox set of this model
            </summary>
        </member>
        <member name="M:Sandbox.Model.Load(System.String)">
            <summary>
            Load a model by file path.
            </summary>
            <param name="filename">The file path to load as a model.</param>
            <returns>The loaded model, or null</returns>
        </member>
        <member name="M:Sandbox.Model.LoadAsync(System.String)">
            <summary>
            Load a model by file path.
            </summary>
            <param name="filename">The file path to load as a model.</param>
            <returns>The loaded model, or null</returns>
        </member>
        <member name="P:Sandbox.Model.MaterialGroupCount">
            <summary>
            Number of material groups this model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetMaterialGroupName(System.Int32)">
            <summary>
            Returns name of a material group at given group index.
            </summary>
            <param name="groupIndex">Group index to get name of, starting at 0.</param>
            <returns>Name of the group.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,MaterialGroupCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetMaterialGroupIndex(System.String)">
            <summary>
            Retrieves the index of a material group given its name.
            </summary>
            <param name="groupIndex">The name of the material group.</param>
            <returns>The index of the material group, or a negative value if the group does not exist.</returns>
        </member>
        <member name="P:Sandbox.Model.Materials">
            <summary>
            Retrieves an enumerable collection of all Materials on the meshes.
            </summary>
            <returns>An IEnumerable of Materials.</returns>
        </member>
        <member name="M:Sandbox.Model.GetMaterials(System.Int32)">
            <summary>
            Retrieves an enumerable collection of Materials belonging to a specified group.
            </summary>
            <param name="groupIndex">The index of the material group. Default value is 0.</param>
            <returns>An IEnumerable of Materials in the specified group.</returns>
        </member>
        <member name="M:Sandbox.Model.GetMaterials(System.String)">
            <summary>
            Retrieves an enumerable collection of Materials belonging to a specified group.
            </summary>
            <param name="groupName">The name of the material group.</param>
            <returns>An IEnumerable of Materials in the specified group.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the provided group name does not exist.</exception>
        </member>
        <member name="T:Sandbox.Model.MaterialGroupAttribute">
            <summary>
            Used to mark a property as a material group, for the editor
            </summary>
        </member>
        <member name="T:Sandbox.Model.MaterialOverrideAttribute">
            <summary>
            Used to mark a property as a material material override dictionary, for the editor
            </summary>
        </member>
        <member name="P:Sandbox.Model.Bones">
            <summary>
            Access to bones of this model.
            </summary>
        </member>
        <member name="P:Sandbox.Model.BoneCount">
            <summary>
            Number of bones this model has.
            </summary>
        </member>
        <member name="P:Sandbox.Model.MorphCount">
            <summary>
            Number of morph controllers this model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetBoneName(System.Int32)">
            <summary>
            Returns name of a bone at given bone index.
            </summary>
            <param name="boneIndex">Bone index to get name of, starting at 0.</param>
            <returns>Name of the bone.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,BoneCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetBoneParent(System.Int32)">
            <summary>
            Returns the id of given bone's parent bone.
            </summary>
            <param name="boneIndex">The bone to look up parent of.</param>
            <returns>The id of the parent bone, or -1 if given bone has no parent.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,BoneCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetBoneTransform(System.Int32)">
            <summary>
            Returns transform of given bone at bind position.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,BoneCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetBoneTransform(System.String)">
            <summary>
            Returns transform of given bone at bind position.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetMorphName(System.Int32)">
            <summary>
            Returns name of a morph controller at given index.
            </summary>
            <param name="morph">Morph controller index to get name of, starting at 0.</param>
            <returns>Name of the morph controller at given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,MorphCount-1]</exception>
        </member>
        <member name="M:Sandbox.Model.GetVisemeMorph(System.String,System.Int32)">
            <summary>
            Get morph weight for viseme.
            </summary>
        </member>
        <member name="M:Sandbox.Model.FromNative(NativeEngine.IModel,System.Boolean)">
            <summary>
            Cached <see cref="T:Sandbox.Model"/> instance from native, or creates
            </summary>
        </member>
        <member name="P:Sandbox.Model.Builder">
            <summary>
            Returns a static <see cref="T:Sandbox.ModelBuilder"/> instance, allowing for runtime model creation.
            </summary>
        </member>
        <member name="P:Sandbox.Model.Cube">
            <summary>
            A cube model
            </summary>
        </member>
        <member name="P:Sandbox.Model.Sphere">
            <summary>
            A sphere model
            </summary>
        </member>
        <member name="P:Sandbox.Model.Plane">
            <summary>
            A plane model
            </summary>
        </member>
        <member name="P:Sandbox.Model.Error">
            <summary>
            An error model
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetVertices">
            <summary>
            Experimental! Try to get all vertices from model (meshes need to be compiled with CPU access!)
            https://files.facepunch.com/layla/1b0611b1/sbox_K1HhsZO3yM.png
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetIndices">
            <summary>
            Experimental! Try to get all indices from model (meshes need to be compiled with CPU access!)
            https://files.facepunch.com/layla/1b0611b1/sbox_K1HhsZO3yM.png
            </summary>
        </member>
        <member name="T:Sandbox.ModelBuilder">
            <summary>
            Provides ability to generate <see cref="T:Sandbox.Model"/>s at runtime.
            A static instance of this class is available at <see cref="P:Sandbox.Model.Builder"/>
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithMass(System.Single)">
            <summary>
            Total mass of the physics body (Default is 1000)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithSurface(System.String)">
            <summary>
            Surface property to use for collision
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithLodDistance(System.Int32,System.Single)">
            <summary>
            LOD switch distance increment for each Level of Detail (LOD) level. (Default is 50)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionBox(Vector3,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add box collision shape.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionSphere(System.Single,Vector3)">
            <summary>
            Add sphere collision shape.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionCapsule(Vector3,Vector3,System.Single)">
            <summary>
            Add capsule collision shape.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionHull(Vector3[],System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add a CONVEX hull collision shape.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionMesh(Vector3[],System.Int32[])">
            <summary>
            Add a CONCAVE mesh collision shape. (This shape can NOT be physically simulated)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh)">
            <summary>
            Add a mesh.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[])">
            <summary>
            Add a bunch of meshes.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh,System.Int32)">
            <summary>
            Add a mesh to a Level of Detail (LOD) group.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[],System.Int32)">
            <summary>
            Add a bunch of meshes to a Level of Detail (LOD) group.
            </summary>
        </member>
        <member name="T:Sandbox.ModelBuilder.Bone">
            <summary>
            A bone definition for use with <see cref="T:Sandbox.ModelBuilder"/>.
            </summary>
            <param name="Name">Name of the bone.</param>
            <param name="ParentName">Name of the parent bone.</param>
            <param name="Position">Position of the bone, relative to its parent.</param>
            <param name="Rotation">Rotation of the bone, relative to its parent.</param>
        </member>
        <member name="M:Sandbox.ModelBuilder.Bone.#ctor(System.String,System.String,Vector3,Rotation)">
            <summary>
            A bone definition for use with <see cref="T:Sandbox.ModelBuilder"/>.
            </summary>
            <param name="Name">Name of the bone.</param>
            <param name="ParentName">Name of the parent bone.</param>
            <param name="Position">Position of the bone, relative to its parent.</param>
            <param name="Rotation">Rotation of the bone, relative to its parent.</param>
        </member>
        <member name="P:Sandbox.ModelBuilder.Bone.Name">
            <summary>Name of the bone.</summary>
        </member>
        <member name="P:Sandbox.ModelBuilder.Bone.ParentName">
            <summary>Name of the parent bone.</summary>
        </member>
        <member name="P:Sandbox.ModelBuilder.Bone.Position">
            <summary>Position of the bone, relative to its parent.</summary>
        </member>
        <member name="P:Sandbox.ModelBuilder.Bone.Rotation">
            <summary>Rotation of the bone, relative to its parent.</summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBone(Sandbox.ModelBuilder.Bone)">
            <summary>
            Add a bone to the skeleton via a <see cref="T:Sandbox.ModelBuilder.Bone"/> struct.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBones(Sandbox.ModelBuilder.Bone[])">
            <summary>
            Add multiple bones to the skeleton.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBone(System.String,Vector3,Rotation,System.String)">
            <summary>
            Add a bone to the skeleton.
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.Create">
            <summary>
            Finish creation of the model.
            </summary>
        </member>
        <member name="P:Sandbox.HitboxSet.Box.Shape">
            <summary>
            Either a Sphere, Capsule or BBox
            </summary>
        </member>
        <member name="P:Sandbox.HitboxSet.Box.RandomPointInside">
            <summary>
            Get a random point inside this hitbox
            </summary>
        </member>
        <member name="P:Sandbox.HitboxSet.Box.RandomPointOnEdge">
            <summary>
            Get a random point on the edge this hitbox
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroupDescription.Surfaces">
            <summary>
            Enumerate every <see cref="T:Sandbox.Surface"/> in this <see cref="T:Sandbox.Model"/> 
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroupDescription.BodyPart.HullPart.GetLines">
            <summary>
            For debug rendering
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroupDescription.BodyPart.MeshPart.GetTriangles">
            <summary>
            For debug rendering
            </summary>
        </member>
        <member name="T:Sandbox.ParticleSnapshot">
            <summary>
            A particle snapshot that can be created procedurally.
            Contains a set of vertices that particle effects can address.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleSnapshot.Vertex">
            <summary>
            A vertex to update a particle snapshot with.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSnapshot.#ctor">
            <summary>
            Create new empty procedural particle snapshot.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSnapshot.Update(System.Span{Sandbox.ParticleSnapshot.Vertex})">
            <summary>
            Update this snapshot with a list of vertices.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleSystem">
            <summary>
            A particle effect system that allows for complex visual effects, such as
            explosions, muzzle flashes, impact effects, etc.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSystem.IsError">
            <summary>
            Whether the particle system is invalid, or has not yet loaded.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSystem.Name">
            <summary>
            Particle system file name.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSystem.Bounds">
            <summary>
            Static bounding box of the resource.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSystem.#ctor(NativeEngine.HParticleSystemDefinition,System.String)">
            <summary>
            Private constructor, use <see cref="M:Sandbox.ParticleSystem.FromNative(NativeEngine.HParticleSystemDefinition,System.String)"/>
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSystem.ChildCount">
            <summary>
            How many child particle systems do we have
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSystem.GetChild(System.Int32)">
            <summary>
            Returns child particle at given index.
            </summary>
            <param name="index">Index of child particle system, starting at 0.</param>
            <returns>Particle system</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,ChildCount-1]</exception>
        </member>
        <member name="M:Sandbox.ParticleSystem.Load(System.String)">
            <summary>
            Loads a particle system from given file.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSystem.LoadAsync(System.String)">
            <summary>
            Load a particle system by file path.
            </summary>
            <param name="filename">The file path to load as a particle system.</param>
            <returns>The loaded particle system, or null</returns>
        </member>
        <member name="M:Sandbox.ParticleSystem.FromNative(NativeEngine.HParticleSystemDefinition,System.String)">
            <summary>
            Try to make it so only one AnimationGraph class exists for each animation graph
            </summary>
        </member>
        <member name="T:Sandbox.Resource">
            <summary>
            A resource loaded in the engine, such as a <see cref="T:Sandbox.Model"/> or <see cref="T:Sandbox.Material"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Resource.ResourceId">
            <summary>
            ID of this resource,
            </summary>
        </member>
        <member name="P:Sandbox.Resource.ResourcePath">
            <summary>
            Path to this resource.
            </summary>
        </member>
        <member name="P:Sandbox.Resource.ResourceName">
            <summary>
            File name of the resource without the extension.
            </summary>
        </member>
        <member name="P:Sandbox.Resource.IsPromise">
            <summary>
            Whether this resource was NOT loaded from disk, but rather simply contains the target filepath on disk.
            This can happen for assets that don't exist.
            </summary>
        </member>
        <member name="M:Sandbox.Resource.SetIdFromResourcePath(System.String)">
            <summary>
            Sets the ResourcePath, ResourceName and ResourceId from a resource path
            </summary>
        </member>
        <member name="M:Sandbox.Resource.Load(System.Type,System.String)">
            <summary>
            Accessor for loading native resources, not great, doesn't need to handle GameResource
            </summary>
        </member>
        <member name="M:Sandbox.Resource.OnReloaded">
            <summary>
            Called by OnResourceReloaded when a resource has been reloaded
            </summary>
        </member>
        <member name="T:Sandbox.ResourceLibrary">
            <summary>
            Keeps a library of all available <see cref="T:Sandbox.GameResource"/>.
            </summary>
        </member>
        <member name="M:Sandbox.ResourceLibrary.Get``1(System.Int32)">
            <summary>
            Get a cached resource by its hash.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="identifier">Resource hash to look up.</param>
        </member>
        <member name="M:Sandbox.ResourceLibrary.Get``1(System.String)">
            <summary>
            Get a cached resource by its file path.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="filepath">File path to the resource.</param>
        </member>
        <member name="M:Sandbox.ResourceLibrary.TryGet``1(System.String,``0@)">
            <summary>
            Try to get a cached resource by its file path.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="filepath">File path to the resource.</param>
            <param name="resource">The retrieved resource, if any.</param>
            <returns>True if resource was retrieved successfully.</returns>
        </member>
        <member name="M:Sandbox.ResourceLibrary.GetAll``1">
            <summary>
            Get all cached resources of given type.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
        </member>
        <member name="M:Sandbox.ResourceLibrary.GetAll``1(System.String,System.Boolean)">
            <summary>
            Get all cached resources of given type in a specific folder.
            </summary>
            <typeparam name="T">Resource type to get.</typeparam>
            <param name="filepath">The path of the folder to check.</param>
            <param name="recursive">Whether or not to check folders within the specified folder.</param>
        </member>
        <member name="M:Sandbox.ResourceLibrary.ReadCompiledResourceJson(System.Span{System.Byte})">
            <summary>
            Read compiled resource as JSON from the provided buffer.
            </summary>
        </member>
        <member name="M:Sandbox.ResourceLibrary.ReadCompiledResourceJson(Sandbox.BaseFileSystem,System.String)">
            <summary>
            Read compiled resource as JSON from the provided file path.
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.cachedScene">
            <summary>
            This is used as a reference
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.ShowInMenu">
            <summary>
            If true then we'll show this in the right click menu, so people can create it
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.MenuPath">
            <summary>
            If ShowInMenu is true, this is the path in the menu for this prefab
            </summary>
        </member>
        <member name="P:Sandbox.PrefabFile.MenuIcon">
            <summary>
            Icon to show to the left of the option in the menu
            </summary>
        </member>
        <member name="M:Sandbox.PrefabFile.Upgrader_v1(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Version 0 to 1
            - "Id" changed to "__guid"
            </summary>
        </member>
        <member name="T:Sandbox.PrefabVariable">
            <summary>
            A prefab variable definition
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Id">
            <summary>
            A unique id for this variable. This is what it will be referred to in code.
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Title">
            <summary>
            A user friendly title for this variable
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Description">
            <summary>
            A user friendly description for this variable
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Group">
            <summary>
            An optional group for this variable to belong to
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Order">
            <summary>
            Lower numbers appear first
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.Targets">
            <summary>
            Component variables that are being targetted
            </summary>
        </member>
        <member name="M:Sandbox.PrefabVariable.AddTarget(System.Guid,System.String)">
            <summary>
            Add a target property
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.PrefabVariableTarget.Id">
            <summary>
            The Id of the gameobject or component
            </summary>
        </member>
        <member name="P:Sandbox.PrefabVariable.PrefabVariableTarget.Property">
            <summary>
            The name of the parameter on the target
            </summary>
        </member>
        <member name="M:Sandbox.SceneFile.Upgrader_v1(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Version 0 to 1
            - "Id" changed to "__guid"
            </summary>
        </member>
        <member name="T:Sandbox.Shader">
            <summary>
            A <a href="https://en.wikipedia.org/wiki/Shader">shader</a> is a specialized and complex computer program that use
            world geometry, materials and textures to render graphics.
            </summary>
        </member>
        <member name="P:Sandbox.Shader.Description">
            <summary>
            Description of the shader.
            </summary>
        </member>
        <member name="M:Sandbox.Shader.FromNative(NativeEngine.CVfx)">
            <summary>
            Try to make it so only one Shader class exists for each shader
            </summary>
        </member>
        <member name="M:Sandbox.Shader.Load(System.String)">
            <summary>
            Load a shader by file path.
            </summary>
            <param name="filename">The file path to load as a shader.</param>
            <returns>The loaded shader, or null</returns>
        </member>
        <member name="T:Sandbox.SoundEvent">
            <summary>
            A sound event. It can play a set of random sounds with optionally random settings such as volume and pitch.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.UI">
            <summary>
            Is this sound 2D?
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Volume">
            <summary>
            How loud the sound should be.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Pitch">
            <summary>
            The base pitch of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Decibels">
            <summary>
            How loud is this sound, affects how far away it can be heard
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.SelectionMode">
            <summary>
            Selection strategy to use when picking from multiple sounds.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Sounds">
            <summary>
            A random sound from the list will be selected to be played.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Occlusion">
            <summary>
            Allow this sound to be occluded by geometry 
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Reflections">
            <summary>
            Allow this sound to trace reflections, allowing it to be heard indirectly
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.AirAbsorption">
            <summary>
            Allow this sound to be absorbed by air
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Transmission">
            <summary>
            Allow this sound to be transmitted through geometry
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.OcclusionRadius">
            <summary>
            The radius of this sound's occlusion in inches.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.DistanceAttenuation">
            <summary>
            Should the sound fade out over distance
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.InputIndex">
            <summary>
            Used for selection mode
            </summary>
        </member>
        <member name="T:Sandbox.Soundscape">
            <summary>
            A soundscape is used for environmental ambiance of a map by playing a set of random sounds at given intervals.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.MasterVolume">
            <summary>
            All sound volumes in this soundscape will be scaled by this value.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.LoopedSounds">
            <summary>
            Sounds that are played constantly on a loop.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSounds">
            <summary>
            Sounds that are played at intervals.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.LoopedSound.SoundFile">
            <summary>
            The sound to play. It should have the looped flag set.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.LoopedSound.Volume">
            <summary>
            Sound volume.
            </summary>
        </member>
        <member name="M:Sandbox.Soundscape.LoopedSound.ToString">
            <summary>
            If true then the sound will come from a random direction in the world
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSound.SoundFile">
            <summary>
            The sound event to play.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSound.InstanceCount">
            <summary>
            How many instances of this sting should exist.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSound.RepeatTime">
            <summary>
            How often should this sound be repeated.
            </summary>
        </member>
        <member name="P:Sandbox.Soundscape.StingSound.Distance">
            <summary>
            How far away from the camera should the sound play.
            </summary>
        </member>
        <member name="T:Sandbox.SoundFile">
            <summary>
            A sound resource.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.OnSoundReloaded">
            <summary>
            Ran when the file is reloaded/recompiled, etc.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.IsLoaded">
            <summary>
            true if sound is loaded
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.Format">
            <summary>
            Format of the audio file.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.BitsPerSample">
            <summary>
            Bits per each sample of this sound file.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.Channels">
            <summary>
            Number of channels this audio file has.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.BytesPerSample">
            <summary>
            Bytes per each sample of this sound file.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.SampleFrameSize">
            <summary>
            Size of one sample, typically this would be "sample size * channel count", but can vary on audio format.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.Rate">
            <summary>
            Sample rate of this sound file, per second.
            </summary>
        </member>
        <member name="P:Sandbox.SoundFile.Duration">
            <summary>
            Duration of the sound this sound file contains, in seconds.
            </summary>
        </member>
        <member name="M:Sandbox.SoundFile.Load(System.String)">
            <summary>
            Load a new sound from disk. Includes automatic caching.
            </summary>
            <param name="filename">The file path to load the sound from.</param>
            <returns>The loaded sound file, or null if failed.</returns>
        </member>
        <member name="M:Sandbox.SoundFile.GetSamplesAsync">
            <summary>
            Request decompressed audio samples.
            </summary>
        </member>
        <member name="T:Sandbox.Surface">
            <summary>
            A physics surface. This is applied to each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> and controls its physical properties and physics related sounds.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.BaseSurface">
            <summary>
            Filepath of the base surface. Use <see cref="M:Sandbox.Surface.SetBaseSurface(System.String)">SetBaseSurface</see> and <see cref="M:Sandbox.Surface.GetBaseSurface">GetBaseSurface</see>.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.AudioSurface">
            <summary>
            Defines the audio properties of this surface for Steam Audio
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Description">
            <summary>
            A concise description explaining what this surface property should be used for.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Friction">
            <summary>
            Friction of this surface material.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Elasticity">
            <summary>
            Controls bounciness.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Density">
            <summary>
            Density of this surface material. This affects things like automatic mass calculation.
            Density is in kg/m^3.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Thickness">
            <summary>
            If above 0, the object is considered hollow, and its auto generated mass is affected accordingly.
            Thickness is in inches.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Dampening">
            <summary>
            Currently unused and does nothing.
            </summary>
            <remarks>TODO: Implement or remove.</remarks>
        </member>
        <member name="P:Sandbox.Surface.BounceThreshold">
            <summary>
            Velocity threshold, below which objects will not bounce due to their elasticity.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.Regular">
            <summary>
            Spawn one of these particles on impact.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.Bullet">
            <summary>
            Spawn one of these particles when hit by a bullet.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.BulletDecal">
            <summary>
            Use one of these as the bullet impact decal.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.SoftParticles">
            <summary>
            Spawn one of these particles on impact.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.SoftDecal">
            <summary>
            Use one of these as a physics impact decal.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.HardParticles">
            <summary>
            Spawn one of these particles on impact.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.HardDecal">
            <summary>
            Use one of these as a physics impact decal.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffects">
            <summary>
            Impact effects of this surface material.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.RoughnessFactor">
            <summary>
            Similar to friction but only affects whether a scrape is rough or smooth.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.RoughThreshold">
            <summary>
            Surface roughness greater than this results in rough scrapes.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.SmoothParticles">
            <summary>
            Spawn one of these particle effects during a smooth scrape.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.RoughParticles">
            <summary>
            Spawn one of these particle effects during a rough scrape.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.SmoothDecal">
            <summary>
            Use one of these particles during a smooth scrape.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffectData.RoughDecal">
            <summary>
            Use one of these particles during a rough scrape.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ScrapeEffects">
            <summary>
            Scrape effects of this surface material.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundData.FootLeft">
            <summary>
            Left footstep sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundData.FootRight">
            <summary>
            Right footstep sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundData.FootLaunch">
            <summary>
            Jump sound for this surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundData.FootLand">
            <summary>
            Landing sound for this surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundData.Bullet">
            <summary>
            Bullet impact sound for this surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundData.ImpactHard">
            <summary>
            Hard, high velocity impact sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundData.ImpactSoft">
            <summary>
            Soft, low velocity impact sound.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundData.ScrapeRough">
            <summary>
            Rough scraping sound when scraping against another surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.SoundData.ScrapeSmooth">
            <summary>
            Smooth scraping sound when scraping against another surface.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Sounds">
            <summary>
            Sounds associated with this surface material.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.BreakablesInfo.BreakSound">
            <summary>
            Play this sound when a model/entity of this surface breaks. Models can override this value.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.BreakablesInfo.GenericGibs">
            <summary>
            These models will be used as gibs when a model of this surface breaks and has no gibs of its own.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Breakables">
            <summary>
            Breakable info for this surface material.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.GetBaseSurface">
            <summary>
            Returns the base surface of this surface, or null if we are the default surface.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.SetBaseSurface(System.String)">
            <summary>
            Sets the base surface by name.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.GetRandomGib">
            <summary>
            Returns a random gib taking into account base surface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Surface.FindByIndex(System.Int32)">
            <summary>
            Find a surface by its index in the array. This is the fastest way to lookup, so it's
            passed from things like Traces since the index is going to be the same. It's important to
            know that this index shouldn't be saved or networked because it could differ between loads or clients.
            Instead send the name hash and look up using that.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.FindByName(System.String)">
            <summary>
            Returns a Surface from its name, or null
            </summary>
            <param name="name">The name of a surface property to look up</param>
            <returns>The surface with given name, or null if such surface property doesn't exist</returns>
        </member>
        <member name="F:Sandbox.Surface.TagList">
            <summary>
            Internal accessor for the surface's tags (stored as StringToken)
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Tags">
            <summary>
            A list of tags as one string.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.HasTag(System.String)">
            <summary>
            Do we have a tag?
            </summary>
            <param name="tag"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Surface.HasAllTags(System.String[])">
            <summary>
            Do we have all the tags on this hitbox?
            </summary>
            <param name="tags"></param>
            <returns>True if all tags match, false if any tag does not match.</returns>
        </member>
        <member name="M:Sandbox.Surface.HasAnyTags(System.String[])">
            <summary>
            Do we have all the tags on this hitbox?
            </summary>
            <param name="tags"></param>
            <returns>True if any tag matches, false if all tags do not match.</returns>
        </member>
        <member name="T:Sandbox.AudioSurface">
            <summary>
            Defines acoustic properties of a surface, which defines how sound will bounce
            </summary>
        </member>
        <member name="T:Sandbox.TerrainMaterial">
            <summary>
            Description of a Terrain Material.
            </summary>
        </member>
        <member name="T:Sandbox.TerrainStorage">
            <summary>
            Stores heightmaps, control maps and materials.
            </summary>
        </member>
        <member name="P:Sandbox.TerrainStorage.TerrainSize">
            <summary>
            Uniform world size of the width and length of the terrain.
            </summary>
        </member>
        <member name="P:Sandbox.TerrainStorage.TerrainHeight">
            <summary>
            World size of the maximum height of the terrain.
            </summary>
        </member>
        <member name="T:Sandbox.TerrainStorage.TerrainMaps">
            <summary>
            Contains terrain maps that get compressed
            </summary>
        </member>
        <member name="T:Sandbox.Texture">
            <summary>
            A texture is an image used in rendering. Can be a static texture loaded from disk, or a dynamic texture rendered to by code.
            Can also be 2D, 3D (multiple slices), or a cube texture (6 slices).
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateCustom">
            <summary>
            Begins creation of a custom texture. Finish by calling <see cref="M:Sandbox.TextureBuilder.Create(System.String,System.Boolean,System.ReadOnlySpan{System.Byte},System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Create(System.Int32,System.Int32,Sandbox.ImageFormat)">
            <summary>
            Begins creation of a custom texture. Finish by calling <see cref="M:Sandbox.Texture2DBuilder.Finish"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateVolume(System.Int32,System.Int32,System.Int32,Sandbox.ImageFormat)">
            <summary>
            Begins creation of a custom 3D texture. Finish by calling <see cref="M:Sandbox.Texture3DBuilder.Finish"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateCube(System.Int32,System.Int32,Sandbox.ImageFormat)">
            <summary>
            Begins creation of a custom cube texture. (A texture with 6 sides) Finish by calling <see cref="M:Sandbox.TextureCubeBuilder.Finish"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateArray(System.Int32,System.Int32,System.Int32,Sandbox.ImageFormat)">
            <summary>
            Begins creation of a custom texture array. Finish by calling <see cref="M:Sandbox.TextureArrayBuilder.Finish"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CreateRenderTarget">
            <summary>
            Begins creation of a <a href="https://en.wikipedia.org/wiki/Render_Target">render target</a>. Finish by calling <see cref="M:Sandbox.TextureBuilder.Create(System.String,System.Boolean,System.ReadOnlySpan{System.Byte},System.Int32)"/>.
            Render targets can be used for fancy things like <see cref="M:Sandbox.Graphics.RenderToTexture(Sandbox.SceneCamera,Sandbox.Texture)"/>.
            </summary>
            <returns>The texture builder to help build the render target.</returns>
        </member>
        <member name="M:Sandbox.Texture.CreateRenderTarget(System.String,Sandbox.ImageFormat,Vector2)">
            <summary>
            A convenience function to quickly create a <a href="https://en.wikipedia.org/wiki/Render_Target">render target</a>.
            Render targets can be used for fancy things like <see cref="M:Sandbox.Graphics.RenderToTexture(Sandbox.SceneCamera,Sandbox.Texture)"/>.
            </summary>
            <param name="name">A meaningless debug name for your texture.</param>
            <param name="format">The image format.</param>
            <param name="size">The size of the texture.</param>
            <returns>The newly created render target texture.</returns>
        </member>
        <member name="M:Sandbox.Texture.CreateRenderTarget(System.String,Sandbox.ImageFormat,Vector2,Sandbox.Texture)">
            <summary>
            This will create a <a href="https://en.wikipedia.org/wiki/Render_Target">render target</a> texture if <paramref name="oldTexture"/> is null or doesn't match what you've passed in. This is designed
            to be called regularly to resize your texture in response to other things changing (like the screen size, panel size etc).
            </summary>
            <param name="name">A meaningless debug name for your texture.</param>
            <param name="format">The image format.</param>
            <param name="size">The size of the texture.</param>
            <param name="oldTexture">A previously created texture.</param>
            <returns>Will return a new texture, or the <paramref name="oldTexture"/>.</returns>
        </member>
        <member name="F:Sandbox.Texture.ParentObject">
            <summary>
            Allow the texture to keep a reference to its parent object (like a videoplayer).
            </summary>
        </member>
        <member name="M:Sandbox.Texture.#ctor(NativeEngine.ITexture)">
            <summary>
            Private constructor, use <see cref="M:Sandbox.Texture.FromNative(NativeEngine.ITexture)"/>
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Index">
            <summary>
            Texture index. Bit raw dog and needs a higher level abstraction.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CopyFrom(Sandbox.Texture)">
            <summary>
            Replace our strong handle with a copy of the strong handle of the passed texture
            Which means that this texture will invisibly become that texture.
            I suspect that there might be a decent way to do this in native using the resource system.
            In which case we should change all this code to use that way instead of doing this.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Width">
            <summary>
            Width of the texture in pixels.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Height">
            <summary>
            Height of the texture in pixels.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Depth">
            <summary>
            Depth of a 3D texture in pixels, or slice count for 2D texture arrays.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Mips">
            <summary>
            Number of <a href="https://en.wikipedia.org/wiki/Mipmap">mip maps</a> this texture has.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Size">
            <summary>
            Returns a Vector2 representing the size of the texture (width, height)
            </summary>
        </member>
        <member name="P:Sandbox.Texture.IsLoaded">
            <summary>
            Whether this texture has finished loading or not.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.ImageFormat">
            <summary>
            Image format of this texture.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.LastUsed">
            <summary>
            Returns how many frames ago this texture was last used by the renderer
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Dispose">
            <summary>
            Will release the handle for this texture. If the texture isn't referenced by anything
            else it'll be released properly. This will happen anyway because it's called in the destructor.
            By calling it manually you're just telling the engine you're done with this texture right now
            instead of waiting for the garbage collector.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.SequenceData">
            <summary>
            If this texture is a sprite sheet, will return information about the sheet, which
            is generally used in the shader. You don't really need to think about the contents.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.SequenceCount">
            <summary>
            The count of sequences in this texture, if any. The rest of the sequence data is encoded into the texture itself.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.GetSequenceFrameCount(System.Int32)">
            <summary>
            Get the frame count for this sequence
            </summary>
        </member>
        <member name="M:Sandbox.Texture.GetSequenceLength(System.Int32)">
            <summary>
            Get the total length of this seqence
            </summary>
        </member>
        <member name="M:Sandbox.Texture.UpdateSheetInfo">
            <summary>
            TODO: Fill this out, build a structure of Sequence[] for people to access
            Then make it so we can actually preview them
            </summary>
        </member>
        <member name="M:Sandbox.Texture.MarkUsed(System.Int32)">
            <summary>
            Tells texture streaming this texture is being used.
            This is usually automatic, but useful for bindless pipelines.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Load(Sandbox.BaseFileSystem,System.String,System.Boolean)">
            <summary>
            Try to load a texture from given filesystem, by filename.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Load(System.String,System.Boolean)">
            <summary>
            Try to load a texture.
            This version is able to load http images - but not images from disk.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.LoadAvatar(System.Int64)">
            <summary>
            Load avatar image of a Steam user.
            </summary>
            <param name="steamid">The SteamID of the user to load avatar of.</param>
            <returns>The avatar texture.</returns>
        </member>
        <member name="M:Sandbox.Texture.LoadAvatar(System.String)">
            <inheritdoc cref="M:Sandbox.Texture.LoadAvatar(System.Int64)"/>
        </member>
        <member name="M:Sandbox.Texture.LoadAsync(Sandbox.BaseFileSystem,System.String,System.Boolean)">
            <summary>
            Load a texture asynchronously. Will return when the texture is loaded and valid.
            This is useful when loading textures from the web.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Find(System.String)">
            <summary>
            Try to get an already loaded texture.
            </summary>
            <param name="filepath">The filename of the texture.</param>
            <returns>The already loaded texture, or null if it was not yet loaded.</returns>
        </member>
        <member name="M:Sandbox.Texture.GetPixels(System.Int32)">
            <summary>
            Reads pixel colors from the texture at the specified mip level
            </summary>
        </member>
        <member name="M:Sandbox.Texture.GetPixels``1(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},System.Int32,System.Int32,System.Span{``0},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Reads a 2D range of pixel values from the texture at the specified mip level, writing to <paramref name="dstData"/>.
            This reads one slice from a 2D texture array or 3D texture volume.
            </summary>
            <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32"/>, <see cref="T:System.Single"/>, <see cref="T:System.UInt32"/> or <see cref="T:System.Byte"/>)</typeparam>
            <param name="srcRect">Pixel region to read.</param>
            <param name="slice">For 2D texture arrays or 3D texture volumes, which slice to read from.</param>
            <param name="mip">Mip level to read from.</param>
            <param name="dstData">Array to write to, starting at index 0 for the first read pixel.</param>
            <param name="dstFormat">Pixel format to use when writing to <paramref name="dstData"/>. We only support some common formats for now.</param>
            <param name="dstSize">Dimensions of destination pixel array. Matches <paramref name="srcRect"/> by default.</param>
        </member>
        <member name="M:Sandbox.Texture.GetPixels3D``1(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32},System.Int32,System.Span{``0},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32,System.Int32})">
            <summary>
            Reads a 3D range of pixel values from the texture at the specified mip level, writing to <paramref name="dstData"/>.
            This can be used with a 2D texture array, or a 3D volume texture.
            </summary>
            <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32"/>, <see cref="T:System.Single"/>, <see cref="T:System.UInt32"/> or <see cref="T:System.Byte"/>)</typeparam>
            <param name="srcBox">Pixel region to read.</param>
            <param name="mip">Mip level to read from.</param>
            <param name="dstData">Array to write to, starting at index 0 for the first read pixel.</param>
            <param name="dstFormat">Pixel format to use when writing to <paramref name="dstData"/>. We only support some common formats for now.</param>
            <param name="dstSize">Dimensions of destination pixel array. Matches <paramref name="srcBox"/> by default.</param>
        </member>
        <member name="M:Sandbox.Texture.GetPixel(System.Single,System.Single,System.Int32)">
            <summary>
            Reads a single pixel color.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.GetPixel3D(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Reads a single pixel color from a volume or array texture.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Invalid">
            <summary>
            1x1 solid magenta colored texture.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.White">
            <summary>
            1x1 solid white opaque texture.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Transparent">
            <summary>
            1x1 fully transparent texture.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Update(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update this texture with given raw data.
            </summary>
            <param name="data">The raw data pixels, appropriate for this textures format.</param>
            <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="width">Width of the image contained in <paramref name="data"/>.</param>
            <param name="height">Height of the image contained in <paramref name="data"/>.</param>
        </member>
        <member name="M:Sandbox.Texture.Update``1(System.ReadOnlySpan{``0},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update this texture with given raw data.
            </summary>
            <param name="data">The raw data pixels, appropriate for this textures format.</param>
            <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="width">Width of the image contained in <paramref name="data"/>.</param>
            <param name="height">Height of the image contained in <paramref name="data"/>.</param>
        </member>
        <member name="M:Sandbox.Texture.Update(System.ReadOnlySpan{Color32},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update this texture with given raw data.
            </summary>
            <param name="data">The raw data pixels, appropriate for this textures format.</param>
            <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="width">Width of the image contained in <paramref name="data"/>.</param>
            <param name="height">Height of the image contained in <paramref name="data"/>.</param>
        </member>
        <member name="M:Sandbox.Texture.Update3D(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Update this 3D texture with given raw data.
            </summary>
            <param name="data">The raw data pixels, appropriate for this textures format.</param>
            <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
            <param name="z">If updating a subsegment of the texture, this will be start coordinates on the target texture.</param>
            <param name="width">Width of the image contained in <paramref name="data"/>.</param>
            <param name="height">Height of the image contained in <paramref name="data"/>.</param>
            <param name="depth">Depth of the image contained in <paramref name="data"/>.</param>
        </member>
        <member name="M:Sandbox.Texture.Update(Color32,Sandbox.Rect)">
            <summary>
            Write a coloured rectangle to the texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Update(Color32,System.Single,System.Single)">
            <summary>
            Write a coloured pixel to the texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithSemiStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithDynamicUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithGPUOnlyUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithUAVBinding">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMips(System.Int32)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Int32)"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithFormat(Sandbox.ImageFormat)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithScreenFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithDepthFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample2X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample4X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample6X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample8X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample16X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithScreenMultiSample">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData(System.Byte[])">
            <inheritdoc cref="M:Sandbox.Texture2DBuilder.WithData(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data.
            </summary>
            <param name="data">Texture data.</param>
            <param name="dataLength">How big our texture data is.</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData``1(System.ReadOnlySpan{``0})">
            <summary>
            Initialize texture with pre-existing texture data.
            </summary>
            <typeparam name="T">Texture data type</typeparam>
            <param name="data">Texture data</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Use Multi-Sample Anti Aliasing (MSAA) of given sample count.
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size.
            </summary>
            <param name="width">Width in pixel.</param>
            <param name="height">Height in pixels.</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithSize(Vector2)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width and Height in pixels</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithSemiStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithDynamicUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithGPUOnlyUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithUAVBinding">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMips(System.Int32)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Int32)"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithFormat(Sandbox.ImageFormat)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithScreenFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithDepthFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample2X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample4X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample6X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample8X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample16X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithScreenMultiSample">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample"/>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithSize(System.Int32,System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
            <param name="depth">Depth in pixels</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithSize(Vector3)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width, Height and Depth in pixels</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithSemiStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithDynamicUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithGPUOnlyUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithUAVBinding">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMips(System.Int32)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Int32)"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithFormat(Sandbox.ImageFormat)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithScreenFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithDepthFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample2X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample4X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample6X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample8X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample16X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithScreenMultiSample">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample"/>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithCount(System.Int32)">
            <summary>
            Create texture array with this many textures
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithStaticUsage">
            <summary>
            Provides a hint to the GPU that this texture will not be modified.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithSemiStaticUsage">
            <summary>
            Provides a hint to the GPU that this texture will only be updated sometimes.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithDynamicUsage">
            <summary>
            Provides a hint to the GPU that this texture will be updated regularly. (almost every frame)
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithGPUOnlyUsage">
            <summary>
            Specify the texture to ONLY be used on the GPU on not allow CPU access.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample2X">
            <summary>
            Sets the texture to use 2x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample4X">
            <summary>
            Sets the texture to use 4x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample6X">
            <summary>
            Sets the texture to use 6x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample8X">
            <summary>
            Sets the texture to use 8x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMultiSample16X">
            <summary>
            Sets the texture to use 16x multisampling.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithScreenMultiSample">
            <summary>
            Sets the texture to use the same multisampling as whatever the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)">
            <summary>
            The internal texture format to use.
            </summary>
            <param name="format">Texture format</param>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithScreenFormat">
            <summary>
            Sets the internal texture format to use the same format as the screen/frame buffer.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithDepthFormat">
            <summary>
            Uses the same depth format as what the screen/framebuffer uses.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithMips(System.Int32)">
            <summary>
            Generate amount of mip levels.
            </summary>
            <param name="mips">How many mips should be generated for this texture</param>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader.
            </summary>
        </member>
        <member name="M:Sandbox.TextureBuilder.Create(System.String,System.Boolean,System.ReadOnlySpan{System.Byte},System.Int32)">
            <summary>
            Finish creating the texture.
            </summary>
            <param name="name">Name for the new texture.</param>
            <param name="anonymous">Whether this texture is anonymous.</param>
            <param name="data">Raw color data in correct format for the texture.</param>
            <param name="dataLength">Length of the <paramref name="data"/>.</param>
            <returns>The created texture.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the texture size is invalid, i.e. less then or equal to 0 on either axis.</exception>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithSemiStaticUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithDynamicUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithGPUOnlyUsage">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithUAVBinding">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMips(System.Int32)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Int32)"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithFormat(Sandbox.ImageFormat)">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithScreenFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithDepthFormat">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample2X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample4X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample6X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample8X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample16X">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithScreenMultiSample">
            <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample"/>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithArrayCount(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithSize(Vector2)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width and Height in pixels</param>
        </member>
        <member name="T:Sandbox.TextureLoader.Avatar">
            <summary>
            Facilitates loading of Steam user avatars.
            </summary>
        </member>
        <member name="F:Sandbox.TextureLoader.ImageUrl.Loaded">
            <summary>
            For textures loaded from the web we want to keep them around a bit longer
            </summary>
        </member>
        <member name="F:Sandbox.VertexBuffer.Vertex">
            <summary>
            List of all vertices in this buffer.
            </summary>
        </member>
        <member name="F:Sandbox.VertexBuffer.Index">
            <summary>
            All indices associated with the vertices of this buffer
            </summary>
        </member>
        <member name="P:Sandbox.VertexBuffer.Indexed">
            <summary>
            Whether this vertex buffer has any indexes. This is set by <see cref="M:Sandbox.VertexBuffer.Init(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.Clear">
            <summary>
            Clear all vertices and indices, and resets <see cref="F:Sandbox.VertexBuffer.Default"/>.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.Init(System.Boolean)">
            <summary>
            Clear the buffer and set whether it will have indices.
            </summary>
            <param name="useIndexBuffer">Whether this buffer will have indices. Affects <see cref="P:Sandbox.VertexBuffer.Indexed"/>.</param>
        </member>
        <member name="M:Sandbox.VertexBuffer.Add(Sandbox.Vertex)">
            <summary>
            Add a vertex
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddIndex(System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count., 1 is Vertex.Count -1
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when <see cref="P:Sandbox.VertexBuffer.Indexed"/> is false.</exception>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddTriangleIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add a triangle by indices. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when <see cref="P:Sandbox.VertexBuffer.Indexed"/> is false.</exception>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddRawIndex(System.Int32)">
            <summary>
            Add an index. This is NOT relative to the top of the vertex buffer.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when <see cref="P:Sandbox.VertexBuffer.Indexed"/> is false.</exception>
        </member>
        <member name="P:Sandbox.CubemapFogController.LodBias">
            <summary>
            Adjust how quickly the cubemap blurs out at closer distances. A value of 0.0 always uses the lowest resolution MIP over the entire range, while a value of 1.0 uses the highest.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.StartDistance">
            <summary>
            The distance from the player at which the fog will start to fade in.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.EndDistance">
            <summary>
            The distance from the player at which the fog will be at full strength.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.FalloffExponent">
            <summary>
            Exponent for distance falloff. For example, 2.0 is proportional to square of distance.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.HeightWidth">
            <summary>
            The distance between the start of the height fog and where it is fully opaque. Setting this to 0 will disable height based blending.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.HeightStart">
            <summary>
            The absolute height in the map at which the height fog will start to fade in.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.HeightExponent">
            <summary>
            Exponent for height falloff. For example, 2.0 is proportional to square of distance.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.Enabled">
            <summary>
            Is this cubemap fog active?
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.Texture">
            <summary>
            Cubemap texture to use for the fog.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.Transform">
            <summary>
            Location of the fog.
            </summary>
        </member>
        <member name="P:Sandbox.CubemapFogController.Tint">
            <summary>
            Tint of the fog. 
            </summary>
        </member>
        <member name="P:Sandbox.GradientFogController.Enabled">
            <summary>
            Whether the fog is enabled.
            </summary>
        </member>
        <member name="P:Sandbox.GradientFogController.StartDistance">
            <summary>
            Start distance of the fog.
            </summary>
        </member>
        <member name="P:Sandbox.GradientFogController.EndDistance">
            <summary>
            End distance of the fog.
            </summary>
        </member>
        <member name="T:Sandbox.ProjectedDecalSceneObject">
            <summary>
            A projected decal. Can be placed in <see cref="T:Sandbox.SceneWorld"/>s.
            </summary>
        </member>
        <member name="P:Sandbox.ProjectedDecalSceneObject.Size">
            <summary>
            The size of the decal. X being the width, Y being the height, and Z being the depth.
            </summary>
        </member>
        <member name="P:Sandbox.ProjectedDecalSceneObject.Material">
            <summary>
            The material for our decal.
            </summary>
        </member>
        <member name="M:Sandbox.ProjectedDecalSceneObject.Update(Sandbox.Material,Vector3)">
            <summary>
            Sets up the cube mesh with the specified material and size
            </summary>
            <param name="material"></param>
            <param name="size"></param>
        </member>
        <member name="T:Sandbox.SceneCamera">
            <summary>
            Represents a camera and holds render hooks. This camera can be used to draw tool windows and scene panels.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Bloom">
            <summary>
            Access tonemapping properties of camera
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.BloomAccessor.Enabled">
            <summary>
            Enable or disable exposure.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Current">
            <summary>
            The current camera that is being rendered
            </summary>
        </member>
        <member name="F:Sandbox.SceneCamera._frustum">
            <summary>
            This is a c++ object with a ton of useful shit.
            Don't access it directly because it might be dirty.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Name">
            <summary>
            The name of this camera.. for debugging purposes.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.ExcludeTags">
            <summary>
            Scene objects with any of these tags won't be rendered by this camera.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.RenderTags">
            <summary>
            Only scene objects with one of these tags will be rendered by this camera.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OnRenderOpaque">
            <summary>
            Called when rendering the transparent pass
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OnRenderTransparent">
            <summary>
            Called when rendering the transparent pass
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OnRenderPostProcess">
            <summary>
            Called when rendering the transparent pass
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OnRenderOverlay">
            <summary>
            Called when rendering the camera's overlay
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Size">
            <summary>
            The size of the screen. Allows us to work out aspect ratio.
            For now will get updated automatically on render.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.VolumetricFog">
            <summary>
            Control volumetric fog parameters, expect this to take 1-2ms of your GPU frame time.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.CubemapFog">
            <summary>
            Control fog based on an image.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.#ctor(System.Int32,System.String)">
             <summary>
             Hidden - allows us to make camera with special lookup indexes
            
              -1 = world main view camera
              -2 = menu, game ui camera
            
             </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.CleanupCollected">
            <summary>
            keep the directory clean by trimming all the old ones
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.World">
            <summary>
            The world we're going to render.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Worlds">
            <summary>
            Your camera can render multiple worlds.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Position">
            <summary>
            The position of the scene's camera.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Rotation">
            <summary>
            The rotation of the scene's camera.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Angles">
            <summary>
            The rotation of the scene's camera.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.FieldOfView">
            <summary>
            The horizontal field of view of the Camera in degrees.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.ZFar">
            <summary>
            The camera's zFar distance. This is the furthest distance this camera will be able to render.
            This value totally depends on the game you're making. Shorter the better, sensible ranges would be
            between about 1000 and 30000, but if you want it to be further out you can balance that out by making
            znear larger.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.ZNear">
            <summary>
            The camera's zNear distance. This is the closest distance this camera will be able to render.
            A good value for this is about 5. Below 5 and particularly below 1 you're going to start to see
            a lot of artifacts like z-fighting.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Ortho">
            <summary>
            Whether to use orthographic projection.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OrthoWidth">
            <summary>
            No longer used
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.OrthoHeight">
            <summary>
            Height of the ortho when <see cref="P:Sandbox.SceneCamera.Ortho"/> is enabled.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.DebugMode">
            <summary>
            Render this camera using a different render mode
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.WireframeMode">
            <summary>
            Render this camera using a wireframe view.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.ClearFlags">
            <summary>
            What kind of clearing should we do before we begin?
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Rect">
            <summary>
            The rect of the screen to render to. This is normalized, between 0 and 1.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.BackgroundColor">
            <summary>
            Color the scene camera clears the render target to.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.AmbientLightColor">
            <summary>
            The color of the ambient light. Set it to black for no ambient light, alpha is used for lerping between IBL and constant color.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.AntiAliasing">
            <summary>
            Enable or disable anti-aliasing for this render.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.EnablePostProcessing">
            <summary>
            Toggle all post processing effects for this camera. The default is on.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TargetEye">
            <summary>
            The HMD eye that this camera is targeting.
            Use <see cref="F:Sandbox.StereoTargetEye.None"/> for the user's monitor (i.e. the companion window).
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.WantsStereoSubmit">
            <summary>
            Set this to false if you don't want the stereo renderer to submit this camera's texture to the compositor.
            This option isn't considered if <see cref="P:Sandbox.SceneCamera.TargetEye"/> is <see cref="F:Sandbox.StereoTargetEye.None"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.EnableDirectLighting">
            <summary>
            Enable or disable direct lighting
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.EnableIndirectLighting">
            <summary>
            Enable or disable indirect lighting
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.OnPreRender(Vector2)">
            <summary>
            Should be called before a render
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.SetViewModelCamera(System.Single,System.Single,System.Single)">
            <summary>
            Set attributes for rendering the viewmodel's camera.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect)">
            <summary>
            Given a pixel rect return a frustum on the current camera.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect,Vector3)">
            <summary>
            Given a pixel rect return a frustum on the current camera. Pass in 1 to ScreenSize to use normalized screen coords.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.GetRay(Vector3)">
            <summary>
            Given a cursor position get a scene aiming ray.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.GetRay(Vector3,Vector3)">
            <summary>
            Given a cursor position get a scene aiming ray.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ToScreen(Vector3)">
            <summary>
            Convert from world coords to screen coords. The results for x and y will be from 0 to <see cref="P:Sandbox.SceneCamera.Size"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ToScreen(Line)">
            <summary>
            Projects a line in world space to screen coords, returning null if the line is
            fully behind the camera.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ToScreenNormal(Vector3)">
            <summary>
            Convert from world coords to normal screen corrds. The results will be between 0 and 1
            </summary>
        </member>
        <member name="M:Sandbox.SceneCamera.ToScreenWithDirection(Vector3)">
            <summary>
            Convert from world coords to screen coords but the Z component stores whether this vector
            is behind the screen (&lt;0) or in front of it (&gt;0). The X and Y components are normalized
            from 0 to 1.
            </summary>
            <param name="world"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SceneCamera.ToWorld(Vector2)">
            <summary>
            Convert from screen coords to world coords on the near frustum plane.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.Tonemap">
            <summary>
            Access tonemapping properties of camera
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.Enabled">
            <summary>
            Enable or disable exposure.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.Rate">
            <summary>
            The rate of change for exposure.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.Fade">
            <summary>
            Set the speed at which exposure fades downwards (diminishes) in response to light changes.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.MinExposure">
            <summary>
            Minimum auto exposure scale
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.MaxExposure">
            <summary>
            Maximum auto exposure scale
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.ExposureCompensation">
            <summary>
            Number of stops to adjust auto-exposure by
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.PercentTarget">
            <summary>
            Set a custom brightness target to go along with 'Target Bright Pixel Percentage'. (-1 for default engine behavior)
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.PercentBrightPixels">
            <summary>
            Set a target for percentage of pixels above a certain brightness. (-1 for default engine behavior)
            </summary>
        </member>
        <member name="P:Sandbox.SceneCamera.TonemapAccessor.MinAverageLuminance">
            <summary>
            Set the minimum average luminance. This ensures that certain regions aren't too dim after tonemapping
            </summary>
        </member>
        <member name="T:Sandbox.ClearFlags">
            <summary>
            Flags for clearing a RT before rendering a scene using a SceneCamera
            </summary>
        </member>
        <member name="T:Sandbox.RenderStage">
             <summary>
             Describes a stage in the pipeline. The pipeline runs in this order:
            
             1. Render opaque sceneobjects
             2. Render skybox sceneobjects
             3. Render transparent sceneobjects (sorted)
             4. Render viewmodel (with adjusted znear/zfar)
             5. Render post processing effects
             6. Render UI
             </summary>
        </member>
        <member name="M:Sandbox.SceneCubemap.RenderDirty">
            <summary>
            Marks the cubemap as dirty, to be re-rendered on the next render.
            </summary>
        </member>
        <member name="T:Sandbox.SceneCullingBox">
            <summary>
            A box which can be used to explicitly control scene visibility. 
            There are two modes:
            1. Cull inside, hide any objects fully inside the box (excluder)
            2. Cull outside, hide any objects not intersecting any cull boxes marked cull outside (includer)
            </summary>
        </member>
        <member name="T:Sandbox.SceneCullingBox.CullMode">
            <summary>
            Cull mode, either inside or outside
            </summary>
        </member>
        <member name="F:Sandbox.SceneCullingBox.CullMode.Inside">
            <summary>
            Hide any objects fully inside the box
            </summary>
        </member>
        <member name="F:Sandbox.SceneCullingBox.CullMode.Outside">
            <summary>
            Hide any objects not intersecting any boxes
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.IsValid">
            <summary>
            Is this culling box valid, exists inside a scene world.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.World">
            <summary>
            The scene world this culling box belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.Transform">
            <summary>
            Position and rotation of this box, scale will scale the box size
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.Size">
            <summary>
            Size of this box, transform scale will scale this size
            </summary>
        </member>
        <member name="P:Sandbox.SceneCullingBox.Mode">
            <summary>
            Cull mode, either inside or outside
            </summary>
        </member>
        <member name="M:Sandbox.SceneCullingBox.#ctor(Sandbox.SceneWorld,Transform,Vector3,Sandbox.SceneCullingBox.CullMode)">
            <summary>
            Create a scene culling box.
            Each scene world can have a list of boxes which can be used to explicitly cull objects inside or outside the boxes.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCullingBox.Delete">
            <summary>
            Delete this culling box. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="T:Sandbox.SceneCustomObject">
            <summary>
            A scene object that allows custom rendering within a scene world.
            </summary>
        </member>
        <member name="F:Sandbox.SceneCustomObject.RenderOverride">
            <summary>
            Called by default version of <see cref="M:Sandbox.SceneCustomObject.RenderSceneObject"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneCustomObject.RenderSceneObject">
            <summary>
            Called when this scene object needs to be rendered.
            Invokes <see cref="F:Sandbox.SceneCustomObject.RenderOverride"/> by default. See the <see cref="T:Sandbox.Graphics" /> library for a starting point.
            </summary>
        </member>
        <member name="T:Sandbox.SceneDirectionalLight">
            <summary>
            A directional scene light that is used to mimic sun light in a <see cref="T:Sandbox.SceneWorld"/>. Direction is controlled by this objects' <see cref="T:Rotation"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneDirectionalLight.SkyColor">
            <summary>
            Ambient light color outside of all light probes.
            </summary>
        </member>
        <member name="P:Sandbox.SceneDirectionalLight.ShadowCascadeCount">
            <summary>
            Control number of shadow cascades
            </summary>
        </member>
        <member name="M:Sandbox.SceneDirectionalLight.SetCascadeDistanceScale(System.Single)">
            <summary>
            Set the max distance of the shadow cascade
            </summary>
        </member>
        <member name="T:Sandbox.SceneFogVolume">
            <summary>
            Represents a volume of fog in a scene, contributing to volumetric fog effects set on <see cref="P:Sandbox.SceneCamera.VolumetricFog"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneFogVolume.Transform">
            <summary>
            The position and rotation of the fog volume in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.SceneFogVolume.BoundingBox">
            <summary>
            Defines the spatial boundaries of the fog volume.
            </summary>
        </member>
        <member name="P:Sandbox.SceneFogVolume.FogStrength">
            <summary>
            The intensity of the fog. Higher values indicate denser fog.
            </summary>
        </member>
        <member name="P:Sandbox.SceneFogVolume.FalloffExponent">
            <summary>
            Controls how quickly the fog fades at the edges of the volume. Higher values give sharper transitions.
            </summary>
        </member>
        <member name="M:Sandbox.SceneFogVolume.Delete">
            <summary>
            Delete this fog volume. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="T:Sandbox.SceneLight">
            <summary>
            Generic point light scene object for use with a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.LightColor">
            <summary>
            Color and brightness of the light
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.Radius">
            <summary>
            Radius of the light in units
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.ConstantAttenuation">
            <summary>
            The light attenuation constant term
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.LinearAttenuation">
            <summary>
            The light attenuation linear term
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.QuadraticAttenuation">
            <summary>
            The light attenuation quadratic term
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.ShadowTextureResolution">
            <summary>
            Get or set the resolution of the shadow map. If this is zero the engine will decide what it should use.
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.ShadowsEnabled">
            <summary>
            Enable or disable shadow rendering
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.LightCookie">
            <summary>
            Access the LightCookie - which is a texture that gets drawn over the light
            </summary>
        </member>
        <member name="T:Sandbox.SceneLightProbe">
            <summary>
            Keep this internal for now
            </summary>
        </member>
        <member name="T:Sandbox.SceneLineObject">
            <summary>
            A scene object which is used to draw lines
            </summary>
        </member>
        <member name="T:Sandbox.SceneMap">
            <summary>
            Map geometry that can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.World">
            <summary>
            The scene world this map belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.IsValid">
            <summary>
            Is the map valid.
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.Bounds">
            <summary>
            Bounds of the map.
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.MapName">
            <summary>
            cs_assault
            </summary>
        </member>
        <member name="P:Sandbox.SceneMap.MapFolder">
            <summary>
            maps/davej/cs_assault
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.#ctor(Sandbox.SceneWorld,System.String)">
            <summary>
            Create a scene map within a scene world.
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.#ctor(Sandbox.SceneWorld,System.String,Sandbox.MapLoader)">
            <summary>
            Create a scene map within a scene world.
            </summary>
        </member>
        <member name="F:Sandbox.SceneMap.OnMapUpdated">
            <summary>
            Invoked when a map file is updated (re-compiled in Hammer.)
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.CreateAsync(Sandbox.SceneWorld,System.String,System.Threading.CancellationToken)">
            <summary>
            Create scene map asynchronously for when large maps take time to load.
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.CreateAsync(Sandbox.SceneWorld,System.String,Sandbox.MapLoader,System.Threading.CancellationToken)">
            <summary>
            Create scene map asynchronously for when large maps take time to load.
            </summary>
        </member>
        <member name="M:Sandbox.SceneMap.Delete">
            <summary>
            Delete this scene map. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="T:Sandbox.SceneModel">
            <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
            <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
            <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
            <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneVelocity(System.Int32,Vector3@,Vector3@)">
            <summary>
            Calculate velocity from previous and current bone transform 
            (I want to expose this public but want to make sure the math is correct first)
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimGraph(System.String)">
            <summary>
            Override the anim graph this scene model uses
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetBoneWorldTransform(System.Int32,Transform)">
            <summary>
            Sets the world space bone transform of a bone by its index.
            </summary>
            <param name="boneIndex">Bone index to set transform of.</param>
            <param name="transform"></param>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneWorldTransform(System.Int32)">
            <summary>
            Returns the world space transform of a bone by its index.
            </summary>
            <param name="boneIndex">Index of the bone to calculate transform of.</param>
            <returns>The world space transform, or an identity transform on failure.</returns>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneWorldTransform(System.String)">
            <summary>
            Returns the world space transform of a bone by its name.
            </summary>
            <param name="boneName">Name of the bone to calculate transform of.</param>
            <returns>The world space transform, or an identity transform on failure.</returns>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneLocalTransform(System.Int32)">
            <summary>
            Returns the local space transform of a bone by its index.
            </summary>
            <param name="boneIndex">Index of the bone to calculate transform of.</param>
            <returns>The local space transform, or an identity transform on failure.</returns>
        </member>
        <member name="M:Sandbox.SceneModel.GetBoneLocalTransform(System.String)">
            <summary>
            Returns the local space transform of a bone by its name.
            </summary>
            <param name="boneName">Name of the bone to calculate transform of.</param>
            <returns>The local space transform, or an identity transform on failure.</returns>
        </member>
        <member name="M:Sandbox.SceneModel.SetMaterialGroup(System.String)">
            <summary>
            Set material group to replace materials of the model as set up in ModelDoc.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetBodyGroup(System.String,System.Int32)">
            <summary>
            Set which body group to use.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetAttachment(System.String,System.Boolean)">
            <summary>
            Get attachment transform by name.
            </summary>
            <param name="name">Name of the attachment to calculate transform of.</param>
            <param name="worldspace">Whether the transform should be in world space (relative to the scene world), or local space (relative to the scene object)</param>
            <returns></returns>
        </member>
        <member name="P:Sandbox.SceneModel.UseAnimGraph">
            <summary>
            Allows the scene model to not use the anim graph so it can play sequences directly
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.RootMotion">
            <summary>
            Get the calculated motion from animgraph since last frame
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.CurrentSequence">
            <summary>
            Allows playback of sequences directly, rather than using an animation graph.
            Requires <see cref="P:Sandbox.SceneModel.UseAnimGraph"/> disabled if the scene model has one.
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.Morphs">
            <summary>
            Access this sceneobject's morph collection. Morphs are generally used in the model to control
            the face, for things like emotions and lip sync.
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.DirectPlayback">
            <summary>
            Access this sceneobject's direct playback. Direct playback is used to control the direct playback node in an animgraph
            to play sequences directly in code
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.OnFootstepEvent">
            <summary>
            Called when a footstep event happens
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.OnGenericEvent">
            <summary>
            Called when a generic event happens
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.OnSoundEvent">
            <summary>
            Called when a sound event happens
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.OnAnimTagEvent">
            <summary>
            Called when a anim tag event happens
            </summary>
        </member>
        <member name="T:Sandbox.SceneModel.AnimTagStatus">
            <summary>
            Enumeration that describes how the AnimGraph tag state changed. Used in <see cref="T:Sandbox.SceneModel.AnimTagEvent"/>.
            </summary>
        </member>
        <member name="F:Sandbox.SceneModel.AnimTagStatus.Fired">
            <summary>
            Tag was activated and deactivated on the same frame
            </summary>
        </member>
        <member name="F:Sandbox.SceneModel.AnimTagStatus.Start">
            <summary>
            The tag has become active
            </summary>
        </member>
        <member name="F:Sandbox.SceneModel.AnimTagStatus.End">
            <summary>
            The tag has become inactive
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,System.Boolean)">
            <summary>
            Sets a boolean animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,System.Single)">
            <summary>
            Sets a float animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,Vector3)">
            <summary>
            Sets a vector animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,System.Int32)">
            <summary>
            Sets a integer animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,Rotation)">
            <summary>
            Sets a rotation animation graph parameter by name.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.ResetAnimParameters">
            <summary>
            Reset all animgraph parameters to their default values.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetRotation(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetVector3(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetBool(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetFloat(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.GetInt(System.String)">
            <summary>
            Get an animated parameter
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.Update(System.Single)">
            <summary>
            Update this animation. Delta is the time you want to advance, usually RealTime.Delta
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.Update(System.Single,System.Action)">
            <summary>
            Update this animation. Delta is the time you want to advance, usually RealTime.Delta
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.UpdateToBindPose">
            <summary>
            Update all of the bones to the bind pose
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.UpdateToBindPose(System.Action)">
            <summary>
            Update all of the bones to the bind pose
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.FinishBoneUpdate">
            <summary>
            Updates attachments, ao proxies etc
            Should be called any time the world transform change
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.MergeBones(Sandbox.SceneModel)">
            <summary>
            Update our bones to match the target's bones. This is a manual bone merge.
            </summary>
        </member>
        <member name="T:Sandbox.SceneObject">
            <summary>
            A model scene object that can be rendered within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.World">
            <summary>
            The scene world this object belongs to.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.Delete">
            <summary>
            Delete this scene object. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Transform">
            <summary>
            Transform of this scene object, relative to its <see cref="P:Sandbox.SceneObject.Parent"/>, or <see cref="T:Sandbox.SceneWorld"/> if parent is not set.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Rotation">
            <summary>
            Rotation of this scene object, relative to its <see cref="P:Sandbox.SceneObject.Parent"/>, or <see cref="T:Sandbox.SceneWorld"/> if parent is not set.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Position">
            <summary>
            Position of this scene object, relative to its <see cref="P:Sandbox.SceneObject.Parent"/>, or <see cref="T:Sandbox.SceneWorld"/> if parent is not set.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Bounds">
            <summary>
            Set or get the axis aligned bounding box for this object.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.LocalBounds">
            <summary>
            The world bounds translated to the local position. Note that this
            does NOT do any scaling or rotation.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.RenderingEnabled">
            <summary>
            Whether this scene object should render or not.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.ColorTint">
            <summary>
            Color tint of this scene object.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.ClipPlane">
            <summary>
            Clipping plane for this scene object. Requires <see cref="P:Sandbox.SceneObject.ClipPlaneEnabled"/> to be <c>true</c>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.ClipPlaneEnabled">
            <summary>
            Whether or not to use the clipping plane defined in <see cref="P:Sandbox.SceneObject.ClipPlane"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Parent">
            <summary>
            Movement parent of this scene object, if any.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.AddChild(System.String,Sandbox.SceneObject)">
            <summary>
            Add a named child scene object to this one. The child scene object will have its parent set.
            </summary>
            <remarks>
            The name can be used to look up children by name, but it is not bound. (SceneObject_FindChild)
            </remarks>
        </member>
        <member name="M:Sandbox.SceneObject.RemoveChild(Sandbox.SceneObject)">
            <summary>
            Unlink given scene object as a child from this one. The child scene object will have its parent set to null. It will not be deleted.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Model">
            <summary>
            The model this scene object will render.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.MeshGroupMask">
            <summary>
            State of all bodygroups of this object's model. You might be looking for <see cref="M:Sandbox.SceneModel.SetBodyGroup(System.String,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.SetMaterialOverride(Sandbox.Material)">
            <summary>
            Override all materials on this object's <see cref="P:Sandbox.SceneObject.Model"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.ClearMaterialOverride">
            <summary>
            Clear all material replacements.
            </summary>
        </member>
        <member name="M:Sandbox.SceneObject.SetMaterialOverride(Sandbox.Material,System.String,System.Int32)">
             <summary>
             Replaces all materials of the model that have the given <b>User Material Attribute</b> set to <b>"1"</b>, with given material.
            
             <para>The system checks both the models' default material group materials and the materials of the active material group.</para>
             </summary>
             <param name="material">Material to replace with.</param>
             <param name="attributeName">Name of the <b>User Material Attribute</b> to test on each material of the model. They are set in the Material Editor's <b>Attributes</b> tab.</param>
             <param name="attributeValue">Value of the attribute to test for.</param>
        </member>
        <member name="M:Sandbox.SceneObject.SetMaterialGroup(System.String)">
            <summary>
            Set material group to replace materials of the model as set up in ModelDoc.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Batchable">
            <summary>
            This object is not batchable by material for some reason ( example: has dynamic attributes that affect rendering )
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.GameObject">
            <summary>
            For storing and retrieving the GameObject this SceneObject belongs to
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Component">
            <summary>
            For storing and retrieving the Component this SceneObject beloings to 
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Flags">
            <summary>
            Access to various advanced scene object flags.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.CastShadows">
            <summary>
            Whether this scene object should cast shadows.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.ExcludeGameLayer">
            <summary>
            Don't render in the opaque/translucent game passes. This is useful when you
            want to only render in the Bloom layer, rather than additionally to it.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.NeedsEnvironmentMap">
            <summary>
            True if this object needs cubemap information
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.WantsFrameBufferCopy">
            <summary>
            Automatically sets the "FrameBufferCopyTexture" attribute within the material.
            This does the same thing as Render.CopyFrameBuffer(); except automatically if
            the pass allows for it.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.RenderLayer">
            <summary>
            For a layer to draw this object, the target layer must match (or be unset)
            and the flags must match
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.Tags">
            <summary>
            List of tags for this scene object.
            </summary>
        </member>
        <member name="T:Sandbox.SceneRenderLayer">
            <summary>
            SceneObjects can be rendered on layers other than the main game layer.
            This is useful if, for example, you want to render on top of everything without
            applying post processing.
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayer.Default">
            <summary>
            Draw wherever makes sense based on the flags, default behaviour
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayer.ViewModel">
            <summary>
            Layer drawn on top of everything else - with altered depth
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayer.OverlayWithDepth">
            <summary>
            Overlay - after post processing - but still with the scene's depth
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayer.OverlayWithoutDepth">
            <summary>
            Overlay - after post processing - without depth (draw over)
            </summary>
        </member>
        <member name="F:Sandbox.SceneRenderLayerHelper.Names">
            <summary>
            Internally we don't pass these enums, they're just string tokens.
            No need to expose the actual string tokens to people unless we expose the render pipeline fully to them.
            </summary>
        </member>
        <member name="T:Sandbox.SceneOrthoLight">
            <summary>
            Keep this internal for now
            </summary>
        </member>
        <member name="T:Sandbox.SceneParticles">
            <summary>
            A SceneObject used to render particles.
            We need to be careful with what we do here, because this object is created for in-engine particles
            as well as custom scene object particles.
            With custom particles there's no automatic Simulate, or deletion.. You're completely on your own. This
            is perhaps a good thing though, it's maybe what you want to happen. To be completely isolated and completely
            in control. But at the same time maybe it's not and it's something we need to sort out.
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.particleCollection">
            <summary>
            TODO: Lets find a way to expose the IParticleCollection a bit raw'er
            </summary>
        </member>
        <member name="M:Sandbox.SceneParticles.#ctor(Sandbox.SceneWorld,System.String)">
            <summary>
            Create scene particles.
            </summary>
            <param name="world">The scene world to create the particles in.</param>
            <param name="particleSystem">Path to the particle system file.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.#ctor(Sandbox.SceneWorld,Sandbox.ParticleSystem)">
            <summary>
            Create scene particles.
            </summary>
            <param name="world">The scene world to create the particles in.</param>
            <param name="particleSystem">Particle system resource.</param>
        </member>
        <member name="P:Sandbox.SceneParticles.RenderParticles">
            <summary>
            Whether to render the particles or not.
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.EmissionStopped">
            <summary>
            Stop (or start) the particle system emission.
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.PhysicsWorld">
            <summary>
            Particle collisions use this physics world to perform traces.
            </summary>
        </member>
        <member name="M:Sandbox.SceneParticles.IsControlPointSet(System.Int32)">
            <summary>
            Whether given control point has any data set.
            </summary>
            <param name="index">The control point index. Range is 0-63.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.GetControlPointPosition(System.Int32)">
            <summary>
            Returns the position set on a given control point.
            </summary>
            <param name="index">The control point index. Range is 0-63.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Vector3)">
            <summary>
            Set position on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="position">The position to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Rotation)">
            <summary>
            Set rotation on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="rotation">The rotation to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Transform)">
            <summary>
            Set transform on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="transform">The transform to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Sandbox.ParticleSnapshot)">
            <summary>
            Set snapshot on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="snapshot">The snapshot to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Sandbox.Model)">
            <summary>
            Set model on given control point.
            </summary>
            <param name="i">The control point index. Range is 0-63.</param>
            <param name="model">The model to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.SetNamedValue(System.String,Vector3)">
            <summary>
            Set vector on given named value.
            </summary>
            <param name="name">The name of the key.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Sandbox.SceneParticles.Simulate(System.Single)">
            <summary>
            Simulate the particles for given amount of time.
            </summary>
            <param name="f">Amount of time has passed since last simulation.</param>
        </member>
        <member name="P:Sandbox.SceneParticles.ActiveParticlesSelf">
            <summary>
            The amount of particles 
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.ActiveParticlesTotal">
            <summary>
            The amount of particles including child systems
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.MaximumParticles">
            <summary>
            The total allowed particle count
            </summary>
        </member>
        <member name="M:Sandbox.SceneParticles.Emit(System.Int32)">
            <summary>
            Manually emit a bunch of particles
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.Finished">
            <summary>
            True if particle system has reached the end
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.SimulationTime">
            <summary>
            Get or set the simulation time
            </summary>
        </member>
        <member name="T:Sandbox.SceneSkyBox">
            <summary>
            Renders a skybox within a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSkyBox.SkyMaterial">
            <summary>
            The skybox material. Typically it should use the "Sky" shader.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSkyBox.SkyTint">
            <summary>
            Skybox color tint.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSkyBox.FogParams">
            <summary>
            Controls the skybox specific fog.
            </summary>
        </member>
        <member name="M:Sandbox.SceneSkybox3D.Delete">
            <summary>
            Delete this fog volume. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="T:Sandbox.SceneSpotLight">
            <summary>
            A simple spot light scene object for use in a <see cref="T:Sandbox.SceneWorld"/>.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSpotLight.ConeInner">
            <summary>
            The inner cone of the spotlight, in degrees.
            </summary>
        </member>
        <member name="P:Sandbox.SceneSpotLight.ConeOuter">
            <summary>
            The outer cone of the spotlight, in degrees
            </summary>
        </member>
        <member name="T:Sandbox.SceneTrailObject">
            <summary>
            I don't want to expose SceneObjects to people anymore. They should be using the scene system.
            It's better if we can keep things internal so we don't have the burden of supporting api layout.
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrailObject.MaxPoints">
            <summary>
            Total maximum points we're allowing
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrailObject.PointDistance">
            <summary>
            Wait until we're this far away before adding a new point
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrailObject.Texturing">
            <summary>
            Texture details, in a nice stuct to hide the bs
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrailObject.LifeTime">
            <summary>
            How long the trail lasts - or 0 for infinite
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrailObject.TryAddPosition(Vector3)">
            <summary>
            Try to add a position to this trail. Returns true on success.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrailObject.AdvanceTime(System.Single)">
            <summary>
            Advance the time for this trail. Will fade out points and scoll the texture.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrailObject.Build">
            <summary>
            Build the vertices for this object.
            TODO: We can move this to build automatically in a thread
            </summary>
        </member>
        <member name="T:Sandbox.TrailTextureConfig">
            <summary>
            Defines how a trail is going to be textured. Used by TrailRenderer.
            </summary>
        </member>
        <member name="T:Sandbox.SceneWorld">
             <summary>
             A scene world that contains <see cref="T:Sandbox.SceneObject"/>s. See <a href="https://sbox.game/api/Tools.Utility.CreateSceneWorld()">Utility.CreateSceneWorld</a>.
            
             <para>You may also want a <see cref="T:Sandbox.SceneCamera"/> to manually render the scene world.</para>
             </summary>
        </member>
        <member name="P:Sandbox.SceneWorld.SceneObjects">
            <summary>
            List of scene objects belonging to this scene world.
            </summary>
        </member>
        <member name="F:Sandbox.SceneWorld.GradientFog">
            <summary>
            Controls gradient fog settings.
            </summary>
        </member>
        <member name="F:Sandbox.SceneWorld.AmbientLightColor">
            <summary>
            Sets the ambient lighting color
            </summary>
        </member>
        <member name="F:Sandbox.SceneWorld.ClearColor">
            <summary>
            Sets the clear color, if nothing else is drawn, this is the color you will see
            </summary>
        </member>
        <member name="P:Sandbox.SceneWorld.IsTransient">
            <summary>
            If a world is transient, it means it was created by game code, and should
            be deleted at the end of the game session. If they're non transient then
            they were created in the menu, or by the engine code and will be released
            properly by that code.
            </summary>
        </member>
        <member name="M:Sandbox.SceneWorld.Delete">
            <summary>
            Delete this scene world. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="M:Sandbox.SceneWorld.SetWorldAttributes(Sandbox.RenderAttributes)">
            <summary>
            Any components we add to the sceneworld will want to install attributes
            into the RenderAttributes for the pipeline to find. This should be called
            right before rendering to allow that to happen.
            </summary>
        </member>
        <member name="M:Sandbox.SceneWorld.DeletePendingObjects">
            <summary>
            Deleted objects are actually deleted at the end of each frame. Call this
            to actually delete pending deletes right now instead of waiting. 
            </summary>
        </member>
        <member name="M:Sandbox.SceneWorld.UpdateObjectsForRendering(Vector3,System.Single)">
            <summary>
            This finishes any loads and actually spawns the world sceneobjects
            </summary>
        </member>
        <member name="M:Sandbox.SceneWorld.AddSceneMap(Sandbox.SceneMap)">
            <summary>
            Add a scenemap to this world
            </summary>
        </member>
        <member name="P:Sandbox.SceneWorld.Trace">
            <summary>
            Trace against all scene objects in this scene world
            </summary>
        </member>
        <member name="F:Sandbox.StereoTargetEye.None">
            <summary>
            Don't render in stereo
            </summary>
        </member>
        <member name="F:Sandbox.StereoTargetEye.LeftEye">
            <summary>
            Only render the left eye
            </summary>
        </member>
        <member name="F:Sandbox.StereoTargetEye.RightEye">
            <summary>
            Only render the right eye
            </summary>
        </member>
        <member name="F:Sandbox.StereoTargetEye.Both">
            <summary>
            Render both eyes in stereo
            </summary>
        </member>
        <member name="P:Sandbox.EditorContext.Target">
            <summary>
            The current entity we're rendering gizmos for
            </summary>
        </member>
        <member name="P:Sandbox.EditorContext.IsSelected">
            <summary>
            If the current entity we're drawing selected
            </summary>
        </member>
        <member name="P:Sandbox.EditorContext.Selection">
            <summary>
            All selected entities
            </summary>
        </member>
        <member name="M:Sandbox.EditorContext.FindTarget(System.String)">
            <summary>
            Given a string name return the first found target
            </summary>
        </member>
        <member name="M:Sandbox.EditorContext.FindTargets(System.String)">
            <summary>
            Given a string name return all found targets
            </summary>
        </member>
        <member name="M:Sandbox.Services.Auth.GetCallingPackage(System.Reflection.Assembly)">
            <summary>
            We want to find out what assembly is calling us. 
            That's the package that is gonna recieve the stats.
            This works and takes around 0.01ms. We could probably get
            around that using codegen.. but we don't want to do that in 
            a way that is going to let people call this with arbituary values.
            
            We should also think about a way to send this package's version 
            along with the stat. That way we could ignore values that were
            created with bullshit, unreleased versions etc. To this this I'd
            store some global lookup list with every assembly that we loaded
            and their chain of custody. Add to the list when loading in any context
            and remove from the list when unloading.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Auth.GetToken(System.String,System.Threading.CancellationToken)">
            <summary>
            Get an auth token, which can be passed to the backend
            </summary>
        </member>
        <member name="T:Sandbox.Services.BenchmarkSystem">
            <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.Start(System.String)">
            <summary>
            Called to start a benchmark
            </summary>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.SetMetric(System.String,System.Double)">
            <summary>
            Set a custom metric, like load time, shutdown time etc
            </summary>
            <param name="name"></param>
            <param name="metric"></param>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.Finish">
            <summary>
            Called to close a benchmark off
            </summary>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.Sample">
            <summary>
            Should be called in update every frame
            </summary>
        </member>
        <member name="M:Sandbox.Services.BenchmarkSystem.SendAsync(System.Threading.CancellationToken)">
            <summary>
            Finish this benchmark session and send it off to the backend
            </summary>
        </member>
        <member name="M:Sandbox.Services.Leaderboards.GetCallingPackage(System.Reflection.Assembly)">
            <summary>
            We want to find out what assembly is calling us. 
            That's the package that is gonna recieve the stats.
            This works and takes around 0.01ms. We could probably get
            around that using codegen.. but we don't want to do that in 
            a way that is going to let people call this with arbituary values.
            
            We should also think about a way to send this package's version 
            along with the stat. That way we could ignore values that were
            created with bullshit, unreleased versions etc. To this this I'd
            store some global lookup list with every assembly that we loaded
            and their chain of custody. Add to the list when loading in any context
            and remove from the list when unloading.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.TargetSteamId">
            <summary>
            The steamid to get information about. If unset then this defaults to the current player.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.MaxEntries">
            <summary>
            The maximum entries to respond with.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Group">
            <summary>
            global, country, friends
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Title">
            <summary>
            The group name of this board. For example, "Global" for global, "Friends" for friends.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.DisplayName">
            <summary>
            The display name of this board, which was set in the backend.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Description">
            <summary>
            The description of this board, which was set in the backend.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.TotalEntries">
            <summary>
            The total number of chart entries for this board.
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Unit">
            <summary>
            The unit type chosen for this board
            </summary>
        </member>
        <member name="P:Sandbox.Services.Leaderboards.Board.Entries">
            <summary>
            The group of entries for this board. This is usually the entries that surround
            the TargetSteamId.
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.Me">
            <summary>
            True if this entry is for the current player.
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.Rank">
            <summary>
            The rank in the board
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.Value">
            <summary>
            The value in the board
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.FormattedValue">
            <summary>
            The value, but formatted according to Unit
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.SteamId">
            <summary>
            The steamid of the entry
            </summary>
        </member>
        <member name="F:Sandbox.Services.Leaderboards.Entry.DisplayName">
            <summary>
            The player's display name
            </summary>
        </member>
        <member name="F:Sandbox.Services.Messaging.incoming">
            <summary>
            Store the messages from the other thread so we can process them 
            on the main thread, at an appropriate time in the loop
            </summary>
        </member>
        <member name="T:Sandbox.Services.ServerList.Entry">
            <summary>
            This is a cleaned up version of gameserveritem_t
            </summary>
        </member>
        <member name="T:Sandbox.Services.gameserveritem_t">
            <summary>
            Data from c++
            We skip the steamid because there's some class padding fuckery going on.
            We pass that in manually to make life easier.
            </summary>
        </member>
        <member name="T:Sandbox.Services.Stats">
            <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GetCallingPackage(System.Reflection.Assembly)">
            <summary>
            We want to find out what assembly is calling us. 
            That's the package that is gonna recieve the stats.
            This works and takes around 0.01ms. We could probably get
            around that using codegen.. but we don't want to do that in 
            a way that is going to let people call this with arbituary values.
            
            We should also think about a way to send this package's version 
            along with the stat. That way we could ignore values that were
            created with bullshit, unreleased versions etc. To this this I'd
            store some global lookup list with every assembly that we loaded
            and their chain of custody. Add to the list when loading in any context
            and remove from the list when unloading.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.FlushAsync(System.Threading.CancellationToken)">
            <summary>
            Send any pending stats to the backend. Don't wait for confirmation of ingestiom, fire and forget.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.Flush">
            <summary>
            Send any pending stats to the backend. Don't wait for confirmation of ingestiom, fire and forget.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.FlushAndWaitAsync(System.Threading.CancellationToken)">
            <summary>
            Send any pending stats to the backend, will wait until they're available for query before finishing.
            </summary>
        </member>
        <member name="F:Sandbox.Services.Stats._globalStats">
            <summary>
            Static cache of all the global stats
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.Global">
            <summary>
            Get the global stats for the calling package
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GetGlobalStats(System.String)">
            <summary>
            Get the global stats for this package
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStats.IsRefreshing">
            <summary>
            True if we're currently fetching new stats
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStats.LastRefresh">
            <summary>
            The UTC datetime when we last fetched new stats
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GlobalStats.Copy">
            <summary>
            Make a copy of this class. Allows you to store the stats from a point in time.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GlobalStats.Get(System.String)">
            <summary>
            Get a stat by name. Will return an empty stat if not found
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GlobalStats.TryGet(System.String,Sandbox.Services.Stats.GlobalStat@)">
            <summary>
            Get a stat by name, returns true if found
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GlobalStats.Refresh">
            <summary>
            Refresh these global stats - grab the latest values
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Name">
            <summary>
            The programatic name for this stat. This should probably be called Ident
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Title">
            <summary>
            The title of this stat, as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Description">
            <summary>
            The description of this stat, as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Unit">
            <summary>
            The unit of this stat as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Velocity">
            <summary>
            The change in this stat in units per hour
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Value">
            <summary>
            The current stat value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.ValueString">
            <summary>
            The current value formatted using Unit
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.GlobalStat.Players">
            <summary>
            The amount of players that have this stat
            </summary>
        </member>
        <member name="F:Sandbox.Services.Stats._playerStats">
            <summary>
            Static cache of all the global stats
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.LocalPlayer">
            <summary>
            Get the global stats for the calling package
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GetLocalPlayerStats(System.String)">
            <summary>
            Get the global stats for this package
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.GetPlayerStats(System.String,System.Int64)">
            <summary>
            Get the stats for this package
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStats.IsRefreshing">
            <summary>
            True if we're currently fetching new stats
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStats.LastRefresh">
            <summary>
            The UTC datetime when we last fetched new stats
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.PlayerStats.Copy">
            <summary>
            Make a copy of this class. Allows you to store the stats from a point in time.
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.PlayerStats.Get(System.String)">
            <summary>
            Get a stat by name. Will return an empty stat if not found
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.PlayerStats.TryGet(System.String,Sandbox.Services.Stats.PlayerStat@)">
            <summary>
            Get a stat by name, returns true if found
            </summary>
        </member>
        <member name="M:Sandbox.Services.Stats.PlayerStats.Refresh">
            <summary>
            Refresh these global stats - grab the latest values
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Name">
            <summary>
            The programatic name for this stat. This should probably be called Ident
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Title">
            <summary>
            The title of this stat, as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Description">
            <summary>
            The description of this stat, as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Unit">
            <summary>
            The unit of this stat as defined on the backend
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.Value">
            <summary>
            The current stat value
            </summary>
        </member>
        <member name="P:Sandbox.Services.Stats.PlayerStat.ValueString">
            <summary>
            The current value formatted using Unit
            </summary>
        </member>
        <member name="P:Sandbox.Standalone.Manifest">
            <summary>
            If running in standalone, contains the properties of the standalone game
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.Name">
            <summary>
            What is the game's name?
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.Ident">
            <summary>
            What ident are we running under?
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.ExecutableName">
            <summary>
            Game's executable name (e.g. game.exe)
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.EnabledAddons">
            <summary>
            Which addons are we shipping with?
            </summary>
        </member>
        <member name="P:Sandbox.StandaloneManifest.AppId">
            <summary>
            The Steam App ID of the game
            </summary>
        </member>
        <member name="M:Sandbox.StreamPoll.End(System.Boolean)">
            <summary>
            End this poll, you can optionally archive the poll, otherwise just terminate it
            </summary>
        </member>
        <member name="M:Sandbox.StreamPrediction.Lock">
            <summary>
            Lock this prediction
            </summary>
        </member>
        <member name="M:Sandbox.StreamPrediction.Cancel">
            <summary>
            Cancel this prediction
            </summary>
        </member>
        <member name="M:Sandbox.StreamPrediction.Resolve">
            <summary>
            Resolve this prediction and choose winning outcome to pay out channel points
            </summary>
        </member>
        <member name="P:Sandbox.StreamUser.Following">
            <summary>
            Get following "Who is following us"
            </summary>
        </member>
        <member name="P:Sandbox.StreamUser.Followers">
            <summary>
            Get followers "Who are we following"
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.Ban(System.String,System.Int32)">
            <summary>
            Ban user from your chat, the user will no longer be able to chat.
            Optionally specify the duration, a duration of zero means perm ban
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.Unban">
            <summary>
            Unban user from your chat, this allows them to chat again
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.CreateClip(System.Boolean)">
            <summary>
            Create a clip of our stream, if we're streaming
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.CreatePoll(System.String,System.Int32,System.String[])">
            <summary>
            Start a poll on our channel with multiple choices, save the poll so you can end it later on
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.CreatePrediction(System.String,System.Int32,System.String,System.String)">
            <summary>
            Create a prediction on our channel to bet with channel points
            </summary>
        </member>
        <member name="P:Sandbox.Twitch.IRCMessage.Channel">
            <summary>
            The channel the message was sent in
            </summary>
        </member>
        <member name="P:Sandbox.Twitch.IRCMessage.Message">
            <summary>
            Message itself
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage._parameters">
            <summary>
            Command parameters
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.User">
            <summary>
            The user whose message it is
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.Hostmask">
            <summary>
            Hostmask of the user
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.Command">
            <summary>
            Raw Command
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.Tags">
            <summary>
            IRCv3 tags
            </summary>
        </member>
        <member name="M:Sandbox.Twitch.IRCMessage.#ctor(System.String)">
            <summary>
            Create an INCOMPLETE IrcMessage only carrying username
            </summary>
            <param name="user"></param>
        </member>
        <member name="M:Sandbox.Twitch.IRCMessage.#ctor(Sandbox.Twitch.IRCCommand,System.String[],System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Create an IrcMessage
            </summary>
            <param name="command">IRC Command</param>
            <param name="parameters">Command params</param>
            <param name="hostmask">User</param>
            <param name="tags">IRCv3 tags</param>
        </member>
        <member name="M:Sandbox.Twitch.IRCParser.Parse(System.String)">
            <summary>
            Parses a raw IRC message into a IRCMessage.
            </summary>
        </member>
        <member name="P:Sandbox.Tasks.ExpirableSynchronizationContext.HasExpired">
            <summary>
            When true, any continuations that attempt to run on this instance will
            log an exception, unless whitelisted by <see cref="M:Sandbox.Tasks.ExpirableSynchronizationContext.AllowPersistentTaskMethods(System.Reflection.Assembly)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.ExpirableSynchronizationContext.#ctor(System.Boolean)">
            <param name="warnNonYieldingTasks">If true, warn when tasks don't yield after <see cref="F:Sandbox.Tasks.ExpirableSynchronizationContext.MaxTimeBetweenYieldsMillis"/>.</param>
        </member>
        <member name="M:Sandbox.Tasks.ExpirableSynchronizationContext.WatchDogAsync">
            <summary>
            Logs a warning if any actions posted to this sync context take
            too long before returning.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.ExpirableSynchronizationContext.CheckValid(System.Object,System.Boolean@)">
            <summary>
            Returns true if <see cref="P:Sandbox.Tasks.ExpirableSynchronizationContext.HasExpired"/> is false, or if <paramref name="state"/> represents
            a task method that is allowed to persist after context expiry. Logs an error otherwise.
            </summary>
        </member>
        <member name="P:Sandbox.Tasks.SyncContext.MainThread">
            <summary>
            Current sync context for the main thread. This will be null until <see cref="M:Sandbox.Tasks.SyncContext.Init"/> has been
            called for the first time.
            </summary>
        </member>
        <member name="P:Sandbox.Tasks.SyncContext.WorkerThread">
            <summary>
            Current sync context for worker threads. This will be null until <see cref="M:Sandbox.Tasks.SyncContext.Init"/> has been
            called for the first time.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.SyncContext.Init">
            <summary>
            Sets both <see cref="P:Sandbox.Tasks.SyncContext.MainThread"/> and <see cref="P:System.Threading.SynchronizationContext.Current"/> to be a new
            instance of <see cref="T:Sandbox.Tasks.ExpirableSynchronizationContext"/>. Only has an effect the first time it's called.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.SyncContext.Reset">
            <summary>
            Invalidates <see cref="P:Sandbox.Tasks.SyncContext.MainThread"/> and <see cref="P:Sandbox.Tasks.SyncContext.WorkerThread"/>, and replaces
            them with a new instance.
            Any tasks that try to continue on the old instances will log an error, unless they
            are whitelisted with <see cref="M:Sandbox.Tasks.ExpirableSynchronizationContext.AllowPersistentTaskMethods(System.Reflection.Assembly)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.SyncContext.RunBlocking(System.Threading.Tasks.Task)">
            <summary>
            Run an async task in a synchronous blocking manner.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.SyncContext.RunBlocking``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Run an async task in a synchronous blocking manner and returns the result.
            </summary>
        </member>
        <member name="M:Sandbox.Tasks.WorkerThread.Start">
            <summary>
            Starts a bunch of long-running tasks in the worker thread pool that
            keep calling <see cref="M:Sandbox.Tasks.ExpirableSynchronizationContext.ProcessQueue"/> on
            <see cref="P:Sandbox.Tasks.SyncContext.WorkerThread"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if tasks are already running.</exception>
        </member>
        <member name="M:Sandbox.Tasks.WorkerThread.Stop(System.Int32)">
            <summary>
            Forces the tasks created by <see cref="M:Sandbox.Tasks.WorkerThread.Start"/> to cancel, to be restarted later.
            This doesn't cancel tasks created with Sandbox.TaskSource.RunInThreadAsync, they
            just get suspended until <see cref="M:Sandbox.Tasks.WorkerThread.Start"/> is called again.
            </summary>
            <param name="millisecondsTimeout">
            Log an error if any tasks take longer than this to return.
            </param>
        </member>
        <member name="T:Sandbox.MainThread">
            <summary>
            Utility functions that revolve around the main thread
            </summary>
        </member>
        <member name="M:Sandbox.MainThread.Run``1(System.Int32,System.Func{``0})">
            <summary>
            Run a function on the main thread and wait for the result.
            </summary>
        </member>
        <member name="M:Sandbox.MainThread.Queue(System.Action)">
            <summary>
            When running in another thread you can queue a method to run in the main thread.
            If you are on the main thread we will execute the method immediately and return.
            </summary>
        </member>
        <member name="M:Sandbox.MainThread.RunMainThreadQueues">
            <summary>
            Run queued actions on the main thread
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse0">
            <summary>
            Left Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse1">
            <summary>
            Muddle Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse2">
            <summary>
            Right Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse3">
            <summary>
            Back Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse4">
            <summary>
            Forward Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelInputType.UI">
            <summary>
            Regular expected behaviour.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelInputType.Game">
            <summary>
            Redirect to the game's Input system
            </summary>
        </member>
        <member name="T:Sandbox.UI.BaseStyles">
            <summary>
            Auto generated container class for majority of CSS properties available.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.Dirty">
            <summary>
            Called when any CSS properties are changed.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Overflow">
            <summary>
            Represents the <c>overflow</c> CSS property.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.Add(Sandbox.UI.BaseStyles)">
            <summary>
            Copy over only the styles that are set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.From(Sandbox.UI.BaseStyles)">
            <summary>
            Copy all styles from given style set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.Set(System.String,System.String)">
            <summary>
            Copy all styles from given style set.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Content">
            <summary>
            Represents the <c>content</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Width">
            <summary>
            Represents the <c>width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MinWidth">
            <summary>
            Represents the <c>min-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaxWidth">
            <summary>
            Represents the <c>max-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Height">
            <summary>
            Represents the <c>height</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MinHeight">
            <summary>
            Represents the <c>min-height</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaxHeight">
            <summary>
            Represents the <c>max-height</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Left">
            <summary>
            Represents the <c>left</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Top">
            <summary>
            Represents the <c>top</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Right">
            <summary>
            Represents the <c>right</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Bottom">
            <summary>
            Represents the <c>bottom</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Opacity">
            <summary>
            Represents the <c>opacity</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundColor">
            <summary>
            Represents the <c>background-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PaddingLeft">
            <summary>
            Represents the <c>padding-left</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PaddingTop">
            <summary>
            Represents the <c>padding-top</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PaddingRight">
            <summary>
            Represents the <c>padding-right</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PaddingBottom">
            <summary>
            Represents the <c>padding-bottom</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MarginLeft">
            <summary>
            Represents the <c>margin-left</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MarginTop">
            <summary>
            Represents the <c>margin-top</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MarginRight">
            <summary>
            Represents the <c>margin-right</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MarginBottom">
            <summary>
            Represents the <c>margin-bottom</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderTopLeftRadius">
            <summary>
            Represents the <c>border-top-left-radius</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderTopRightRadius">
            <summary>
            Represents the <c>border-top-right-radius</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderBottomRightRadius">
            <summary>
            Represents the <c>border-bottom-right-radius</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderBottomLeftRadius">
            <summary>
            Represents the <c>border-bottom-left-radius</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderLeftWidth">
            <summary>
            Represents the <c>border-left-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderTopWidth">
            <summary>
            Represents the <c>border-top-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderRightWidth">
            <summary>
            Represents the <c>border-right-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderBottomWidth">
            <summary>
            Represents the <c>border-bottom-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderLeftColor">
            <summary>
            Represents the <c>border-left-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderTopColor">
            <summary>
            Represents the <c>border-top-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderRightColor">
            <summary>
            Represents the <c>border-right-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderBottomColor">
            <summary>
            Represents the <c>border-bottom-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontSize">
            <summary>
            Represents the <c>font-size</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontColor">
            <summary>
            Represents the <c>font-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontWeight">
            <summary>
            Represents the <c>font-weight</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontFamily">
            <summary>
            Represents the <c>font-family</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Cursor">
            <summary>
            Represents the <c>cursor</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PointerEvents">
            <summary>
            Represents the <c>pointer-events</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MixBlendMode">
            <summary>
            Represents the <c>mix-blend-mode</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Position">
            <summary>
            Represents the <c>position</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.OverflowX">
            <summary>
            Represents the <c>overflow-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.OverflowY">
            <summary>
            Represents the <c>overflow-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexDirection">
            <summary>
            Represents the <c>flex-direction</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.JustifyContent">
            <summary>
            Represents the <c>justify-content</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Display">
            <summary>
            Represents the <c>display</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexWrap">
            <summary>
            Represents the <c>flex-wrap</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AlignContent">
            <summary>
            Represents the <c>align-content</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AlignSelf">
            <summary>
            Represents the <c>align-self</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AlignItems">
            <summary>
            Represents the <c>align-items</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexBasis">
            <summary>
            Represents the <c>flex-basis</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexGrow">
            <summary>
            Represents the <c>flex-grow</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FlexShrink">
            <summary>
            Represents the <c>flex-shrink</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.RowGap">
            <summary>
            Represents the <c>row-gap</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.ColumnGap">
            <summary>
            Represents the <c>column-gap</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AspectRatio">
            <summary>
            Represents the <c>aspect-ratio</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextAlign">
            <summary>
            Represents the <c>text-align</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextOverflow">
            <summary>
            Represents the <c>text-overflow</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.WordBreak">
            <summary>
            Represents the <c>word-break</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationLine">
            <summary>
            Represents the <c>text-decoration-line</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationColor">
            <summary>
            Represents the <c>text-decoration-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationThickness">
            <summary>
            Represents the <c>text-decoration-thickness</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationSkipInk">
            <summary>
            Represents the <c>text-decoration-skip-ink</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextDecorationStyle">
            <summary>
            Represents the <c>text-decoration-style</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextUnderlineOffset">
            <summary>
            Represents the <c>text-underline-offset</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextOverlineOffset">
            <summary>
            Represents the <c>text-overline-offset</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextLineThroughOffset">
            <summary>
            Represents the <c>text-line-through-offset</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontStyle">
            <summary>
            Represents the <c>font-style</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Transform">
            <summary>
            Represents the <c>transform</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextTransform">
            <summary>
            Represents the <c>text-transform</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TransformOriginX">
            <summary>
            Represents the <c>transform-origin-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TransformOriginY">
            <summary>
            Represents the <c>transform-origin-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.LetterSpacing">
            <summary>
            Represents the <c>letter-spacing</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.LineHeight">
            <summary>
            Represents the <c>line-height</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.WordSpacing">
            <summary>
            Represents the <c>word-spacing</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.WhiteSpace">
            <summary>
            Represents the <c>white-space</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.ZIndex">
            <summary>
            Represents the <c>z-index</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.Order">
            <summary>
            Represents the <c>order</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.SoundIn">
            <summary>
            Represents the <c>sound-in</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.SoundOut">
            <summary>
            Represents the <c>sound-out</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterBlur">
            <summary>
            Represents the <c>backdrop-filter-blur</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterBrightness">
            <summary>
            Represents the <c>backdrop-filter-brightness</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterContrast">
            <summary>
            Represents the <c>backdrop-filter-contrast</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterSaturate">
            <summary>
            Represents the <c>backdrop-filter-saturate</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterSepia">
            <summary>
            Represents the <c>backdrop-filter-sepia</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterInvert">
            <summary>
            Represents the <c>backdrop-filter-invert</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackdropFilterHueRotate">
            <summary>
            Represents the <c>backdrop-filter-hue-rotate</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterBlur">
            <summary>
            Represents the <c>filter-blur</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterSaturate">
            <summary>
            Represents the <c>filter-saturate</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterSepia">
            <summary>
            Represents the <c>filter-sepia</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterBrightness">
            <summary>
            Represents the <c>filter-brightness</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterHueRotate">
            <summary>
            Represents the <c>filter-hue-rotate</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterInvert">
            <summary>
            Represents the <c>filter-invert</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterContrast">
            <summary>
            Represents the <c>filter-contrast</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterTint">
            <summary>
            Represents the <c>filter-tint</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterBorderWidth">
            <summary>
            Represents the <c>filter-border-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FilterBorderColor">
            <summary>
            Represents the <c>filter-border-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskMode">
            <summary>
            Represents the <c>mask-mode</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskRepeat">
            <summary>
            Represents the <c>mask-repeat</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskSizeX">
            <summary>
            Represents the <c>mask-size-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskSizeY">
            <summary>
            Represents the <c>mask-size-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskPositionX">
            <summary>
            Represents the <c>mask-position-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskPositionY">
            <summary>
            Represents the <c>mask-position-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskAngle">
            <summary>
            Represents the <c>mask-angle</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.MaskScope">
            <summary>
            Represents the <c>mask-scope</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundSizeX">
            <summary>
            Represents the <c>background-size-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundSizeY">
            <summary>
            Represents the <c>background-size-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundPositionX">
            <summary>
            Represents the <c>background-position-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundPositionY">
            <summary>
            Represents the <c>background-position-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundRepeat">
            <summary>
            Represents the <c>background-repeat</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthLeft">
            <summary>
            Represents the <c>border-image-width-left</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthRight">
            <summary>
            Represents the <c>border-image-width-right</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthTop">
            <summary>
            Represents the <c>border-image-width-top</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthBottom">
            <summary>
            Represents the <c>border-image-width-bottom</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageFill">
            <summary>
            Represents the <c>border-image-fill</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageRepeat">
            <summary>
            Represents the <c>border-image-repeat</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BorderImageTint">
            <summary>
            Represents the <c>border-image-tint</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundBlendMode">
            <summary>
            Represents the <c>background-blend-mode</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundTint">
            <summary>
            Represents the <c>background-tint</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.BackgroundAngle">
            <summary>
            Represents the <c>background-angle</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextBackgroundAngle">
            <summary>
            Represents the <c>text-background-angle</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PerspectiveOriginX">
            <summary>
            Represents the <c>perspective-origin-x</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.PerspectiveOriginY">
            <summary>
            Represents the <c>perspective-origin-y</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextStrokeColor">
            <summary>
            Represents the <c>text-stroke-color</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.TextStrokeWidth">
            <summary>
            Represents the <c>text-stroke-width</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.ImageRendering">
            <summary>
            Represents the <c>image-rendering</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationDelay">
            <summary>
            Represents the <c>animation-delay</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationDirection">
            <summary>
            Represents the <c>animation-direction</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationDuration">
            <summary>
            Represents the <c>animation-duration</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationFillMode">
            <summary>
            Represents the <c>animation-fill-mode</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationIterationCount">
            <summary>
            Represents the <c>animation-iteration-count</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationName">
            <summary>
            Represents the <c>animation-name</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationPlayState">
            <summary>
            Represents the <c>animation-play-state</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.AnimationTimingFunction">
            <summary>
            Represents the <c>animation-timing-function</c> CSS property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.FontSmooth">
            <summary>
            Represents the <c>font-smooth</c> CSS property.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.AddGenerated(Sandbox.UI.BaseStyles)">
            <summary>
            Copy over only the styles that are set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.FromGenerated(Sandbox.UI.BaseStyles)">
            <summary>
            Copy all styles from given style set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.SetGenerated(System.String,System.String)">
            <summary>
            Set a CSS property via its string name.
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.FromLerp(Sandbox.UI.BaseStyles,Sandbox.UI.BaseStyles,System.Single)">
            <summary>
            Lerp every property in this stylesheet
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.LerpProperty(System.String,Sandbox.UI.BaseStyles,Sandbox.UI.BaseStyles,System.Single)">
            <summary>
            Lerp a specific property by name
            </summary>
        </member>
        <member name="M:Sandbox.UI.BaseStyles.Clone">
            <summary>
            Perform a deep copy of this stylesheet
            </summary>
        </member>
        <member name="P:Sandbox.UI.BaseStyles.HasAnimation">
            <summary>
            Whether there is an active CSS animation.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Parallel">
            <summary>
            Wrappers of the parallel class.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Steam.CategorizeSteamId(System.UInt64)">
            <summary>
            Return what type os SteamId this is
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Steam.SteamId">
            <summary>
            The current user's SteamId
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Steam.PersonaName">
            <summary>
            The current user's persona name (Steam name)
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.DownloadFile(System.String,System.String,System.Threading.CancellationToken,Sandbox.Utility.DataProgress.Callback)">
            <summary>
            Download a file to a target filename (todo - progress)
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.GrabFile(System.String,System.Threading.CancellationToken,System.Action{System.Int32})">
            <summary>
            Download a file to a byte array
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.DownloadString(System.String,System.Threading.CancellationToken)">
            <summary>
            Download a url to a string
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.DownloadJson``1(System.String,System.Threading.CancellationToken)">
            <summary>
            Download a url to a string
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.PutAsync(System.IO.Stream,System.String,System.Threading.CancellationToken,Sandbox.Utility.DataProgress.Callback)">
            <summary>
            Download a file to a target filename (todo - progress)
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.RemoveAll">
            <summary>
            Remove all tags from the set.
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.Has(System.String)">
            <summary>
            Does this set have the specified tag?
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:Sandbox.ITagSet.Add(System.String)">
            <summary>
            Add a tag to the set.
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:Sandbox.ITagSet.Remove(System.String)">
            <summary>
            Remove a tag from the set.
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:Sandbox.ITagSet.Set(System.String,System.Boolean)">
            <summary>
            Add or remove this tag, based on state
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.TryGetAll">
            <summary>
            Try to get all tags in the set.
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.SetFrom(Sandbox.ITagSet)">
            <summary>
            Set the tags to match this other tag set
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.Add(Sandbox.ITagSet)">
            <summary>
            Add the tags from another set, to this set
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.Toggle(System.String)">
            <summary>
            If this tag is already here, remove it, else add it.
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.HasAny(Sandbox.ITagSet)">
            <summary>
            Does this set have any of the specified tag?
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.HasAll(Sandbox.ITagSet)">
            <summary>
            Does this set have all of the specified tags?
            </summary>
        </member>
        <member name="M:Sandbox.ITagSet.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Sandbox.ITagSet.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Sandbox.IJsonConvert">
            <summary>
            Allows writing JsonConverter in a more compact way, without having to pre-register them.
            </summary>
        </member>
        <member name="T:Sandbox.Json">
            <summary>
            A convenience JSON helper that handles <see cref="T:Sandbox.Resource"/> types for you.
            </summary>
        </member>
        <member name="M:Sandbox.Json.Initialize(Sandbox.Internal.TypeLibrary)">
            <summary>
            Should be called on startup and when hotloading. 
            The reason for doing on hotloading is to clear all the types in JsonSerializableFactory
            </summary>
        </member>
        <member name="M:Sandbox.Json.Deserialize(System.String,System.Type)">
            <summary>
            Try to deserialize given source to given type.
            </summary>
        </member>
        <member name="M:Sandbox.Json.Deserialize``1(System.String)">
            <summary>
            Try to deserialize given source to given type.
            </summary>
        </member>
        <member name="M:Sandbox.Json.Serialize(System.Object)">
            <summary>
            Serialize an object.
            </summary>
        </member>
        <member name="M:Sandbox.Json.ParseToJsonObject(System.String)">
            <summary>
            Parse some Json to a JsonObject
            </summary>
        </member>
        <member name="M:Sandbox.Json.ParseToJsonNode(System.String)">
            <summary>
            Parse some Json to a JsonNode
            </summary>
        </member>
        <member name="M:Sandbox.Json.DeserializeToObject(System.Object,System.String)">
            <summary>
            Deserialize to this existing object
            </summary>
        </member>
        <member name="M:Sandbox.Json.ToNode(System.Object)">
            <summary>
            Serialize a single object to a JsonNode
            </summary>
        </member>
        <member name="M:Sandbox.Json.ToNode(System.Object,System.Type)">
            <summary>
            Serialize a single object to a JsonNode with the given expected type
            </summary>
        </member>
        <member name="M:Sandbox.Json.FromNode(System.Text.Json.Nodes.JsonNode,System.Type)">
            <summary>
            Deserialize a single object to a type
            </summary>
        </member>
        <member name="M:Sandbox.Json.SerializeAsObject(System.Object)">
            <summary>
            Serialize this object property by property - even if JsonConvert has other plans
            </summary>
        </member>
        <member name="M:Sandbox.Json.WalkJsonTree(System.Text.Json.Nodes.JsonNode,System.Func{System.String,System.Text.Json.Nodes.JsonValue,System.Text.Json.Nodes.JsonNode})">
            <summary>
            Deep walk though an entire Json tree, optionally changing values of nodes.
            </summary>
        </member>
        <member name="M:Sandbox.Json.PopulateReflectionCache(Sandbox.Internal.TypeLibrary)">
            <summary>
            Try to do any reflection / code gen immediately, so we don't do anything too slow during gameplay.
            </summary>
        </member>
        <member name="M:Sandbox.JsonUpgrader.Upgrade(System.Int32,System.Text.Json.Nodes.JsonObject,System.Type)">
            <summary>
            Runs through all upgraders that match its class where our version is lower than the specified version.
            </summary>
            <param name="version">The current version that's serialized in the json object</param>
            <param name="json"></param>
            <param name="targetType"></param>
        </member>
        <member name="T:Sandbox.Metadata">
            <summary>
            A simple class for storing and retrieving metadata values.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.Deserialize(System.String)">
            <summary>
            Deserialize metadata from a JSON string.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.Serialize">
            <summary>
            Serialize the metadata to a JSON string.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.SetValue(System.String,System.Object)">
            <summary>
            Set a value with the specified key.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.TryGetValue``1(System.String,``0@)">
            <summary>
            Try to get a value of the specified type.
            </summary>
        </member>
        <member name="M:Sandbox.Metadata.GetValueOrDefault``1(System.String,``0)">
            <summary>
            Get the a value. If it's missing or the wrong type then use the default value.
            </summary>
        </member>
        <member name="T:Sandbox.Screen">
            <summary>
            Access screen dimension etc.
            </summary>
        </member>
        <member name="P:Sandbox.Screen.Size">
            <summary>
            The total size of the game screen
            </summary>
        </member>
        <member name="P:Sandbox.Screen.Width">
            <summary>
            The width of the game screen. Equal to Screen.x
            </summary>
        </member>
        <member name="P:Sandbox.Screen.Height">
            <summary>
            The height of the game screen. Equal to Screen.y
            </summary>
        </member>
        <member name="P:Sandbox.Screen.Aspect">
            <summary>
            The aspect ratio of the screen. Equal to Width/Height
            </summary>
        </member>
        <member name="M:Sandbox.Screen.CreateVerticalFieldOfView(System.Single)">
            <summary>
            Converts a vertical field of view to a horizontal field of view based on the screen aspect ratio.
            </summary>
        </member>
        <member name="M:Sandbox.Screen.CreateVerticalFieldOfView(System.Single,System.Single)">
            <summary>
            Converts a vertical field of view to a horizontal field of view based on the given aspect ratio.
            </summary>
        </member>
        <member name="P:Sandbox.Time.Now">
            <summary>
            The time since game startup
            </summary>
        </member>
        <member name="P:Sandbox.Time.Delta">
            <summary>
            The delta between the last frame and the current (for all intents and purposes)
            </summary>
        </member>
        <member name="T:Sandbox.TimeSince">
            <summary>
            A convenience struct to easily measure time since an event last happened, based on <see cref="P:Sandbox.Time.Now"/>.<br/>
            <br/>
            Typical usage would see you assigning 0 to a variable of this type to reset the timer.
            Then the struct would return time since the last reset. i.e.:
            <code>
            TimeSince lastUsed = 0;
            if ( lastUsed > 10 ) { /*Do something*/ }
            </code>
            </summary>
        </member>
        <member name="P:Sandbox.TimeSince.Absolute">
            <summary>
            Time at which the timer reset happened, based on <see cref="P:Sandbox.Time.Now"/>.
            </summary>
        </member>
        <member name="P:Sandbox.TimeSince.Relative">
            <summary>
            Time passed since last reset, in seconds.
            </summary>
        </member>
        <member name="T:Sandbox.TimeUntil">
            <summary>
            A convenience struct to easily manage a time countdown, based on <see cref="P:Sandbox.Time.Now"/>.<br/>
            <br/>
            Typical usage would see you assigning to a variable of this type a necessary amount of seconds.
            Then the struct would return the time countdown, or can be used as a bool i.e.:
            <code>
            TimeUntil nextAttack = 10;
            if ( nextAttack ) { /*Do something*/ }
            </code>
            </summary>
        </member>
        <member name="P:Sandbox.TimeUntil.Absolute">
            <summary>
            Time to which we are counting down to, based on <see cref="P:Sandbox.Time.Now"/>.
            </summary>
        </member>
        <member name="P:Sandbox.TimeUntil.Relative">
            <summary>
            The actual countdown, in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.TimeUntil.Passed">
            <summary>
            Amount of seconds passed since the countdown started.
            </summary>
        </member>
        <member name="P:Sandbox.TimeUntil.Fraction">
            <summary>
            The countdown, but as a fraction, i.e. a value from 0 (start of countdown) to 1 (end of countdown)
            </summary>
        </member>
        <member name="M:Sandbox.VoiceManager.Uncompress(System.Byte[],System.Action{System.Memory{System.Int16}})">
            <summary>
            Uncompress a voice buffer and call ondata with the result
            </summary>
        </member>
        <member name="T:Sandbox.WebSurface">
            <summary>
            Enables rendering and interacting with a webpage
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.OnTexture">
            <summary>
            Called when the texture has changed and should be updated
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.Url">
            <summary>
            The current Url
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.CheckUrlIsAllowed(System.Uri)">
            <summary>
            Is this URL allowed
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.Size">
            <summary>
            The size of the browser
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.OnNeedsRepaint(Steamworks.Data.HTML_NeedsPaint_t)">
            <summary>
            Invoked when the browser needs to be repainted
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.OnStartRequest(Steamworks.Data.HTML_StartRequest_t)">
            <summary>
            A navigation has happened, allow or deny it
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:Sandbox.WebSurface.OnURLChanged(Steamworks.Data.HTML_URLChanged_t)">
            <summary>
            Invoked when the browser is navigating to a new url
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Sandbox.WebSurface.TellMouseMove(Vector2)">
            <summary>
            Tell the browser the mouse has moved
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.TellMouseWheel(System.Int32)">
            <summary>
            Tell the browser the mouse wheel has moved
            </summary>
            <param name="delta"></param>
        </member>
        <member name="M:Sandbox.WebSurface.TellMouseButton(Sandbox.MouseButtons,System.Boolean)">
            <summary>
            Tell the browser a mouse button has been pressed
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.TellChar(System.UInt32,Sandbox.KeyboardModifiers)">
            <summary>
            Tell the browser a unicode key has been pressed
            </summary>
        </member>
        <member name="M:Sandbox.WebSurface.TellKey(System.UInt32,Sandbox.KeyboardModifiers,System.Boolean)">
            <summary>
            Tell the browser a key has been pressed or released
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.HasKeyFocus">
            <summary>
            Tell the html control if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.ScaleFactor">
            <summary>
            DPI Scaling factor
            </summary>
        </member>
        <member name="P:Sandbox.WebSurface.InBackgroundMode">
            <summary>
            Enable/disable low-resource background mode, where javascript and repaint timers are throttled, resources are
            more aggressively purged from memory, and audio/video elements are paused. When background mode is enabled,
            all HTML5 video and audio objects will execute ".pause()" and gain the property "._steam_background_paused = 1".
            When background mode is disabled, any video or audio objects with that property will resume with ".play()".
            </summary>
        </member>
        <member name="T:Sandbox.MusicPlayer">
            <summary>
            Enables music playback. Use this for music, not for playing game sounds.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.SampleRate">
            <summary>
            Sample rate of the audio being played.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Channels">
            <summary>
            Number of channels of the audio being played.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Duration">
            <summary>
            Gets the total duration of the video in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.PlaybackTime">
            <summary>
            Gets the current playback time in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.OnFinished">
            <summary>
            Invoked when the audio has finished playing.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.OnRepeated">
            <summary>
            Invoked when the audio has repeated.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.ListenLocal">
            <summary>
            Place the listener at 0,0,0 facing 1,0,0.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Position">
            <summary>
            Position of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Paused">
            <summary>
            Pause playback of audio.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Repeat">
            <summary>
            Audio will repeat when reaching the end.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Volume">
            <summary>
            Change the volume of this music.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.LipSync">
            <summary>
            Enables lipsync processing.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.TargetMixer">
            <summary>
            Which mixer do we want to write to
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Visemes">
            <summary>
            A list of 15 lipsync viseme weights. Requires <see cref="P:Sandbox.MusicPlayer.LipSync"/> to be enabled.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Title">
            <summary>
            Get title of the track.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Spectrum">
            <summary>
            512 FFT magnitudes used for audio visualization.
            </summary>
        </member>
        <member name="P:Sandbox.MusicPlayer.Amplitude">
            <summary>
            Approximate measure of audio loudness.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.PlayUrl(System.String)">
            <summary>
            Plays a music stream from a URL.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.Play(Sandbox.BaseFileSystem,System.String)">
            <summary>
            Plays a music file from a relative path.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.Stop">
            <summary>
            Stops audio playback.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.Seek(System.Single)">
            <summary>
            Sets the playback position to a specified time in the audio, given in seconds.
            </summary>
        </member>
        <member name="M:Sandbox.MusicPlayer.GetMeta(System.String)">
            <summary>
            Get meta data string.
            </summary>
        </member>
        <member name="T:Sandbox.VideoPlayer">
            <summary>
            Enables video playback and access to the video texture and audio.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.OnLoaded">
            <summary>
            Video successfully loaded.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.OnAudioReady">
            <summary>
            Event that is invoked when the audio stream is created and ready to use.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.OnTextureData">
            <summary>
            If this event is set, texture data will be provided instead of rendering to the texture.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Repeat">
            <summary>
            Sets whether the video should loop when it reaches the end.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Duration">
            <summary>
            Gets the total duration of the video in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.PlaybackTime">
            <summary>
            Gets the current playback time in seconds.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.SampleRate">
            <summary>
            Audio sample rate.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Channels">
            <summary>
            Number of audio channels.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.HasAudio">
            <summary>
            Does the loaded video have audio?
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.IsPaused">
            <summary>
            Has the video been paused?
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Texture">
            <summary>
            Texture of the video frame.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Width">
            <summary>
            Width of the video.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Height">
            <summary>
            Height of the video.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Audio">
            <summary>
            Access audio properties for this video playback.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.ListenLocal">
            <summary>
            Place the listener at 0,0,0 facing 1,0,0.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.Position">
            <summary>
            Position of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.TargetMixer">
            <summary>
            Which mixer do we want to write to
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.AudioAccessor.Volume">
            <summary>
            Volume of the sound.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Play(System.String)">
            <summary>
            Plays a video file from a URL. If there's already a video playing, it will stop.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Play(Sandbox.BaseFileSystem,System.String)">
            <summary>
            Plays a video file from a relative path. If there's already a video playing, it will stop.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Resume">
            <summary>
            Resumes video playback.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Stop">
            <summary>
            Stops video playback.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Pause">
            <summary>
            Pauses video playback.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.TogglePause">
            <summary>
            Toggle video playback
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Seek(System.Single)">
            <summary>
            Sets the playback position to a specified time in the video, given in seconds.
            </summary>
        </member>
        <member name="M:Sandbox.VideoPlayer.Present">
            <summary>
            Present a video frame.
            </summary>
        </member>
        <member name="P:Sandbox.VideoPlayer.Muted">
            <summary>
            The video is muted
            </summary>
        </member>
        <member name="T:Sandbox.VideoWriter">
            <summary>
            Allows the creation of video content by encoding a sequence of frames.
            </summary>
        </member>
        <member name="M:Sandbox.VideoWriter.Config.IsCodecSupported">
            <summary>
            Can this container support the codec.
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.H264">
            <summary>
            H.264 codec (does not support transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.H265">
            <summary>
            H.265 codec (does not support transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.VP8">
            <summary>
            VP8 codec (does not support transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.VP9">
            <summary>
            VP9 codec (supports transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Codec.WebP">
            <summary>
            WebP codec (supports transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Container.MP4">
            <summary>
            MP4 container (does not support transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Container.WebM">
            <summary>
            WebM container (supports transparency)
            </summary>
        </member>
        <member name="F:Sandbox.VideoWriter.Container.WebP">
            <summary>
            WebP container (supports transparency)
            </summary>
        </member>
        <member name="M:Sandbox.VideoWriter.Dispose">
            <summary>
            Dispose this recorder, the encoder will be flushed and video finalized.
            </summary>
        </member>
        <member name="M:Sandbox.VideoWriter.FinishAsync">
            <summary>
            Finish creating this video. The encoder will be flushed and video finalized.
            </summary>
        </member>
        <member name="M:Sandbox.VideoWriter.AddFrame(System.ReadOnlySpan{System.Byte},System.Nullable{System.TimeSpan})">
            <summary>
            Add a frame of data to be encoded. Timestamp is in microseconds. 
            If a timestamp is not specified, it will use an incremented 
            frame count as the timestamp.
            </summary>
            <param name="data">The frame data to be encoded.</param>
            <param name="timestamp">The timestamp for the frame in microseconds. If not specified, an incremented frame count will be used.</param>
        </member>
        <member name="T:NativeEngine.HMaterial">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:NativeEngine.IndexBufferHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:NativeEngine.RenderBufferHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:NativeEngine.RenderShaderHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="T:NativeEngine.VertexBufferHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="P:NativeEngine.InputEvent.IsButtonPress">
            <summary>
            True if this is as a result of a button being pressed
            </summary>
        </member>
        <member name="P:NativeEngine.InputEvent.IsGameButton">
            <summary>
            We let some button presses skip the UI completely. These can then be used as key binds that
            can always run. We mainly do this with the F keys.
            </summary>
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.SHOULD_BE_DELETED_BEFORE_WORLD">
            For objects that can't be considered to be "owned" by the world they are in because they
            are owned by a manager. All this flag does is cause a warning when such an object is still
            in the world at world deletion time (a leak).
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.OWNED_BY_ANOTHER_SCENEOBJECT">
            if this flag is set, then the object will not be deleted when deleting the world, and will not be queued for delete. It's assumed that this object is going to be deleted inside of the destructor of another sceneobject
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.PARTIALLY_ALPHA_BLENDED">
            We have a mixture of alpha-blended and non-alpha blended draws
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.UNIQUE_BATCH_GROUP">
            A unique batch flag that allows objects to draw in a separate batch from their original group
        </member>
        <member name="F:NativeEngine.SceneSystemWellKnownRenderTargetID.SCENE_RTGT_SCRATCH_TEXTURE_8888">
            <summary>
            a scratch render target texture for use for monitor rendering and other temp storage
            </summary>
        </member>
        <member name="T:ConditionalVisibilityAttribute">
            <summary>
            Hide a property if a condition matches.
            </summary>
        </member>
        <member name="M:ConditionalVisibilityAttribute.TestCondition(System.Object,Sandbox.TypeDescription)">
            <summary>
            The test condition.
            </summary>
            <param name="targetObject">The class instance of the property this attribute is attached to.</param>
            <param name="td">Description of the <paramref name="targetObject"/>'s type.</param>
            <returns>Return true if the property should be visible.</returns>
        </member>
        <member name="T:HideIfAttribute">
            <summary>
            Hide this property if a given property within the same class has the given value. Used typically in the Editor Inspector.
            </summary>
        </member>
        <member name="P:HideIfAttribute.PropertyName">
            <summary>
            Property name to test.
            </summary>
        </member>
        <member name="P:HideIfAttribute.Value">
            <summary>
            Property value to test against.
            </summary>
        </member>
        <member name="T:ShowIfAttribute">
            <summary>
            Show this property if a given property within the same class has the given value. Used typically in the Editor Inspector.
            </summary>
        </member>
        <member name="T:Editor.MetaDataAttribute">
            <summary>
            Base attribute which allows adding FGD metadata to classes.
            </summary>
        </member>
        <member name="T:Editor.FieldMetaDataAttribute">
            <summary>
            Base attribute which allows adding metadata to properties.
            </summary>
        </member>
        <member name="T:Editor.HidePropertyAttribute">
            <summary>
            A way to hide properties from parent classes in tools.
            </summary>
        </member>
        <member name="M:Editor.HidePropertyAttribute.#ctor(System.String)">
            <param name="internal_name">The internal/fgd name to skip. Usually all lowercase and with underscores (_) instead of spaces.</param>
        </member>
        <member name="T:Editor.EnableColorAlphaAttribute">
            <summary>
            If used on a Color or Color32 property, enables alpha modification in editors.
            </summary>
        </member>
        <member name="T:Editor.HammerEntityAttribute">
            <summary>
            This is an entity that can be placed in Hammer.
            </summary>
        </member>
        <member name="T:Editor.SolidAttribute">
            <summary>
            This is a brush based entity class. It can only be a mesh tied to an entity.
            </summary>
        </member>
        <member name="T:Editor.SupportsSolidAttribute">
            <summary>
            This is a point class entity, but does support being a brush entity (a mesh tied to an entity).
            </summary>
        </member>
        <member name="T:Editor.PhysicsConstraintAttribute">
            <summary>
            Marks this entity as a physics constraint.
            This disables pre-settle for all <see cref="T:Editor.PhysicsSimulatedAttribute">PhysicsSimulated</see> entities this entity's keyvalues reference in Hammer.
            </summary>
        </member>
        <member name="T:Editor.PathAttribute">
            <summary>
            This is a path class, used with Hammer's Path Tool.
            </summary>
        </member>
        <member name="M:Editor.PathAttribute.#ctor(System.String,System.Boolean)">
            <param name="nodeClassName">Class name of the node entity.</param>
            <param name="spawnEnts">If set to true, will actually create node entities. If set to false, node data will be serialized to a JSON key-value.</param>
        </member>
        <member name="T:Editor.PathNodeAttribute">
            <summary>
            This is a path node class. May not necessarily be an entity.
            </summary>
        </member>
        <member name="T:Editor.AutoApplyMaterialAttribute">
            <summary>
            Apply this material to the mesh when tying one to this class. Typically used for triggers.
            </summary>
        </member>
        <member name="T:Editor.ModelAttribute">
            <summary>
            This makes it so the model, skin and bodygroups can be set and changed in Hammer.
            </summary>
        </member>
        <member name="P:Editor.ModelAttribute.Model">
            <summary>
            The default model to be set to.
            </summary>
        </member>
        <member name="P:Editor.ModelAttribute.BodyGroup">
            <summary>
            The default body group to be set to.
            </summary>
        </member>
        <member name="P:Editor.ModelAttribute.MaterialGroup">
            <summary>
            The default material group to be set to.
            </summary>
        </member>
        <member name="P:Editor.ModelAttribute.Archetypes">
            <summary>
            Marks this entity as a representative of a certain model archetype.
            This makes this entity class appear in ModelDoc under given archetype(s), which will be used to decide which entity class to use when dragging models from Hammer's Asset browser.
            </summary>
        </member>
        <member name="T:Editor.EditorSpriteAttribute">
            <summary>
            Declare a sprite to represent this entity in Hammer.
            </summary>
            <example>
            [EditorSprite( "editor/ai_goal_follow.vmat" )]
            </example>
        </member>
        <member name="T:Editor.ParticleAttribute">
            <summary>
            Tells Hammer that this entity has a particle effect keyvalue that needs to be visualized.
            </summary>
        </member>
        <member name="T:Editor.PhysicsTypeOverrideMeshAttribute">
            <summary>
            Indicate to the map builder that any meshes associated with the entity should have a mesh physics type.
            </summary>
        </member>
        <member name="T:Editor.PhysicsSimulatedAttribute">
            <summary>
            Indicate if the entity is simulated in game and should participate in the pre-settle simulation during map compile.
            Adds a pre-settle keyvalue to this entity class.
            </summary>
        </member>
        <member name="T:Editor.SkyboxAttribute">
            <summary>
            Helper to render skybox in hammer
            </summary>
        </member>
        <member name="T:Editor.VisGroup">
            <summary>
            Used to tell Hammer which automatic Visibility Groups an entity should belong to. See <see cref="T:Editor.VisGroupAttribute">VisGroupAttribute</see>.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Lighting">
            <summary>
            Entities that are primarily lights and that sort of thing.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Sound">
            <summary>
            The purpose of these entities is to emit light and not much else.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Logic">
            <summary>
            Pure logic entities, typically not shown in-game.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Trigger">
            <summary>
            Any sort of trigger volume, these usually don't show up in-game.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Navigation">
            <summary>
            Entities that are related to nav meshes.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Particles">
            <summary>
            The main reason these exist is to create particle systems.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Physics">
            <summary>
            Physics enabled entities.
            </summary>
        </member>
        <member name="F:Editor.VisGroup.Dynamic">
            <summary>
            Entities that do not move via physics but are still intractable with or otherwise non static.
            </summary>
        </member>
        <member name="T:Editor.VisGroupAttribute">
            <summary>
            Makes the entity show up under given automatic visibility group in Hammer.
            </summary>
        </member>
        <member name="T:Editor.DrawAnglesAttribute">
            <summary>
            Draws the movement direction in Hammer.
            </summary>
            <example>
            [DrawAngles( "movedir", "movedir_islocal" )]
            </example>
        </member>
        <member name="T:Editor.DoorHelperAttribute">
            <summary>
            Draws the door movement and the final open position in Hammer.
            </summary>
        </member>
        <member name="T:Editor.RenderFieldsAttribute">
            <summary>
            Adds the render color and other related options to the entity class in Hammer.
            </summary>
            <example>
            [RenderFields]
            </example>
        </member>
        <member name="T:Editor.FrustumBoundlessAttribute">
            <summary>
            Draws a frustum that doesn't contribute to bounds calculations.
            </summary>
        </member>
        <member name="T:Editor.SphereAttribute">
            <summary>
            Displays a sphere in Hammer with a radius tied to given property and with given color.
            The sphere's radius can be manipulated in Hammer's 2D views. You can have multiple of these.
            </summary>
        </member>
        <member name="P:Editor.SphereAttribute.IsLean">
            <summary>
            If set to true, the sphere will appear as 3 circles in 3D view, rather than a wireframe sphere.
            </summary>
        </member>
        <member name="M:Editor.SphereAttribute.#ctor(System.String,System.UInt32,System.Boolean)">
            <param name="variableName">Name of the variable to use as sphere radius.</param>
            <param name="color">Color as an unsigned integer. For example 0xFF99CC, where 0xBBGGRR.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="M:Editor.SphereAttribute.#ctor(System.String,System.String,System.Boolean)">
            <param name="variableName">Name of the variable to use as sphere radius.</param>
            <param name="color">Color as an unsigned integer. For example 0xFF99CC, where 0xBBGGRR.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="M:Editor.SphereAttribute.#ctor(System.String,System.Byte,System.Byte,System.Byte,System.Boolean)">
            <param name="variableName">Name of the variable to use as sphere radius.</param>
            <param name="red">Red component of the sphere's color.</param>
            <param name="green">Green component of the sphere's color.</param>
            <param name="blue">Blue component of the sphere's color.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="M:Editor.SphereAttribute.#ctor(System.Single,System.Byte,System.Byte,System.Byte,System.Boolean)">
            <param name="radius">Range of the sphere to show.</param>
            <param name="red">Red component of the sphere's color.</param>
            <param name="green">Green component of the sphere's color.</param>
            <param name="blue">Blue component of the sphere's color.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="T:Editor.TextAttribute">
            <summary>
            Displays text in Hammer on the entity.
            </summary>
        </member>
        <member name="M:Editor.TextAttribute.#ctor(System.String,System.String,System.Boolean)">
            <param name="text">The text to display.</param>
            <param name="offsetVariable">The name of the property that will act as the position of the text.</param>
            <param name="worldspace">Whether the position from the variable should be interpreted in world space (true) or in local space (false).</param>
        </member>
        <member name="T:Editor.LineAttribute">
            <summary>
            Draws a line in Hammer. You can have multiple of this attribute.
            </summary>
        </member>
        <member name="M:Editor.LineAttribute.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Draws lines between this entity and all entities which have a key named '<paramref name="startKey">startKey</paramref>' and its value matches
            the value of our '<paramref name="startKeyValue">startKeyValue</paramref>'.
            </summary>
            <param name="startKey">Name of the key to search on other entities. This typically will be 'targetname'.</param>
            <param name="startKeyValue">Name of our key whose value will be used to match other entities.</param>
            <param name="onlySelected">Only draw the line when the entity is selected.</param>
        </member>
        <member name="M:Editor.LineAttribute.#ctor(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Draws lines between all entities, starting from each entity that has a key named '<paramref name="startKey">startKey</paramref>' and its value matches
            the value of our '<paramref name="startKeyValue">startKeyValue</paramref>' and going to each entity that has a key named <paramref name="endKey">endKey</paramref>
            with a value of '<paramref name="endKeyValue">endKeyValue</paramref>'s value.
            </summary>
            <param name="startKey">Name of the key to search on other entities. This typically will be 'targetname'.</param>
            <param name="startKeyValue">Name of our key whose value will be used to match other entities.</param>
            <param name="endKey">Name of the key to search on other entities.</param>
            <param name="endKeyValue">Name of our key whose value will be used to match other entities.</param>
            <param name="onlySelected">Only draw the line when the entity is selected.</param>
        </member>
        <member name="T:Editor.PointLineAttribute">
            <summary>
            Draws a line in Hammer from the entity's origin to a point that can be moved with a gizmo and is stored in this property.
            </summary>
        </member>
        <member name="P:Editor.PointLineAttribute.Local">
            <summary>
            Write local to entity coordinates to the provided key. Default is to write in world space.
            </summary>
        </member>
        <member name="T:Editor.BoxSizeAttribute">
            <summary>
            For point entities without visualization (model/sprite), sets the size of the box the entity will appear as in Hammer.
            </summary>
        </member>
        <member name="T:Editor.BoundsHelperAttribute">
            <summary>
            Creates a resizable box helper in Hammer which outputs the size of the bounding box defined by the level designer into given keys/properties.
            You can have multiple of this attribute.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.MinsKey">
            <summary>
            Key (classname) of the entity to store the "Mins" of the bounding box.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.MaxsKey">
            <summary>
            Key (classname) of the entity to store the "Maxs" of the bounding box.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.ExtentsKey">
            <summary>
            Key (classname) of the entity to store the bounding box as an "extents".
            This replaces <see cref="P:Editor.BoundsHelperAttribute.MinsKey"/> and <see cref="P:Editor.BoundsHelperAttribute.MaxsKey"/> and assumes the entity is in the middle of the bounds.
            The output value will be the total size of the bounds on each axis.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.AutoCenter">
            <summary>
            Always move the entity to the center of the bounds.
            </summary>
        </member>
        <member name="P:Editor.BoundsHelperAttribute.IsWorldAligned">
            <summary>
            Make the bounds AABB (true), not OBB (false). Basically ignores rotation.
            </summary>
        </member>
        <member name="M:Editor.BoundsHelperAttribute.#ctor(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a box helper that outputs the size of the bounding box defined by the level designer as mins and maxs
            </summary>
            <param name="minsKey">The internal key name to output "mins" size to.</param>
            <param name="maxsKey">The internal key name to output "maxs" size to.</param>
            <param name="autoCenter">If set to true, editing this box in Hammer will automatically move the entity to the center of the box.</param>
            <param name="worldAliged">If set, the helper box will ignore entity rotation.</param>
        </member>
        <member name="M:Editor.BoundsHelperAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a box helper that outputs the size of the bounding box defined by the level designer as extents (maxs - mins).
            This assumes the entity is in the center of the box.
            </summary>
            <param name="extentsKey">The internal key name to output "extents" size to. This is the result of (maxs - mins).</param>
            <param name="worldAliged">If set, the helper box will ignore entity rotation.</param>
        </member>
        <member name="T:Editor.OrthoBoundsHelperAttribute">
            <summary>
            Creates a resizable box helper that represents an orthographic projection from the entity's origin in Hammer.
            The size of the bounding box as defined by the level designer is put into given keys/properties.
            </summary>
        </member>
        <member name="T:Editor.CanBeClientsideOnlyAttribute">
            <summary>
            Adds a property in Hammer that dictates whether the entity will be spawned on server or client.
            </summary>
        </member>
        <member name="T:Editor.EntityReportSourceAttribute">
            <summary>
            Makes value of this property appear in the Source File column of the Entity Report dialog in Hammer.
            There can be only one of such properties.
            </summary>
        </member>
        <member name="T:Editor.PostProcessingVolumeAttribute">
            <summary>
            Internally marks this class in Hammer as a post processing entity for preview purposes.
            </summary>
        </member>
        <member name="T:Editor.ToneMapAttribute">
            <summary>
            Internally marks this class in Hammer as a tonemap entity for preview purposes.
            </summary>
        </member>
        <member name="T:Editor.LightAttribute">
            <summary>
            Internally marks this class in Hammer as a light.
            </summary>
        </member>
        <member name="T:Editor.LightConeAttribute">
            <summary>
            The light_spot visualizer.
            </summary>
        </member>
        <member name="T:Editor.GlobalAttribute">
            <summary>
            Marks this entity as global, there should only be one entity with this global name in the map.
            Used internally for Preview purposes.
            </summary>
        </member>
        <member name="T:Editor.SimpleHelperAttribute">
            <summary>
            Adds a simple parameterless helper to the entity class.
            </summary>
        </member>
        <member name="T:Editor.BakeAmbientLightAttribute">
            <summary>
            Used by light_environment entity internally.
            </summary>
        </member>
        <member name="T:Editor.BakeAmbientOcclusionAttribute">
            <summary>
            Used by light_environment entity internally.
            </summary>
        </member>
        <member name="T:Editor.BakeSkyLightAttribute">
            <summary>
            Used by light_environment entity internally.
            </summary>
        </member>
        <member name="T:Editor.BakeResourceAttribute">
            <summary>
            Allows hammer to bake resources, mostly used for cubemaps and light probes
            </summary>
        </member>
        <member name="T:SwapChainHandle_t">
            <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxDgnstcs_Logging_RegisterEngineLogger(System.Int32,System.IntPtr)">
            <summary>
            Sandbox.Diagnostics.Logging.RegisterEngineLogger( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_Bootstrap_EnvironmentExit(System.Int32)">
            <summary>
            Sandbox.Engine.Bootstrap.EnvironmentExit( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMouseMotion(System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnMouseMotion( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMousePositionChange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnMousePositionChange( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMouseButton(System.Int64,System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnMouseButton( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnKey(System.Int64,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnKey( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnText(System.UInt32)">
            <summary>
            Sandbox.Engine.InputRouter.OnText( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnWindowActive(System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnWindowActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMouseWheel(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnMouseWheel( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnImeStart">
            <summary>
            Sandbox.Engine.InputRouter.OnImeStart( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnImeComposition(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnImeComposition( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnImeEnd">
            <summary>
            Sandbox.Engine.InputRouter.OnImeEnd( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerButton(System.Int32,System.Int64,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnGameControllerButton( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerAxis(System.Int32,System.Int64,System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnGameControllerAxis( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerConnected(System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnGameControllerConnected( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerDisconnected(System.Int32)">
            <summary>
            Sandbox.Engine.InputRouter.OnGameControllerDisconnected( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_SystemInfo_Set(System.IntPtr,System.UInt16,System.UInt64,System.UInt64)">
            <summary>
            Sandbox.Engine.SystemInfo.Set( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_SystemInfo_SetGpu(System.IntPtr,System.IntPtr,System.UInt64)">
            <summary>
            Sandbox.Engine.SystemInfo.SetGpu( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_FrameStage(System.IntPtr,System.Double)">
            <summary>
            Sandbox.EngineLoop.FrameStage( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_PreInput">
            <summary>
            Sandbox.EngineLoop.PreInput( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_PostInput">
            <summary>
            Sandbox.EngineLoop.PostInput( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_PreOutput">
            <summary>
            Sandbox.EngineLoop.PreOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_Print(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.Print( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_DispatchConsoleCommand(System.IntPtr,System.IntPtr,System.Int64)">
            <summary>
            Sandbox.EngineLoop.DispatchConsoleCommand( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_OnClientOutput">
            <summary>
            Sandbox.EngineLoop.OnClientOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_OnPresent">
            <summary>
            Sandbox.EngineLoop.OnPresent( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Graphics_OnLayer(System.Int32,ManagedRenderSetup_t)">
            <summary>
            Sandbox.Graphics.OnLayer( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_HandleIndex_RegisterHandle(System.IntPtr,System.UInt32)">
            <summary>
            Sandbox.HandleIndex.RegisterHandle( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_HandleIndex_FreeHandle(System.Int32)">
            <summary>
            Sandbox.HandleIndex.FreeHandle( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnLobbyInvite(System.UInt64,System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnLobbyInvite( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnMemberEntered(System.UInt64,System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnMemberEntered( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnMemberLeave(System.UInt64,System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnMemberLeave( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnEntered(System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnEntered( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnCreated(System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnDataUpdate(System.UInt64,System.UInt64)">
            <summary>
            Sandbox.LobbyManager.OnDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnChatMessage(System.UInt64,System.UInt64,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.LobbyManager.OnChatMessage( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_MusicPlayer_OnInitAudioInternal(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Sandbox.MusicPlayer.OnInitAudioInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_MusicPlayer_OnFinishedInternal(System.UInt32)">
            <summary>
            Sandbox.MusicPlayer.OnFinishedInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_MusicPlayer_OnRepeatInternal(System.UInt32)">
            <summary>
            Sandbox.MusicPlayer.OnRepeatInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSocketConnection(Sandbox.Network.HSteamListenSocket,Sandbox.Network.HSteamNetConnection)">
            <summary>
            Sandbox.Network.SteamNetwork.OnSocketConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSocketDisconnection(Sandbox.Network.HSteamListenSocket,Sandbox.Network.HSteamNetConnection)">
            <summary>
            Sandbox.Network.SteamNetwork.OnSocketDisconnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxPhysics_PhysicsEngine_OnPhysicsJointBreak(System.Int32)">
            <summary>
            Sandbox.Physics.PhysicsEngine.OnPhysicsJointBreak( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxPhysics_PhysicsEngine_OnActive(System.Int32,Transform,Vector3,Vector3)">
            <summary>
            Sandbox.Physics.PhysicsEngine.OnActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxPhysics_PhysicsEngine_DebugDrawLine(Vector3,Vector3,Color32)">
            <summary>
            Sandbox.Physics.PhysicsEngine.DebugDrawLine( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_RealTime_Update(System.Single)">
            <summary>
            Sandbox.RealTime.Update( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_RenderTarget_Flush">
            <summary>
            Sandbox.RenderTarget.Flush( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Resource_OnResourceReloaded(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Resource.OnResourceReloaded( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_ScnCstmbjctRndr_RenderObject(ManagedRenderSetup_t,System.Int32)">
            <summary>
            Sandbox.SceneCustomObjectRender.RenderObject( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_ServerList_OnStarted(System.UInt32)">
            <summary>
            Sandbox.Services.ServerList.OnStarted( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_ServerList_OnServerResponded(System.UInt32,System.IntPtr,System.UInt64)">
            <summary>
            Sandbox.Services.ServerList.OnServerResponded( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_ServerList_OnFinished(System.UInt32)">
            <summary>
            Sandbox.Services.ServerList.OnFinished( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnTextureCreatedInternal(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.OnTextureCreatedInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnInitAudioInternal(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Sandbox.VideoPlayer.OnInitAudioInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnFreeAudioInternal(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.OnFreeAudioInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnTextureDataInternal(System.UInt32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.VideoPlayer.OnTextureDataInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnLoadedInternal(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.OnLoadedInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_WantsTextureData(System.UInt32)">
            <summary>
            Sandbox.VideoPlayer.WantsTextureData( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_InternalIsActive">
            <summary>
            Sandbox.VR.VRSystem.InternalIsActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_InternalWantsInit">
            <summary>
            Sandbox.VR.VRSystem.InternalWantsInit( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_BeginFrame">
            <summary>
            Sandbox.VR.VRSystem.BeginFrame( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_EndFrame">
            <summary>
            Sandbox.VR.VRSystem.EndFrame( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_Sync">
            <summary>
            Sandbox.VR.VRSystem.Sync( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_Submit(System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.VR.VRSystem.Submit( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_GetVulkanInstanceExtensionsRequired">
            <summary>
            Sandbox.VR.VRSystem.GetVulkanInstanceExtensionsRequired( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_GetVulkanDeviceExtensionsRequired">
            <summary>
            Sandbox.VR.VRSystem.GetVulkanDeviceExtensionsRequired( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_RenderOverlays">
            <summary>
            Sandbox.VR.VRSystem.RenderOverlays( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Steamworks_Dispatch_OnClientCallback(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Steamworks.Dispatch.OnClientCallback( ... )
            </summary>
        </member>
        <member name="M:NetCore.InitializeInterop(System.String)">
            <summary>
            From here we'll open the native dlls and inject our function pointers into them,
            and retrieve function pointers from them.
            </summary>
        </member>
        <member name="T:FBMGammaType_t">
            <summary>
            from FloatBitmap 
            </summary>
        </member>
        <member name="T:NativeResourceCache">
            <summary>
            We only want 1 instance of a Resource class in C# and we want that to have 1 strong handle to native.
            So we need a WeakReference lookup everytime we get a Resource from native to match that class.
            This way GC can work for us and free anything we're no longer using anywhere, fantastic!
            
            However sometimes GC is very good at it's job and will free Resources we don't keep a strong reference to
            in generation 0 or 1 immediately after usage. This can cause the resource to need to be loaded every frame.
            Or worse be finalized at unpredictable times.
            
            So we keep a sliding memory cache of the Resources - realistically these only need to live for an extra frame.
            But it's probably nice to keep around for longer if they're going to be used on and off.
            </summary>
        </member>
        <member name="F:NativeResourceCache.WeakTable">
            <summary>
            We still want a WeakReference cache because we might have a strong reference somewhere to a resource
            that has been expired from the cache. And we absolutely only want 1 instance of the resource.
            </summary>
        </member>
        <member name="M:NativeResourceCache.Tick">
            <summary>
            Ticks the underlying MemoryCache to clear expired entries
            </summary>
        </member>
        <member name="M:NativeResourceCache.Clear">
            <summary>
            Clear the cache when games are closed etc. ready for a <see cref="M:System.GC.Collect"/>
            </summary>
        </member>
        <member name="T:SceneObjectAnimationSequence">
            <summary>
            Hidden class. addon code should only ever access AnimationSequence.
            </summary>
        </member>
        <member name="T:SceneObjectDirectPlayback">
            <summary>
            Hidden class. addon code should only ever access DirectPlayback.
            </summary>
        </member>
        <member name="T:SceneObjectMorphCollection">
            <summary>
            Hidden class. addon code should only ever access MorphCollection.
            </summary>
        </member>
        <member name="T:Steamworks.CallResult`1">
            <summary>
            An awaitable version of a SteamAPICall_t
            </summary>
        </member>
        <member name="M:Steamworks.CallResult`1.OnCompleted(System.Action)">
            <summary>
            This gets called if IsComplete returned false on the first call.
            The Action "continues" the async call. We pass it to the Dispatch
            to be called when the callback returns.
            </summary>
        </member>
        <member name="M:Steamworks.CallResult`1.GetResult">
            <summary>
            Gets the result. This is called internally by the async shit.
            </summary>
        </member>
        <member name="P:Steamworks.CallResult`1.IsCompleted">
            <summary>
            Return true if complete or failed
            </summary>
        </member>
        <member name="M:Steamworks.CallResult`1.GetAwaiter">
            <summary>
            This is what makes this struct awaitable
            </summary>
        </member>
        <member name="T:Steamworks.ICallbackData">
            <summary>
            Gives us a generic way to get the CallbackId of structs
            </summary>
        </member>
        <member name="T:Steamworks.Dispatch">
            <summary>
            Responsible for all callback/callresult handling
            
            This manually pumps Steam's message queue and dispatches those
            events to any waiting callbacks/callresults.
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.OnClientCallback(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Called if an exception happens during a callback/callresult.
            This is needed because the exception isn't always accessible when running
            async.. and can fail silently. With this hooked you won't be stuck wondering
            what happened.
            </summary>
        </member>
        <member name="F:Steamworks.Dispatch.actionsToCall">
            <summary>
            To be safe we don't call the continuation functions while iterating
            the Callback list. This is maybe overly safe because the only way this
            could be an issue is if the callback list is modified in the continuation
            which would only happen if starting or shutting down in the callback.
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.ProcessCallback(Steamworks.CallbackType,System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            A callback is a general global message
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.CallbackToString(Steamworks.CallbackType,System.IntPtr,System.Int32)">
            <summary>
            Given a callback, try to turn it into a string
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.ProcessResult(Steamworks.CallbackType,System.IntPtr,System.Int32)">
            <summary>
            A result is a reply to a specific command
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.OnCallComplete``1(Steamworks.Data.SteamAPICall_t,System.Action,System.Boolean)">
            <summary>
            Watch for a steam api call
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.Install``1(System.Action{``0},System.Boolean)">
            <summary>
            Install a global callback. The passed function will get called if it's all good.
            </summary>
        </member>
        <member name="T:Steamworks.Data.DurationControl">
            <summary>
            Sent for games with enabled anti indulgence / duration control, for enabled users. 
            Lets the game know whether persistent rewards or XP should be granted at normal rate, half rate, or zero rate.
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.Appid">
            <summary>
            appid generating playtime
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.Applicable">
            <summary>
            is duration control applicable to user + game combination
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.PlaytimeInLastFiveHours">
            <summary>
            playtime since most recent 5 hour gap in playtime, only counting up to regulatory limit of playtime, in seconds
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.PlaytimeToday">
            <summary>
            playtime on current calendar day
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.Progress">
            <summary>
            recommended progress
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.Join">
            <summary>
            Try to join this room. Will return RoomEnter.Success on success,
            and anything else is a failure
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.Leave">
            <summary>
            Leave a lobby; this will take effect immediately on the client side
            other users in the lobby will be notified by a LobbyChatUpdate_t callback
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.InviteFriend(Steamworks.SteamId)">
            <summary>
            Invite another user to the lobby
            will return true if the invite is successfully sent, whether or not the target responds
            returns false if the local user is not connected to the Steam servers
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.MemberCount">
            <summary>
            Get current lobby's member count
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.Members">
            <summary>
            Returns current members. Need to be in the lobby to see the users.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.GetData(System.String)">
            <summary>
            Get data associated with this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.SetData(System.String,System.String)">
            <summary>
            Get data associated with this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.DeleteData(System.String)">
            <summary>
            Removes a metadata key from the lobby
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.Data">
            <summary>
            Get all data for this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.GetMemberData(Steamworks.Friend,System.String)">
            <summary>
            Gets per-user metadata for someone in this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.SetMemberData(System.String,System.String)">
            <summary>
            Sets per-user metadata (for the local user implicitly)
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.RefreshData">
            <summary>
            Refreshes metadata for a lobby you're not necessarily in right now
            you never do this for lobbies you're a member of, only if your
            this will send down all the metadata associated with a lobby
            this is an asynchronous call
            returns false if the local user is not connected to the Steam servers
            results will be returned by a LobbyDataUpdate_t callback
            if the specified lobby doesn't exist, LobbyDataUpdate_t::m_bSuccess will be set to false
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.MaxMembers">
            <summary>
            Max members able to join this lobby. Cannot be over 250.
            Can only be set by the owner
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.Owner">
            <summary>
            You must be the lobby owner to set the owner
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.IsOwnedBy(Steamworks.SteamId)">
            <summary>
            Check if the specified SteamId owns the lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceClose">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceFar">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceWorldwide">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithKeyValue(System.String,System.String)">
            <summary>
            Filter by specified key/value pair; string parameters
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithLower(System.String,System.Int32)">
            <summary>
            Numerical filter where value is less than the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithHigher(System.String,System.Int32)">
            <summary>
            Numerical filter where value is greater than the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithEqual(System.String,System.Int32)">
            <summary>
            Numerical filter where value must be equal to the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithNotEqual(System.String,System.Int32)">
            <summary>
            Numerical filter where value must not equal the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.AddNumericalFilter(System.String,System.Int32,Steamworks.LobbyComparison)">
            <summary>
            Test key, initialize numerical filter list if necessary, then add new numerical filter
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.OrderByNear(System.String,System.Int32)">
            <summary>
            Order filtered results according to key/values nearest the provided key/value pair.
            Can specify multiple near value filters; each successive filter is lower priority than the previous.
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithSlotsAvailable(System.Int32)">
            <summary>
            returns only lobbies with the specified number of slots available
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithMaxResults(System.Int32)">
            <summary>
            sets how many results to return, the lower the count the faster it is to download the lobby results
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.RequestAsync">
            <summary>
            Run the query, get the matching lobbies
            </summary>
        </member>
        <member name="T:Steamworks.SteamApps">
            <summary>
            Exposes a wide range of information and actions for applications and Downloadable Content (DLC).
            </summary>
        </member>
        <member name="E:Steamworks.SteamApps.OnDlcInstalled">
            <summary>
            posted after the user gains ownership of DLC and that DLC is installed
            </summary>
        </member>
        <member name="E:Steamworks.SteamApps.OnNewLaunchParameters">
            <summary>
            posted after the user gains executes a Steam URL with command line or query parameters
            such as steam://run/appid//-commandline/?param1=value1(and)param2=value2(and)param3=value3 etc
            while the game is already running.  The new params can be queried
            with GetLaunchQueryParam and GetLaunchCommandLine
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsSubscribed">
            <summary>
            Checks if the active user is subscribed to the current App ID
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsSubscribedFromFamilySharing">
            <summary>
            Check if user borrowed this game via Family Sharing, If true, call GetAppOwner() to get the lender SteamID
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsLowViolence">
            <summary>
            Checks if the license owned by the user provides low violence depots.
            Low violence depots are useful for copies sold in countries that have content restrictions
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsCybercafe">
            <summary>
            Checks whether the current App ID license is for Cyber Cafes.
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsVACBanned">
            <summary>
            CChecks if the user has a VAC ban on their account
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.GameLanguage">
            <summary>
            Gets the current language that the user has set.
            This falls back to the Steam UI language if the user hasn't explicitly picked a language for the title.
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.AvailableLanguages">
            <summary>
            Gets a list of the languages the current app supports.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.IsSubscribedToApp(Steamworks.AppId)">
            <summary>
            Checks if the active user is subscribed to a specified AppId.
            Only use this if you need to check ownership of another game related to yours, a demo for example.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.IsDlcInstalled(Steamworks.AppId)">
            <summary>
            Checks if the user owns a specific DLC and if the DLC is installed
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.PurchaseTime(Steamworks.AppId)">
            <summary>
            Returns the time of the purchase of the app
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsSubscribedFromFreeWeekend">
            <summary>
            Checks if the user is subscribed to the current app through a free weekend
            This function will return false for users who have a retail or other type of license
            Before using, please ask your Valve technical contact how to package and secure your free weekened
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.DlcInformation">
            <summary>
            Returns metadata for all available DLC
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.InstallDlc(Steamworks.AppId)">
            <summary>
            Install/Uninstall control for optional DLC
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.UninstallDlc(Steamworks.AppId)">
            <summary>
            Install/Uninstall control for optional DLC
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.CurrentBetaName">
            <summary>
            Returns null if we're not on a beta branch, else the name of the branch
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.MarkContentCorrupt(System.Boolean)">
             <summary>
             Allows you to force verify game content on next launch.
            
             If you detect the game is out-of-date(for example, by having the client detect a version mismatch with a server),
             you can call use MarkContentCorrupt to force a verify, show a message to the user, and then quit.
             </summary>
        </member>
        <member name="M:Steamworks.SteamApps.InstalledDepots(Steamworks.AppId)">
            <summary>
            Gets a list of all installed depots for a given App ID in mount order
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.AppInstallDir(Steamworks.AppId)">
            <summary>
            Gets the install folder for a specific AppID.
            This works even if the application is not installed, based on where the game would be installed with the default Steam library location.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.IsAppInstalled(Steamworks.AppId)">
            <summary>
            The app may not actually be owned by the current user, they may have it left over from a free weekend, etc.
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.AppOwner">
            <summary>
            Gets the Steam ID of the original owner of the current app. If it's different from the current user then it is borrowed..
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.GetLaunchParam(System.String)">
            <summary>
            Gets the associated launch parameter if the game is run via steam://run/appid/?param1=value1;param2=value2;param3=value3 etc.
            Parameter names starting with the character '@' are reserved for internal use and will always return an empty string.
            Parameter names starting with an underscore '_' are reserved for steam features -- they can be queried by the game,
            but it is advised that you not param names beginning with an underscore for your own features.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.DlcDownloadProgress(Steamworks.AppId)">
            <summary>
            Gets the download progress for optional DLC.
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.BuildId">
            <summary>
            Gets the buildid of this app, may change at any time based on backend updates to the game.
            Defaults to 0 if you're not running a build downloaded from steam.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.GetFileDetailsAsync(System.String)">
            <summary>
            Asynchronously retrieves metadata details about a specific file in the depot manifest.
            Currently provides:
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.CommandLine">
            <summary>
            Get command line if game was launched via Steam URL, e.g. steam://run/appid//command line/.
            This method of passing a connect string (used when joining via rich presence, accepting an
            invite, etc) is preferable to passing the connect string on the operating system command
            line, which is a security risk.  In order for rich presence joins to go through this
            path and not be placed on the OS command line, you must set a value in your app's
            configuration on Steam.  Ask Valve for help with this.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.IsTimedTrial(System.Int32@,System.Int32@)">
            <summary>
             check if game is a timed trial with limited playtime
            </summary>
        </member>
        <member name="M:Steamworks.SteamClient.Init(System.Int32)">
            <summary>
            Initialize the steam client.
            If asyncCallbacks is false you need to call RunCallbacks manually every frame.
            </summary>
        </member>
        <member name="P:Steamworks.SteamClient.IsValid">
            <summary>
            Check if Steam is loaded and accessible.
            </summary>		
        </member>
        <member name="P:Steamworks.SteamClient.IsLoggedOn">
            <summary>
            Checks if the current user's Steam client is connected to the Steam servers.
            If it's not then no real-time services provided by the Steamworks API will be enabled. The Steam 
            client will automatically be trying to recreate the connection as often as possible. When the 
            connection is restored a SteamServersConnected_t callback will be posted.
            You usually don't need to check for this yourself. All of the API calls that rely on this will 
            check internally. Forcefully disabling stuff when the player loses access is usually not a 
            very good experience for the player and you could be preventing them from accessing APIs that do not 
            need a live connection to Steam.
            </summary>
        </member>
        <member name="F:Steamworks.SteamClient.SteamId">
            <summary>
            Gets the Steam ID of the account currently logged into the Steam client. This is 
            commonly called the 'current user', or 'local user'.
            A Steam ID is a unique identifier for a Steam accounts, Steam groups, Lobbies and Chat 
            rooms, and used to differentiate users in all parts of the Steamworks API.
            </summary>
        </member>
        <member name="F:Steamworks.SteamClient.Name">
            <summary>
            returns the local players name - guaranteed to not be NULL.
            this is the same name as on the users community profile page
            </summary>
        </member>
        <member name="P:Steamworks.SteamClient.State">
            <summary>
            gets the status of the current user
            </summary>
        </member>
        <member name="F:Steamworks.SteamClient.AppId">
            <summary>
            returns the appID of the current process
            </summary>
        </member>
        <member name="M:Steamworks.SteamClient.RestartAppIfNecessary(System.UInt32)">
            <summary>
            Checks if your executable was launched through Steam and relaunches it through Steam if it wasn't
             this returns true then it starts the Steam client if required and launches your game again through it, 
             and you should quit your process as soon as possible. This effectively runs steam://run/AppId so it 
             may not relaunch the exact executable that called it, as it will always relaunch from the version 
             installed in your Steam library folder/
             Note that during development, when not launching via Steam, this might always return true.
            </summary>
        </member>
        <member name="M:Steamworks.SteamClient.ValidCheck">
            <summary>
            Called in interfaces that rely on this being initialized
            </summary>
        </member>
        <member name="T:Steamworks.SteamFriends">
            <summary>
            Undocumented Parental Settings
            </summary>
        </member>
        <member name="P:Steamworks.SteamFriends.OnPersonaStateChange">
            <summary>
            called when a friends' status changes
            </summary>
        </member>
        <member name="P:Steamworks.SteamFriends.OnGameRichPresenceJoinRequested">
            <summary>
            Called when the user tries to join a game from their friends list
            rich presence will have been set with the "connect" key which is set here
            </summary>
        </member>
        <member name="P:Steamworks.SteamFriends.OnFriendRichPresenceUpdate">
            <summary>
            Callback indicating updated data about friends rich presence information
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.OpenUserOverlay(Steamworks.SteamId,System.String)">
            <summary>
            "steamid" - Opens the overlay web browser to the specified user or groups profile.
            "chat" - Opens a chat window to the specified user, or joins the group chat.
            "jointrade" - Opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API.
            "stats" - Opens the overlay web browser to the specified user's stats.
            "achievements" - Opens the overlay web browser to the specified user's achievements.
            "friendadd" - Opens the overlay in minimal mode prompting the user to add the target user as a friend.
            "friendremove" - Opens the overlay in minimal mode prompting the user to remove the target friend.
            "friendrequestaccept" - Opens the overlay in minimal mode prompting the user to accept an incoming friend invite.
            "friendrequestignore" - Opens the overlay in minimal mode prompting the user to ignore an incoming friend invite.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.OpenGameInviteOverlay(Steamworks.SteamId)">
            <summary>
            Activates the Steam Overlay to open the invite dialog. Invitations sent from this dialog will be for the provided lobby.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.RequestUserInformation(Steamworks.SteamId,System.Boolean)">
            <summary>
            Requests the persona name and optionally the avatar of a specified user.
            NOTE: It's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them.
            returns true if we're fetching the data, false if we already have it
            </summary>
        </member>
        <member name="T:Steamworks.SteamMatchmaking">
            <summary>
            Functions for clients to access matchmaking services, favorites, and to operate on game lobbies
            </summary>
        </member>
        <member name="P:Steamworks.SteamMatchmaking.MaxLobbyKeyLength">
            <summary>
            Maximum number of characters a lobby metadata key can be
            </summary>
        </member>
        <member name="M:Steamworks.SteamMatchmaking.CreateLobbyAsync(System.Int32)">
            <summary>
            Creates a new invisible lobby. Call lobby.SetPublic to take it online.
            </summary>
        </member>
        <member name="M:Steamworks.SteamMatchmaking.JoinLobbyAsync(Steamworks.SteamId)">
            <summary>
            Attempts to directly join the specified lobby
            </summary>
        </member>
        <member name="T:Steamworks.SteamUtils">
            <summary>
            Interface which provides access to a range of miscellaneous utility functions
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.GetImageSize(System.Int32,System.UInt32@,System.UInt32@)">
            <summary>
            returns true if the image exists, and the buffer was successfully filled out
            results are returned in RGBA format
            the destination buffer size should be 4 * height * width * sizeof(char)
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.GetImage(System.Int32)">
            <summary>
            returns the image in RGBA format
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.IsRunningOnSteamDeck">
            <summary>
            returns true if Steam itself is running on the Steam Deck
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsMe">
            <summary>
            Returns true if this is the local user
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsFriend">
            <summary>
            Return true if this is a friend
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsBlocked">
            <summary>
            Returns true if you have this user blocked
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsPlayingThisGame">
            <summary>
            Return true if this user is playing the game we're running
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsPlaying">
            <summary>
            Return true if this user is playing another game
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsOnline">
            <summary>
            Returns true if this friend is online
            </summary>
        </member>
        <member name="M:Steamworks.Friend.RequestInfoAsync">
            <summary>
            Sometimes we don't know the user's name. This will wait until we have
            downloaded the information on this user.
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsAway">
            <summary>
            Returns true if this friend is marked as away
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsBusy">
            <summary>
            Returns true if this friend is marked as busy
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsSnoozing">
            <summary>
            Returns true if this friend is marked as snoozing
            </summary>
        </member>
        <member name="M:Steamworks.Friend.InviteToGame(System.String)">
            <summary>
            Invite this friend to the game that we are playing
            </summary>
        </member>
        <member name="M:Steamworks.Friend.OpenInOverlay(System.String)">
            <summary>
            Activates the Steam Overlay to a specific dialog
            </summary>
            <param name="type">
            "steamid" - Opens the overlay web browser to the specified user or groups profile.
            "chat" - Opens a chat window to the specified user, or joins the group chat.
            "jointrade" - Opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API.
            "stats" - Opens the overlay web browser to the specified user's stats.
            "achievements" - Opens the overlay web browser to the specified user's achievements.
            "friendadd" - Opens the overlay in minimal mode prompting the user to add the target user as a friend.
            "friendremove" - Opens the overlay in minimal mode prompting the user to remove the target friend.
            "friendrequestaccept" - Opens the overlay in minimal mode prompting the user to accept an incoming friend invite.
            "friendrequestignore" - Opens the overlay in minimal mode prompting the user to ignore an incoming friend invite.
            </param>
        </member>
        <member name="M:Steamworks.Friend.SendMessage(System.String)">
            <summary>
            Sends a message to a Steam friend. Returns true if success
            </summary>
        </member>
        <member name="T:Steamworks.SteamServerInit">
            <summary>
            Used to set up the server.
            The variables in here are all required to be set, and can't be changed once the server is created.
            </summary>
        </member>
        <member name="F:Steamworks.SteamServerInit.VersionString">
            <summary>
            The version string is usually in the form x.x.x.x, and is used by the master server to detect when the server is out of date.
            If you go into the dedicated server tab on steamworks you'll be able to server the latest version. If this version number is
            less than that latest version then your server won't show.
            </summary>
        </member>
        <member name="F:Steamworks.SteamServerInit.ModDir">
            <summary>
            This should be the same directory game where gets installed into. Just the folder name, not the whole path. I.e. "Rust", "Garrysmod".
            </summary>
        </member>
        <member name="F:Steamworks.SteamServerInit.GameDescription">
            <summary>
            The game description. Setting this to the full name of your game is recommended.
            </summary>
        </member>
        <member name="F:Steamworks.SteamServerInit.DedicatedServer">
            <summary>
            Is a dedicated server
            </summary>
        </member>
        <member name="M:Steamworks.SteamServerInit.WithRandomSteamPort">
            <summary>
            Set the Steam query port
            </summary>
        </member>
        <member name="M:Steamworks.SteamServerInit.WithQueryShareGamePort">
             <summary>
             If you pass MASTERSERVERUPDATERPORT_USEGAMESOCKETSHARE into usQueryPort, then it causes the game server API to use
             "GameSocketShare" mode, which means that the game is responsible for sending and receiving UDP packets for the master
             server updater.
            
             More info about this here: https://partner.steamgames.com/doc/api/ISteamGameServer#HandleIncomingPacket
             </summary>
        </member>
        <member name="P:Steamworks.Epoch.Current">
            <summary>
            Returns the current Unix Epoch
            </summary>
        </member>
        <member name="M:Steamworks.Epoch.ToDateTime(System.Decimal)">
            <summary>
            Convert an epoch to a datetime
            </summary>
        </member>
        <member name="M:Steamworks.Epoch.FromDateTime(System.DateTime)">
            <summary>
            Convert a DateTime to a unix time
            </summary>
        </member>
        <member name="M:Steamworks.Helpers.TakeBuffer(System.Int32)">
            <summary>
            Returns a buffer. This will get returned and reused later on.
            We shouldn't really be using this anymore. 
            </summary>
        </member>
        <member name="T:Steamworks.PreserveAttribute">
            <summary>
            Prevent unity from stripping shit we depend on
            https://docs.unity3d.com/Manual/ManagedCodeStripping.html
            </summary>
        </member>
    </members>
</doc>
