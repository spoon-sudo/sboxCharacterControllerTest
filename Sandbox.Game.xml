<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sandbox.Game</name>
    </assembly>
    <members>
        <member name="M:Sandbox.ActionGraphs.ActionGraphCache.GetOrAdd``2(System.String)">
            <summary>
            Deserializes the given action graph from JSON, returning a cached copy if already deserialized.
            </summary>
            <typeparam name="TTarget">ActionGraph delegate type.</typeparam>
            <typeparam name="TDelegate">ActionGraph delegate type.</typeparam>
            <param name="json">Serialized action graph.</param>
        </member>
        <member name="T:Sandbox.ActionGraphs.IActionComponent">
            <summary>
            A component that only provides actions to implement with an Action Graph.
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.SimpleActionComponent">
            <summary>
            These should not exist
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphs.SimpleActionComponent.Action">
            <summary>
            ActionGraph to run when the relevant event occurs.
            </summary>
        </member>
        <member name="T:Sandbox.ActionGraphs.AwakeActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnAwake"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.StartActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnStart"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.EnabledActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnEnabled"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.DisabledActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnDisabled"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.UpdateActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnUpdate"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.FixedUpdateActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnFixedUpdate"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.DestroyActionComponent">
            <inheritdoc cref="M:Sandbox.Component.OnDestroy"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.CollisionActionComponent">
            <summary>
            Reacts to collisions.
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphs.CollisionActionComponent.CollisionStart">
            <inheritdoc cref="M:Sandbox.Component.ICollisionListener.OnCollisionStart(Sandbox.Collision)"/>
        </member>
        <member name="P:Sandbox.ActionGraphs.CollisionActionComponent.CollisionUpdate">
            <inheritdoc cref="M:Sandbox.Component.ICollisionListener.OnCollisionUpdate(Sandbox.Collision)"/>
        </member>
        <member name="P:Sandbox.ActionGraphs.CollisionActionComponent.CollisionStop">
            <inheritdoc cref="M:Sandbox.Component.ICollisionListener.OnCollisionStop(Sandbox.CollisionStop)"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.TriggerActionComponent">
            <summary>
            Reacts to collider triggers.
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphs.TriggerActionComponent.TriggerEnter">
            <inheritdoc cref="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.Collider)"/>
        </member>
        <member name="P:Sandbox.ActionGraphs.TriggerActionComponent.TriggerExit">
            <inheritdoc cref="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.Collider)"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.SoundFile(Sandbox.SoundFile)">
            <summary>
            A sound resource.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.SoundEvent(Sandbox.SoundEvent)">
            <summary>
            A sound event. It can play a set of random sounds with optionally random settings such as volume and pitch.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.Model(Sandbox.Model)">
            <summary>
            A model.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.Material(Sandbox.Material)">
            <summary>
            A material. Uses several Textures and a Shader with specific settings for more interesting visual effects.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.Prefab(Sandbox.PrefabFile)">
            <summary>
            A prefab.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.ResourceNodes.GameResource``1(``0)">
            <summary>
            An asset defined in C# and created through tools.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.SceneNodes.PlaySound(Sandbox.GameObject,Sandbox.SoundEvent)">
            <summary>
            Plays a sound at the position of the target object.
            </summary>
        </member>
        <member name="P:Sandbox.ActionGraphs.SceneNodes.Trace">
            <inheritdoc cref="P:Sandbox.Scene.Trace"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.SceneNodes.NetworkSpawn(Sandbox.GameObject,Sandbox.Connection)">
            <inheritdoc cref="M:Sandbox.GameObject.NetworkSpawn(Sandbox.Connection)"/>
        </member>
        <member name="T:Sandbox.ActionGraphs.SceneRefGizmo">
            <summary>
            Handles drawing lines representing ActionGraph references between objects / components in the scene.
            </summary>
        </member>
        <member name="M:Sandbox.ActionGraphs.TimeNodes.Delay(System.Single,System.Nullable{System.Threading.CancellationToken})">
            <inheritdoc cref="M:Sandbox.GameTask.DelaySeconds(System.Single)"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.TimeNodes.Delay(Sandbox.GameObject,System.Single,System.Nullable{System.Threading.CancellationToken})">
            <inheritdoc cref="M:Sandbox.GameTask.DelaySeconds(System.Single,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.TimeNodes.Delta">
            <inheritdoc cref="P:Sandbox.Time.Delta"/>
        </member>
        <member name="M:Sandbox.ActionGraphs.TimeNodes.Now">
            <inheritdoc cref="P:Sandbox.Time.Now"/>
        </member>
        <member name="T:Sandbox.ConsoleSystem">
            <summary>
            A library to interact with the Console System.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.SetValue(System.String,System.Object)">
            <summary>
            Try to set a console variable. You will only be able to set variables that you have permission to set.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.GetValue(System.String,System.String)">
            <summary>
            Get a console variable's value as a string.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.OnWrappedSet``1(Sandbox.WrappedPropertySet{``0})">
            <summary>
            When we update a ConVar in code, call the ConsoleSystem.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.Run(System.String)">
            <summary>
            Run this command. This should be a single command.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.Run(System.String,System.Object[])">
            <summary>
            Run this command, along with the arguments. We'll automatically convert them to strings and handle quoting.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.RunInternal(Sandbox.ConsoleSystem.ConsoleCommand)">
            <summary>
            Actually do the business of trying to run a command. Will return (not throw) an exception
            object if an exception is thrown of command isn't found.
            </summary>
        </member>
        <member name="M:Sandbox.ContextInterface.OwnsAssembly(System.Reflection.Assembly)">
            <summary>
            Return true if this assembly is a part of this context
            </summary>
        </member>
        <member name="T:Sandbox.Event">
            <summary>
            The event system.
            </summary>
        </member>
        <member name="M:Sandbox.Event.UnregisterAssembly(System.Reflection.Assembly)">
            <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
        </member>
        <member name="M:Sandbox.Event.RegisterAssembly(System.Reflection.Assembly)">
            <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
        </member>
        <member name="M:Sandbox.Event.Register(System.Object)">
            <summary>
            Register an object to start receiving events
            </summary>
        </member>
        <member name="M:Sandbox.Event.Unregister(System.Object)">
            <summary>
            Unregister an object, stop reviving events
            </summary>
        </member>
        <member name="M:Sandbox.Event.Run(System.String)">
            <summary>
            Run an event.
            </summary>
        </member>
        <member name="M:Sandbox.Event.Run``1(System.String,``0)">
            <summary>
            Run an event with an argument of arbitrary type.
            </summary>
            <typeparam name="T">Arbitrary type for the argument.</typeparam>
            <param name="name">Name of the event to run.</param>
            <param name="arg0">Argument to pass down to event handlers.</param>
        </member>
        <member name="M:Sandbox.Event.Run``2(System.String,``0,``1)">
            <summary>
            Run an event with 2 arguments of arbitrary type.
            </summary>
            <typeparam name="T">Arbitrary type for the first argument.</typeparam>
            <typeparam name="U">Arbitrary type for the second argument.</typeparam>
            <param name="name">Name of the event to run.</param>
            <param name="arg0">First argument to pass down to event handlers.</param>
            <param name="arg1">Second argument to pass down to event handlers.</param>
        </member>
        <member name="M:Sandbox.Event.Run``3(System.String,``0,``1,``2)">
            <summary>
            Run an event with 3 arguments of arbitrary type.
            </summary>
            <typeparam name="T">Arbitrary type for the first argument.</typeparam>
            <typeparam name="U">Arbitrary type for the second argument.</typeparam>
            <typeparam name="V">Arbitrary type for the third argument.</typeparam>
            <param name="name">Name of the event to run.</param>
            <param name="arg0">First argument to pass down to event handlers.</param>
            <param name="arg1">Second argument to pass down to event handlers.</param>
            <param name="arg2">Third argument to pass down to event handlers.</param>
        </member>
        <member name="T:Sandbox.Event.Streamer">
            <summary>
            Stream API related events. See Sandbox.Streamer.
            </summary>
        </member>
        <member name="T:Sandbox.Event.Streamer.JoinChatAttribute">
            <summary>
            Event called when joined a chat
            </summary>
        </member>
        <member name="T:Sandbox.Event.Streamer.LeaveChatAttribute">
            <summary>
            Event called when left a chat
            </summary>
        </member>
        <member name="T:Sandbox.Event.Streamer.ChatMessageAttribute">
            <summary>
            Event called when chat message comes in
            </summary>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.Reset(Sandbox.ClothingContainer,Sandbox.SkinnedModelRenderer)">
            <summary>
            Clear the outfit from this model, make it named
            </summary>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.Apply(Sandbox.ClothingContainer,Sandbox.SkinnedModelRenderer)">
            <summary>
            Dress a skinned model renderer with an outfit
            </summary>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.MountAsync(Sandbox.Package,System.Boolean)">
            <summary>
            Download and mount this package. If withCode is true we'll try to load the assembly if it exists.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.IsMounted(Sandbox.Package,System.Boolean,System.Boolean)">
            <summary>
            Download and mount this package. If withCode is true we'll try to load the assembly if it exists.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.PlayCollisionSound(Sandbox.Surface,Vector3,System.Single)">
            <summary>
            Play a collision sound based on this shape's surface. Can return null if sound is invalid, or too quiet to play.
            </summary>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.ToScreen(Vector3)">
            <summary>
            Clientside, returns position of this 3D vector on local clients' screen in 2D coordinates based on the Camera
            </summary>
            <param name="self">The vector to transform/project.</param>
            <returns>
            The position of this vector3 on the local clients' screen.<br/>
            X and Y components are in range of 0 (left, top) to 1 (right, bottom).<br/>
            The Z component stores whether this vector is behind the screen (&lt;0) or in front of it (&gt;0).
            </returns>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.ToScreen(Vector3,Vector2)">
            <summary>
            Same as <see cref="M:Sandbox.SandboxGameExtensions.ToScreen(Vector3)"/>, but return value is in absolute coordinates.
            </summary>
            <param name="self">The vector to transform/project.</param>
            <param name="screenSize">Screen size. You probably want to use <see cref="P:Sandbox.Screen.Size"/>.</param>
            <returns>Will return null if this vector is behind the screen, otherwise returns position of it on the local clients' screen.</returns>
        </member>
        <member name="M:Sandbox.SandboxGameExtensions.Draw(Sandbox.VertexBuffer,Sandbox.Material,Sandbox.RenderAttributes)">
            <summary>
            Draw this mesh using Material
            </summary>
        </member>
        <member name="T:Sandbox.FileSystem">
            <summary>
            A filesystem that can be accessed by the game.
            </summary>
        </member>
        <member name="M:Sandbox.FileSystem.NormalizeFilename(System.String)">
            <summary>
            Normalizes given file path so the game's filesystem can understand it. Fixes slashes and lowercases the file path.
            </summary>
            <param name="filepath">The file path to normalize</param>
            <returns>The normalized file path</returns>
        </member>
        <member name="P:Sandbox.FileSystem.Mounted">
            <summary>
            All mounted content.
            </summary>
        </member>
        <member name="P:Sandbox.FileSystem.Data">
            <summary>
            A subset of <see cref="P:Sandbox.FileSystem.OrganizationData"/> for custom gamemode data.
            </summary>
        </member>
        <member name="P:Sandbox.FileSystem.OrganizationData">
            <summary>
            A filesystem for custom data, per gamemode's organization.
            </summary>
        </member>
        <member name="P:Sandbox.FileSystem.Localization">
            <summary>
            A filesystem for localization
            </summary>
        </member>
        <member name="P:Sandbox.FileSystem.ProjectSettings">
            <summary>
            Internal until we have a reason for it not to be
            </summary>
        </member>
        <member name="P:Sandbox.Game.InputContext">
            <summary>
            The input context for this context (menu, gamemenu, clien)
            </summary>
        </member>
        <member name="P:Sandbox.Game.AppId">
            <summary>
            Steam AppId of S&amp;box.
            </summary>
        </member>
        <member name="P:Sandbox.Game.InGame">
            <summary>
            Return true if we're in a game (ie, not in the main menu)
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsEditor">
            <summary>
            Returns true if the game is running with the editor enabled
            </summary>
        </member>
        <member name="P:Sandbox.Game.Ident">
            <summary>
            Returns the current game's ident - ie facepunch.sandbox
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsMainMenuVisible">
            <summary>
            Returns true if the main menu is visible. Note that this will work serverside too but will only
            return the state of the host.
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsRecordingVideo">
            <summary>
            True if we're currently recording a video (using the video command, or F6)
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsClosing">
            <summary>
            Set to true when the game is closing
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsRunningInVR">
            <summary>
            Return true if we're running in VR
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsRunningOnHandheld">
            <summary>
            Return true if we're running on a handheld device (the deck). Will always be false serverside.
            </summary>
        </member>
        <member name="P:Sandbox.Game.Random">
            <summary>
            A shared random that is automatically seeded on tick
            </summary>
        </member>
        <member name="M:Sandbox.Game.SetRandomSeed(System.Int32)">
            <summary>
            Set the seed for Game.Random
            </summary>
        </member>
        <member name="P:Sandbox.Game.SteamId">
            <summary>
            Your SteamId
            </summary>
        </member>
        <member name="M:Sandbox.Game.CreateWebSurface">
            <summary>
            Create a limited web surface
            </summary>
        </member>
        <member name="M:Sandbox.Game.Disconnect">
            <summary>
            Disconnect from the current game session
            </summary>
        </member>
        <member name="P:Sandbox.Game.PhysicsTrace">
            <summary>
            Trace against the physics in the current scene
            </summary>
        </member>
        <member name="P:Sandbox.Game.SceneTrace">
            <summary>
            Trace against the physics and hitboxes in the current scene
            </summary>
        </member>
        <member name="M:Sandbox.Game.Close">
            <summary>
            Close the current game.
            </summary>
        </member>
        <member name="M:Sandbox.Game.InitUnitTest``1">
            <summary>
            Initialize for a unit test
            </summary>
        </member>
        <member name="P:Sandbox.Game.IsMenu">
            <summary>
            Returns true only when current code is running in the menu.
            </summary>
        </member>
        <member name="M:Sandbox.Game.AssertMenu(System.String)">
            <summary>
            Throws an exception when called from client or server.
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowPackageModal(System.String)">
            <summary>
            Opens a modal for the specified package
            </summary>
            <param name="ident"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowLauncher(System.String)">
            <summary>
            Opens a modal for quickly creating a game
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowOrganizationModal(Sandbox.Package.Organization)">
            <summary>
            Opens a modal for the specified organization. 
            This is most likely called from a Package - so get the organization from there.
            </summary>
            <param name="org"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowPackageSelector(System.String,System.Action{Sandbox.Package},System.Action{System.String})">
            <summary>
            Opens a modal for selecting a package
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowFriendsList(Sandbox.Modals.FriendsListModalOptions)">
            <summary>
            Opens a modal that shows the user's friends list
            </summary>
            <param name="options"></param>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowServerList(Sandbox.Modals.ServerListConfig@)">
            <summary>
            Opens a modal that shows a list of active servers
            </summary>
        </member>
        <member name="M:Sandbox.Game.Overlay.ShowBinds">
            <summary>
            Opens a modal that lets you view and rebind game input actions.
            </summary>
        </member>
        <member name="P:Sandbox.Game.Overlay.IsOpen">
            <summary>
            Returns true if any overlay is open
            </summary>
        </member>
        <member name="P:Sandbox.Game.Overlay.IsPauseMenuOpen">
            <summary>
            Returns true if the pause menu overlay is open
            </summary>
        </member>
        <member name="P:Sandbox.Internal.GlobalGameNamespace.Log">
            <summary>
            Log information to console for debugging purposes.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.GlobalGameNamespace.Cookie">
            <summary>
            Data storage that persists across sessions.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.GlobalGameNamespace.TypeLibrary">
            <summary>
            Allows access to all available types, reflection style.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.GlobalGameNamespace.NodeLibrary">
            <summary>
            A library of node definitions for action graphs.
            </summary>
        </member>
        <member name="M:Sandbox.LargeNetworkFiles.Reset">
            <summary>
            Reset the string table.
            </summary>
        </member>
        <member name="M:Sandbox.LargeNetworkFiles.Refresh">
            <summary>
            Add all files from the network.
            </summary>
        </member>
        <member name="M:Sandbox.LargeNetworkFiles.AddFile(System.String)">
            <summary>
            Add a file to be networked.
            </summary>
        </member>
        <member name="M:Sandbox.LargeNetworkFiles.RemoveFile(System.String)">
            <summary>
            Remove a networked file.
            </summary>
        </member>
        <member name="T:Sandbox.ServerPackagesStringTable">
            <summary>
            Manages the network string table "Package", which contains a list of packages that the client should
            have installed. During join the client will install these packages before loading in.
            </summary>
        </member>
        <member name="M:Sandbox.ServerPackagesStringTable.Get(System.String)">
            <summary>
            Return true if this package has been downloaded and mounted and is basically ready to go
            </summary>
        </member>
        <member name="M:Sandbox.SmallNetworkFiles.Reset">
            <summary>
            Reset the string table.
            </summary>
        </member>
        <member name="M:Sandbox.SmallNetworkFiles.Refresh">
            <summary>
            Add all files from the network.
            </summary>
        </member>
        <member name="M:Sandbox.SmallNetworkFiles.AddFile(System.String,System.Byte[])">
            <summary>
            Add a file to be networked.
            </summary>
        </member>
        <member name="M:Sandbox.SmallNetworkFiles.RemoveFile(System.String)">
            <summary>
            Remove a networked file.
            </summary>
        </member>
        <member name="T:Sandbox.EditorHandleAttribute">
            <summary>
            When applied to a component, the editor will draw a selectable handle sprite for the gameobject in scene
            </summary>
        </member>
        <member name="T:Sandbox.AudioListener">
            <summary>
            If this exists and is enabled in a scene, then the client will hear from this point rather than
            from the cameras point of view.
            </summary>
        </member>
        <member name="P:Sandbox.AudioListener.UseCameraDirection">
            <summary>
            If true, while the audio listener position will be used, the rotation element will come from the camera.
            </summary>
        </member>
        <member name="P:Sandbox.BaseSoundComponent.TargetMixer">
            <summary>
            The mixer we want this sound to play through
            </summary>
        </member>
        <member name="T:Sandbox.LipSync">
            <summary>
            Drive morphs with lipsync from sounds.
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.StayActiveOnExit">
            <summary>
            When true the soundscape will keep playinng after exiting the area, and will
            only stop playing once another soundscape takes over.
            </summary>
        </member>
        <member name="M:Sandbox.SoundscapeTrigger.TestListenerPosition(Vector3)">
            <summary>
            Return true if they should hear this soundscape when in this position
            </summary>
        </member>
        <member name="M:Sandbox.SoundscapeTrigger.StartSoundscape(Sandbox.Soundscape)">
            <summary>
            Load and start this soundscape..
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.PlayingSound.IsDead">
            <summary>
            True if this sound has finished, can be removed
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.PlayingSound.Finished">
            <summary>
            Gets set when it's time to fade this out
            </summary>
        </member>
        <member name="F:Sandbox.SoundscapeTrigger.LoopedSoundEntry.currentVolume">
            <summary>
            We store the current volume so we can seamlessly fade in and out
            </summary>
        </member>
        <member name="P:Sandbox.SoundscapeTrigger.LoopedSoundEntry.IsDead">
            <summary>
            Consider us dead if the soundscape system thinks we're finished and our volume is low
            </summary>
        </member>
        <member name="M:Sandbox.SoundscapeTrigger.LoopedSoundEntry.TryUpdateFrom(Sandbox.Soundscape.LoopedSound,System.Single)">
            <summary>
            If we're using the same sound file as this incoming sound, and we're on our way out.. then
            let it replace us instead. This is much nicer.
            </summary>
        </member>
        <member name="P:Sandbox.Voice.LastPlayed">
            <summary>
            How long has it been since this sound played?
            </summary>
        </member>
        <member name="P:Sandbox.Voice.LaughterScore">
            <summary>
            Laughter score for the current audio frame, between 0 and 1
            </summary>
        </member>
        <member name="P:Sandbox.Voice.TargetMixer">
            <summary>
            Which mixer do we want to write to
            </summary>
        </member>
        <member name="P:Sandbox.Voice.IsListening">
            <summary>
            Returns true if the mic is listening. Even if it's listening, it might
            not be playing - because it will only record and transmit if it can hear sound.
            </summary>
        </member>
        <member name="P:Sandbox.Voice.Amplitude">
            <summary>
            Measure of audio loudness.
            </summary>
        </member>
        <member name="M:Sandbox.Voice.ExcludeFilter">
            <summary>
            Exclude these connection from hearing our voice.
            </summary>
        </member>
        <member name="T:Sandbox.CameraComponent">
            <summary>
            Every scene should have at least one Camera.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.ClearFlags">
            <summary>
            The clear flags for this camera.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.BackgroundColor">
            <summary>
            The background color of this camera's view if there's no 2D Sky in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.IsMainCamera">
            <summary>
            Returns true if this is the main game camera.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.FieldOfView">
            <summary>
            The field of view of this camera.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.ZNear">
            <summary>
            The camera's near clip plane distance. This is the closest distance this camera will be able to render.
            A good value for this is about 5. Below 5 and particularly below 1 you're going to start to see
            a lot of artifacts like z-fighting.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.ZFar">
            <summary>
            The camera's far clip plane distance. This is the furthest distance this camera will be able to render.
            This value totally depends on the game you're making. Shorter the better, sensible ranges would be
            between about 1000 and 30000, but if you want it to be further out you can balance that out by making
            ZNear larger.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.Priority">
            <summary>
            The priority of this camera. Dictates which camera gets rendered on top of another. Higher means it'll be rendered on top.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.Orthographic">
            <summary>
            Whether or not to use orthographic projection instead of perspective.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.OrthographicHeight">
            <summary>
            The orthographic size for this camera while <see cref="P:Sandbox.CameraComponent.Orthographic"/> is set to true.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.TargetEye">
            <inheritdoc cref="P:Sandbox.SceneCamera.TargetEye"/>
        </member>
        <member name="P:Sandbox.CameraComponent.RenderTags">
            <summary>
            A list of tags that will be checked to include specific game objects when rendering this camera.
            If none are set, it will include everything.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.RenderExcludeTags">
            <summary>
            A list of tags that will be checked to exclude specific game objects when rendering this camera.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.Viewport">
            <summary>
            The size of the camera represented on the screen. Normalized between 0 and 1.
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.SceneCamera">
            <summary>
            Accessor for getting this Camera Component's SceneCamera
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.UpdateSceneCamera(Sandbox.SceneCamera,System.Boolean)">
            <summary>
            Update a SceneCamera with the settings from this component
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.AddToRenderList">
            <summary>
            This should only be called when creating render lists!!
            </summary>
        </member>
        <member name="P:Sandbox.CameraComponent.ScreenRect">
            <summary>
            The size of the viewport, in screen coordinates
            </summary>
        </member>
        <member name="M:Sandbox.CameraComponent.RenderToTexture(Sandbox.Texture)">
            <inheritdoc cref="M:Sandbox.Graphics.RenderToTexture(Sandbox.SceneCamera,Sandbox.Texture)"/>
        </member>
        <member name="T:Sandbox.Tonemapping.TonemappingMode">
            <summary>
            Options to select a tonemapping algorithm to use for color grading.
            </summary>
        </member>
        <member name="F:Sandbox.Tonemapping.TonemappingMode.HableFilmic">
            <summary>
            John Hable's filnic tonemapping algorithm.
            Matches the default curve Source 2 uses based on Uncharted 2.
            </summary>
        </member>
        <member name="F:Sandbox.Tonemapping.TonemappingMode.ACES">
            <summary>
            The most realistic tonemapper at handling bright light, desaturating light as it becomes brighter.
            This is slightly more expensive than other options.
            </summary>
        </member>
        <member name="F:Sandbox.Tonemapping.TonemappingMode.Legacy">
            <summary>
            Source 2 native tonemapper, same as Hable Filmic but with auto exposure bells and whistles.
            </summary>
        </member>
        <member name="P:Sandbox.Tonemapping.Mode">
            <summary>
            Which tonemapping algorithm to use for color grading.
            </summary>
        </member>
        <member name="P:Sandbox.CharacterController.Bounciness">
            <summary>
            When jumping into walls, should we bounce off or just stop dead?
            </summary>
        </member>
        <member name="P:Sandbox.CharacterController.UseCollisionRules">
            <summary>
            If enabled, determine what to collide with using current project's collision rules for the <see cref="P:Sandbox.GameObject.Tags"/>
            of the containing <see cref="T:Sandbox.GameObject"/>.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.Accelerate(Vector3)">
            <summary>
            Add acceleration to the current velocity. 
            No need to scale by time delta - it will be done inside.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.ApplyFriction(System.Single,System.Single)">
            <summary>
            Apply an amount of friction to the current velocity.
            No need to scale by time delta - it will be done inside.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.TraceDirection(Vector3)">
            <summary>
            Trace the controller's current position to the specified delta
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.Punch(Vector3@)">
            <summary>
            Disconnect from ground and punch our velocity. This is useful if you want the player to jump or something.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.Move">
            <summary>
            Move a character, with this velocity
            </summary>
        </member>
        <member name="M:Sandbox.CharacterController.MoveTo(Vector3,System.Boolean)">
            <summary>
            Move from our current position to this target position, but using tracing an sliding.
            This is good for different control modes like ladders and stuff.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterControllerHelper.TraceFromTo(Vector3,Vector3)">
            <summary>
            Trace this from one position to another
            </summary>
        </member>
        <member name="M:Sandbox.CharacterControllerHelper.TryMove(System.Single)">
            <summary>
            Try to move to the position. Will return the fraction of the desired velocity that we traveled.
            Position and Velocity will be what we recommend using.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterControllerHelper.TraceMove(Vector3)">
            <summary>
            Move our position by this delta using trace. If we hit something we'll stop,
            we won't slide across it nicely like TryMove does.
            </summary>
        </member>
        <member name="M:Sandbox.CharacterControllerHelper.TryMoveWithStep(System.Single,System.Single)">
            <summary>
            Like TryMove but will also try to step up if it hits a wall
            </summary>
        </member>
        <member name="T:Sandbox.VelocityClipPlanes">
            <summary>
            Used to store a list of planes that an object is going to hit, and then
            remove velocity from them so the object can slide over the surface without
            going through any of the planes.
            </summary>
        </member>
        <member name="P:Sandbox.VelocityClipPlanes.Max">
            <summary>
            Maximum number of planes that can be hit
            </summary>
        </member>
        <member name="P:Sandbox.VelocityClipPlanes.Count">
            <summary>
            Number of planes we're currently holding
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.TryAdd(Vector3,Vector3@,System.Single)">
            <summary>
            Try to add this plane and restrain velocity to it (and its brothers)
            </summary>
            <returns>False if we ran out of room and should stop adding planes</returns>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.TryClip(Vector3@)">
            <summary>
            Try to clip our velocity to all the planes, so we're not travelling into them
            Returns true if we clipped properly
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.MovingTowardsAnyPlane(Vector3,System.Int32)">
            <summary>
            Returns true if we're moving towards any of our planes (except for skip)
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.StartBump(Vector3)">
            <summary>
            Start a new bump. Clears planes and resets BumpVelocity
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.ClipVelocity(Vector3,Vector3,System.Single)">
            <summary>
            Clip the velocity to the normal
            </summary>
        </member>
        <member name="P:Sandbox.BoxCollider.Scale">
            <summary>
            The size of the box, from corner to corner.
            </summary>
        </member>
        <member name="P:Sandbox.BoxCollider.Center">
            <summary>
            The center of the box relative to this GameObject
            </summary>
        </member>
        <member name="P:Sandbox.CapsuleCollider.Start">
            <summary>
            Bottom point of the capsule
            </summary>
        </member>
        <member name="P:Sandbox.CapsuleCollider.End">
            <summary>
            Top point of the capsule
            </summary>
        </member>
        <member name="P:Sandbox.CapsuleCollider.Radius">
            <summary>
            Radius of the capsule
            </summary>
        </member>
        <member name="P:Sandbox.Collider.Rigidbody">
            <summary>
            If this collider is part of a Rigidbody then this will return the component
            that it's attached to. If this is null it's usually a good indication that this
            collider is either static, world geometry, or a keyframe.
            </summary>
        </member>
        <member name="M:Sandbox.Collider.CreatePhysicsShapes(Sandbox.PhysicsBody)">
            <summary>
            Overridable in derived component to create shapes
            </summary>
        </member>
        <member name="P:Sandbox.Collider.OnTriggerEnter">
            <summary>
            Called when a collider enters this trigger
            </summary>
        </member>
        <member name="P:Sandbox.Collider.OnTriggerExit">
            <summary>
            Called when a collider exits this trigger
            </summary>
        </member>
        <member name="M:Sandbox.Collider.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our shape tags
            </summary>
        </member>
        <member name="P:Sandbox.Collider.Touching">
            <summary>
            If we're a trigger, this will list all of the colliders that are touching us.
            If we're not a trigger, this will list all of the triggers that we are touching.
            </summary>
        </member>
        <member name="M:Sandbox.Collider.ConfigureShapes">
            <summary>
            Apply any things that we an apply after they're created
            </summary>
        </member>
        <member name="T:Sandbox.CollisionEventSystem">
            <summary>
            Used to abstract the listening of collision events
            </summary>
        </member>
        <member name="P:Sandbox.HullCollider.Type">
            <summary>
            The type of primitive.
            </summary>
        </member>
        <member name="P:Sandbox.HullCollider.Center">
            <summary>
            The center of the primitive relative to this GameObject.
            </summary>
        </member>
        <member name="P:Sandbox.HullCollider.BoxSize">
            <summary>
            The size of the box, from corner to corner.
            </summary>
        </member>
        <member name="P:Sandbox.ModelPhysics.MotionEnabled">
            <summary>
            Enable to drive renderer from physics, disable to drive physics from renderer.
            </summary>
        </member>
        <member name="M:Sandbox.ModelPhysics.OnTagsChanged">
            <summary>
            The gameobject tags have changed, update collision tags on the target objects
            </summary>
        </member>
        <member name="P:Sandbox.PlaneCollider.Scale">
            <summary>
            The size of the plane, from corner to corner.
            </summary>
        </member>
        <member name="P:Sandbox.PlaneCollider.Center">
            <summary>
            The center of the plane relative to this GameObject
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.MassOverride">
            <summary>
            Override mass for this body, only when value is more than zero
            </summary>
        </member>
        <member name="P:Sandbox.Rigidbody.PhysicsBody">
            <summary>
            Get the actual physics body that was created by this component. You should be careful, this
            can of course be null when the object is not enabled or the physics world is not available. 
            It might also get deleted and re-created, so best use this to access, but don't store it.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.FindClosestPoint(Vector3@)">
            <summary>
            Returns the closest point to the given one between all convex shapes of this body.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.GetVelocityAtPoint(Vector3@)">
            <summary>
            Returns the world space velocity of a point of the object. This is useful for objects rotating around their own axis/origin.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyForceAt(Vector3@,Vector3@)">
            <summary>
            Applies force to this body at given position.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyForce(Vector3@)">
            <summary>
            Applies linear force to this body
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyTorque(Vector3@)">
            <summary>
            Applies angular velocity to this body.
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyImpulseAt(Vector3@,Vector3@)">
            <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body at given position
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ApplyImpulse(Vector3@)">
            <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body
            </summary>
        </member>
        <member name="M:Sandbox.Rigidbody.ClearForces">
            <summary>
            Clear accumulated linear forces (<see cref="M:Sandbox.Rigidbody.ApplyForce(Vector3@)"/> and <see cref="M:Sandbox.Rigidbody.ApplyForceAt(Vector3@,Vector3@)"/>) during this physics frame that were not yet applied to the physics body.
            </summary>
        </member>
        <member name="T:Sandbox.Component">
            <summary>
            A GameObject can have many components, which are the building blocks of the game.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Scene">
            <summary>
            The scene this Component is in. This is a shortcut for `GameObject.Scene`.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Transform">
            <summary>
            The transform of the GameObject this component belongs to. Components don't have their own transforms
            but they can access the transform of the GameObject they belong to. This is a shortcut for `GameObject.Transform`.
            </summary>
        </member>
        <member name="P:Sandbox.Component.GameObject">
            <summary>
            The GameObject this component belongs to.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Task">
            <summary>
            Allow creating tasks that are automatically cancelled when the GameObject is destroyed.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Components">
            <summary>
            Access components on this component's GameObject
            </summary>
        </member>
        <member name="M:Sandbox.Component.InitializeComponent">
            <summary>
            Called to call Awake, once, at startup.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Enabled">
            <summary>
            The enable state of this Component. This doesn't tell you whether it the Component is actually active
            because its parent GameObject might be disabled. This merely tells you what the Component wants to be.
            You should use Active to determine whether the object is truly active in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Active">
            <summary>
            True if this Component is enabled, and all of its ancestor GameObjects are enabled
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnAwake">
            <summary>
            Called once per component
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnEnabled">
            <summary>
            Called after Awake or whenever the component switches to being enabled (because a gameobject heirachy active change, or the component changed)
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnDestroy">
            <summary>
            Called once, when the component or gameobject is destroyed
            </summary>
        </member>
        <member name="M:Sandbox.Component.SetUpdateAction``1(System.Action@,System.Action,Sandbox.Utility.BufferedHashSet{Sandbox.Component})">
            <summary>
            Replaces <paramref name="currentAction"/> with <paramref name="newAction"/>, and adds / removes this component
            from the given <paramref name="updateSet"/>, depending on whether the new action is null, and this type implements
            the given <typeparamref name="TSubscriber"/> interface.
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnValidate">
            <summary>
            Called immediately after deserializing, and when a property is changed in the editor.
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnRefresh">
            <summary>
            Called immediately after being refreshed from a network snapshot.
            </summary>
        </member>
        <member name="M:Sandbox.Component.EditLog(System.String,System.Object)">
            <summary>
            Called when something on the component has been edited
            </summary>
        </member>
        <member name="P:Sandbox.Component.Tags">
            <inheritdoc cref="P:Sandbox.GameObject.Tags"/>
        </member>
        <member name="M:Sandbox.Component.OnTagsChanged">
            <summary>
            When tags have been updated
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnParentChanged(Sandbox.GameObject,Sandbox.GameObject)">
            <summary>
            The parent has changed from one parent to another
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnPropertyDirty``1(Sandbox.WrappedPropertySet{``0})">
            <summary>
            Called when a property is set, which will run a callback
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnDirty">
            <summary>
            Called when the component has become dirty
            </summary>
        </member>
        <member name="M:Sandbox.Component.DrawGizmos">
            <summary>
            Called in the editor to draw things like bounding boxes etc
            </summary>
        </member>
        <member name="M:Sandbox.Component.ForceChangeId(System.Guid)">
            <summary>
            Should only be called by <see cref="M:Sandbox.GameObjectDirectory.Add(Sandbox.Component)"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Component.IsProxy">
            <summary>
            True if this is a networked object and is owned by another client. This means that we're
            not controlling this object, so shouldn't try to move it or anything.
            </summary>
        </member>
        <member name="M:Sandbox.Component.CheckRequireComponent">
            <summary>
            Check all of our properties for a [RequireComponent] attribute. 
            If we find one, and the property is null, try to find one or create one.
            Runs in the editor as well as in game.
            </summary>
        </member>
        <member name="M:Sandbox.Component.ShouldSerializeMember(Sandbox.MemberDescription)">
            <summary>
            Should the given property or field be serialized?
            </summary>
        </member>
        <member name="M:Sandbox.Component.DeserializeImmediately(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Deserialize this component as per <see cref="M:Sandbox.Component.Deserialize(System.Text.Json.Nodes.JsonObject)"/> but update <see cref="P:Sandbox.Component.GameObject"/> and <see cref="T:Sandbox.Component"/> property
            references immediately instead of having them deferred.
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnStart">
            <summary>
            Called once before the first Update - when enabled.
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnUpdate">
            <summary>
            When enabled, called every frame
            </summary>
        </member>
        <member name="M:Sandbox.Component.OnFixedUpdate">
            <summary>
            When enabled, called on a fixed interval that is determined by the Scene. This
            is also the fixed interval in which the physics are ticked. Time.Delta is that
            fixed interval.
            </summary>
        </member>
        <member name="P:Sandbox.Component.ComponentVersion">
            <summary>
            The version of the component. Used by <see cref="T:Sandbox.JsonUpgrader"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Component.ExecuteInEditor">
            <summary>
            A component with this interface will run in the editor
            </summary>
        </member>
        <member name="T:Sandbox.Component.ICollisionListener">
            <summary>
            A component with this interface can react to collisions
            </summary>
        </member>
        <member name="M:Sandbox.Component.ICollisionListener.OnCollisionStart(Sandbox.Collision)">
            <summary>
            Called when this collider/rigidbody starts touching another collider.
            </summary>
        </member>
        <member name="M:Sandbox.Component.ICollisionListener.OnCollisionUpdate(Sandbox.Collision)">
            <summary>
            Called once per physics step for every collider being touched.
            </summary>
        </member>
        <member name="M:Sandbox.Component.ICollisionListener.OnCollisionStop(Sandbox.CollisionStop)">
            <summary>
            Called when this collider/rigidbody stops touching another collider.
            </summary>
        </member>
        <member name="T:Sandbox.Component.IColorProvider">
            <summary>
            When applied to a component, the component will be able to provide the color to use for certain UI editor elements
            </summary>
        </member>
        <member name="T:Sandbox.Component.IDamageable">
            <summary>
            A component that can be damaged by something
            </summary>
        </member>
        <member name="T:Sandbox.Component.INetworkListener">
            <summary>
            A component with this interface can react to network events
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkListener.OnConnected(Sandbox.Connection)">
            <summary>
            Called when someone connection joins the server
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkListener.OnDisconnected(Sandbox.Connection)">
            <summary>
            Called when someone leaves the server
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkListener.OnActive(Sandbox.Connection)">
            <summary>
            Called when someone is all loaded and entered the game
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkListener.OnBecameHost(Sandbox.Connection)">
            <summary>
            Called when the host of the game has left - and you are now the new host
            </summary>
        </member>
        <member name="T:Sandbox.Component.INetworkSpawn">
            <summary>
            A component with this interface can react to network events
            </summary>
        </member>
        <member name="M:Sandbox.Component.INetworkSpawn.OnNetworkSpawn(Sandbox.Connection)">
            <summary>
            Called when this object is spawned on the network
            </summary>
        </member>
        <member name="T:Sandbox.Component.ITintable">
            <summary>
            A component that lets you change its color
            </summary>
        </member>
        <member name="T:Sandbox.Component.ITriggerListener">
            <summary>
            A component with this interface can react to interactions with triggers
            </summary>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.Collider)">
            <summary>
            Called when a collider enters the trigger.
            </summary>
        </member>
        <member name="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.Collider)">
            <summary>
            Called when a collider stops touching the trigger.
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Hidden">
            <summary>
            Hide this component in component inspector
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.NotSaved">
            <summary>
            Don't save this component to disk, or when duplicating etc
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Error">
            <summary>
            There's something wrong with this
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Loading">
            <summary>
            Loading something
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Deserializing">
            <summary>
            Is in the process of deserializing
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.NotEditable">
            <summary>
            Cannot be edited in the component inspector
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.NotNetworked">
            <summary>
            Keep local - don't network this component as part of the scene snapshot
            </summary>
        </member>
        <member name="F:Sandbox.ComponentFlags.Refreshing">
            <summary>
            In the process of refreshing from the network
            </summary>
        </member>
        <member name="T:Sandbox.LegacyParticleSystem">
            <summary>
            Support's Source Engine's vpcf particles
            </summary>
        </member>
        <member name="T:Sandbox.Gib">
            <summary>
            A gib is a prop that is treated slightly different. It will fade out after a certain amount of time.
            </summary>
        </member>
        <member name="T:Sandbox.ManualHitbox">
            <summary>
            A hitbox that can be placed manually on a GameObject, instead of coming from a model
            </summary>
        </member>
        <member name="P:Sandbox.ManualHitbox.Target">
            <summary>
            The target GameObject to report in trace hits. If this is unset we'll default to the gameobject on which this component is.
            </summary>
        </member>
        <member name="M:Sandbox.ManualHitbox.OnTagsChanged">
            <summary>
            Tags have been updated
            </summary>
        </member>
        <member name="T:Sandbox.ModelHitboxes">
            <summary>
            Hitboxes from a model
            </summary>
        </member>
        <member name="P:Sandbox.ModelHitboxes.Renderer">
            <summary>
            The target SkinnedModelRenderer that holds the model/skeleton you want to 
            take the hitboxes from.
            </summary>
        </member>
        <member name="P:Sandbox.ModelHitboxes.Target">
            <summary>
            The target GameObject to report in trace hits. If this is unset we'll defaault to the gameobject on which this component is.
            </summary>
        </member>
        <member name="M:Sandbox.ModelHitboxes.OnTagsChanged">
            <summary>
            The gameobject tags have changed, update collision tags on the target objects
            </summary>
        </member>
        <member name="T:Sandbox.Prop">
            <summary>
            A prop is defined by its model. The model can define its health and what happens when it breaks.
            This component is designed to be easy to use - since you only need to define the model. Although you can 
            access the procedural (hidden) components, they aren't saved, so it's a waste of time.
            </summary>
        </member>
        <member name="P:Sandbox.Prop.IsStatic">
            <summary>
            If the prop is static - it won't have dynamic physics. This is usually used for things that
            you want to be breakable but don't move. Like fences and stuff.
            </summary>
        </member>
        <member name="M:Sandbox.Prop.Break">
            <summary>
            Delete this component and split into the procedural components that this prop created.
            </summary>
        </member>
        <member name="T:Sandbox.BallJoint">
            <summary>
            Fix two objects together but can rotate - like a shoulder.
            </summary>
        </member>
        <member name="T:Sandbox.FixedJoint">
            <summary>
            Weld two physics objects together
            </summary>
        </member>
        <member name="T:Sandbox.HingeJoint">
            <summary>
            Create a hinged connection between two physics objects. Like a door hinge or a wheel.
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.MinAngle">
            <summary>
            Minimum angle it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.MaxAngle">
            <summary>
            Maximum angle it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.Motor">
            <summary>
            Motor mode
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.Friction">
            <summary>
            Hinge friction
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.TargetAngle">
            <summary>
            Target angle of motor
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.Fequency">
            <summary>
            Fequency of motor
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.DampingRatio">
            <summary>
            Damping of motor
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.TargetVelocity">
            <summary>
            Target velocity of motor
            </summary>
        </member>
        <member name="P:Sandbox.HingeJoint.MaxTorque">
            <summary>
            Max torque of motor
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Body">
            <summary>
            Game object to find the body to attach this joint to.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.EnableCollision">
            <summary>
            Enable or disable collision between the two bodies.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.BreakForce">
            <summary>
            Strength of the linear constraint. If it takes any more energy than this, it'll break.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.BreakTorque">
            <summary>
            Strength of the angular constraint. If it takes any more energy than this, it'll break.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Body1">
            <summary>
            The source physics body this joint is attached to.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Body2">
            <summary>
            The target physics body this joint is constraining.
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Point1">
            <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Joint.Body1"/>
            </summary>
        </member>
        <member name="P:Sandbox.Joint.Point2">
            <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Joint.Body2"/>
            </summary>
        </member>
        <member name="P:Sandbox.Joint.OnBreak">
            <summary>
            Called when the joint breaks.
            </summary>
        </member>
        <member name="M:Sandbox.Joint.CreateJoint(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint)">
            <summary>
            Joint type implementation.
            </summary>
        </member>
        <member name="T:Sandbox.SliderJoint">
            <summary>
            Restrict an object to one axis, relative to another object. Like a drawer opening.
            </summary>
        </member>
        <member name="P:Sandbox.SliderJoint.MaxLength">
            <summary>
            Maximum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.SliderJoint.MinLength">
            <summary>
            Minimum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.SliderJoint.Friction">
            <summary>
            Slider friction
            </summary>
        </member>
        <member name="T:Sandbox.SpringJoint">
            <summary>
            Try to keep an object a set distance away from another object. Like a spring connecting two objects.
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.Frequency">
            <summary>
            The stiffness of the spring
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.Damping">
            <summary>
            The damping ratio of the spring, usually between 0 and 1
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.MaxLength">
            <summary>
            Maximum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.MinLength">
            <summary>
            Minimum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.AmbientLight.Color">
            <summary>
            Ambient light color outside of all light probes.
            </summary>
        </member>
        <member name="P:Sandbox.DirectionalLight.SkyColor">
            <summary>
            Color of the ambient sky color
            This is kept for long term support, the recommended way to do this is with an Ambient Light component.
            </summary>
        </member>
        <member name="F:Sandbox.EnvmapProbe.Texture">
            <summary>
            If this is set, the EnvmapProbe will use a custom cubemap texture instead of render dynamically
            </summary>
        </member>
        <member name="M:Sandbox.EnvmapProbe.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our tags
            </summary>
        </member>
        <member name="P:Sandbox.EnvmapProbe.MaxDistance">
            <summary>
            Only update dynamically if we're this close to it
            </summary>
        </member>
        <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.OnEnabled">
            <summary>
            Update once, when the cubemap is enabled
            </summary>
        </member>
        <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.EveryFrame">
            <summary>
            Update every frame (slow, not recommended)
            </summary>
        </member>
        <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.FrameInterval">
            <summary>
            Update every x frames
            </summary>
        </member>
        <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.TimeInterval">
            <summary>
            Update on a time based interval
            </summary>
        </member>
        <member name="P:Sandbox.Light.LightColor">
            <summary>
            The main color of the light
            </summary>
        </member>
        <member name="P:Sandbox.Light.Shadows">
            <summary>
            Should this light cast shadows?
            </summary>
        </member>
        <member name="M:Sandbox.Light.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our light's tags
            </summary>
        </member>
        <member name="P:Sandbox.MapInstance.IsLoaded">
            <summary>
            True if the map is loaded
            </summary>
        </member>
        <member name="P:Sandbox.MapInstance.OnMapLoaded">
            <summary>
            Called when the map has successfully loaded
            </summary>
        </member>
        <member name="P:Sandbox.MapInstance.OnMapUnloaded">
            <summary>
            Called when the map has been unloaded
            </summary>
        </member>
        <member name="P:Sandbox.MapInstance.Bounds">
            <summary>
            Get the world bounds of the map
            </summary>
        </member>
        <member name="M:Sandbox.MapInstance.UnloadMap">
            <summary>
            Unload the current map.
            </summary>
        </member>
        <member name="M:Sandbox.MapInstance.OnCreateObject(Sandbox.GameObject,Sandbox.MapLoader.ObjectEntry)">
            <summary>
            Override this to add components to a map object.
            Only called for map objects that are not implemented.
            </summary>
        </member>
        <member name="T:Sandbox.SkyboxMapLoader">
            <summary>
            Loader for a 3D skybox which updates the values on the parent sceneworld
            </summary>
        </member>
        <member name="T:Sandbox.MeshComponent">
            <summary>
            An editable polygon mesh with collision
            </summary>
        </member>
        <member name="T:Sandbox.PolygonMesh">
            <summary>
            An editable mesh made up of polygons, triangulated into a model
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.IsDirty">
            <summary>
            Has there been changes to the mesh that need rebuilding?
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.Transform">
            <summary>
            Where is the mesh in worldspace.
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.VertexHandles">
            <summary>
            All of the vertex handles being used
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.FaceHandles">
            <summary>
            All of the face handles being used
            </summary>
        </member>
        <member name="P:Sandbox.PolygonMesh.HalfEdgeHandles">
            <summary>
            All of the half edge handles being used
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.AddVertex(Vector3)">
            <summary>
            Add a vertex to the topology
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.AddVertices(Vector3[])">
            <summary>
            Add multiple vertices to the topology
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.AddFace(HalfEdgeMesh.VertexHandle[])">
            <summary>
            Connect these vertices to make a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.CalculateBounds">
            <summary>
            Calculate bounds of all vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.CalculateBounds(Transform)">
            <summary>
            Calculate bounds of all transformed vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.Scale(Vector3)">
            <summary>
            Scale all vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetFaceMaterial(HalfEdgeMesh.FaceHandle,Sandbox.Material)">
            <summary>
            Assign a material to a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetFaceMaterial(HalfEdgeMesh.FaceHandle,System.String)">
            <summary>
            Assign a material to a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetFaceMaterial(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get a material a face is using
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetEdgeSmoothing(HalfEdgeMesh.HalfEdgeHandle)">
            <summary>
            Get the smoothing of this edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetEdgeSmoothing(HalfEdgeMesh.HalfEdgeHandle,Sandbox.PolygonMesh.EdgeSmoothMode)">
            <summary>
            Set the smoothing of this edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.TriangleToFace(System.Int32)">
            <summary>
            Convert a triangle index to a face handle
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.ExtrudeFaces(HalfEdgeMesh.FaceHandle[],System.Collections.Generic.List{HalfEdgeMesh.FaceHandle}@,System.Collections.Generic.List{HalfEdgeMesh.FaceHandle}@,Vector3)">
            <summary>
            Extrude multiple faces along an offset
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.DetachFaces(HalfEdgeMesh.FaceHandle[],System.Collections.Generic.List{HalfEdgeMesh.FaceHandle}@)">
            <summary>
            Detatch multiple faces
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.CreateFaceInEdgeLoop(HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.FaceHandle@)">
            <summary>
            Add a face filling in the open edge loop specified by the provided edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetHalfEdgeFace(HalfEdgeMesh.HalfEdgeHandle)">
            <summary>
            Get the face connected to this half edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.IsEdgeOpen(HalfEdgeMesh.HalfEdgeHandle)">
            <summary>
            Determine if the specified edge is open (only has one connected face)
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.ExtrudeEdge(HalfEdgeMesh.HalfEdgeHandle,Vector3)">
            <summary>
            Extrude a single open edge along an offset
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.FindEdgeRing(HalfEdgeMesh.HalfEdgeHandle,System.Collections.Generic.List{HalfEdgeMesh.HalfEdgeHandle}@)">
            <summary>
            Find all of the edges in the ring with the specified edge. An edge ring is the set of edges that
            are connected by a loop of faces.
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.BridgeEdges(HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.FaceHandle@)">
            <summary>
            Bridge two edges (create a face connecting them). The edges must both be open and belong to
            different faces.
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.ConnectEdges(System.Collections.Generic.IReadOnlyList{HalfEdgeMesh.HalfEdgeHandle},System.Collections.Generic.List{HalfEdgeMesh.HalfEdgeHandle}@)">
            <summary>
            Connect the specified edges by adding a vertex to their mid point of each edge and then 
            connecting the vertices.
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetEdgeLine(HalfEdgeMesh.HalfEdgeHandle)">
            <summary>
            Get start and end points of an edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetEdgeVertices(HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.VertexHandle@,HalfEdgeMesh.VertexHandle@)">
            <summary>
            Get the two vertices of this half edge
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetVertexPosition(HalfEdgeMesh.VertexHandle,Vector3)">
            <summary>
            Set the position of a vertex
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetVertexPosition(HalfEdgeMesh.VertexHandle)">
            <summary>
            Get the position of a vertex
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetVertexPosition(HalfEdgeMesh.VertexHandle,Transform,Vector3@)">
            <summary>
            Get the position of a vertex
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetVertexPositions">
            <summary>
            Get the positions of all vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetFaceCenter(HalfEdgeMesh.FaceHandle)">
            <summary>
            Calculate the center point of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetEdges">
            <summary>
            Get the start and end points of all edges
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.ApplyTransform(Transform)">
            <summary>
            Transform all the vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetFaceEdges(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get all edge handles of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetFaceVertices(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get all vertex handles of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetTextureOffset(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get texture offset of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetTextureOffset(HalfEdgeMesh.FaceHandle,Vector2)">
            <summary>
            Set texture offset of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.GetTextureScale(HalfEdgeMesh.FaceHandle)">
            <summary>
            Get texture scale of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetTextureScale(HalfEdgeMesh.FaceHandle,Vector2)">
            <summary>
            Set texture scale of a face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.TextureAlignToGrid(Transform,HalfEdgeMesh.FaceHandle)">
            <summary>
            Align face texture properties to grid
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.TextureAlignToFace(Transform,HalfEdgeMesh.FaceHandle)">
            <summary>
            Align face texture properties to face
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetFaceTextureCoords(HalfEdgeMesh.FaceHandle,System.Collections.Generic.IReadOnlyList{Vector2})">
            <summary>
            Set face texture coords
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.SetFaceTextureParameters(HalfEdgeMesh.FaceHandle,Vector2,Vector3,Vector3)">
            <summary>
            Set face texture properties
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.TextureAlignToGrid(Transform)">
            <summary>
            Align all face texture properties to grid
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.RemoveFaces(System.Collections.Generic.IEnumerable{HalfEdgeMesh.FaceHandle})">
            <summary>
            Remove these faces
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.RemoveVertices(System.Collections.Generic.IEnumerable{HalfEdgeMesh.VertexHandle})">
            <summary>
            Remove these vertices
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.RemoveEdges(System.Collections.Generic.IEnumerable{HalfEdgeMesh.HalfEdgeHandle})">
            <summary>
            Remove these edges
            </summary>
        </member>
        <member name="M:Sandbox.PolygonMesh.Rebuild">
            <summary>
            Triangulate the polygons into a model
            </summary>
        </member>
        <member name="T:Sandbox.MissingComponent">
            <summary>
            This is added when a component is missing. It will store the json data of the missing component, so we don't lose any data.
            </summary>
        </member>
        <member name="M:Sandbox.MissingComponent.GetJson">
            <summary>
            Get the Json data that was deserialized
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.UpdatePosition">
            <summary>
            Set the Position of the GameObject to the agent position every frame. You can turn this off and handle it yourself by using the AgentPosition property.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.UpdateRotation">
            <summary>
            This will simply face the direction it is moving. It is not configurable on purpose, so you should really turn this off and be doing this yourself if you need it to do anything specific.
            </summary>
        </member>
        <member name="P:Sandbox.NavMeshAgent.AgentPosition">
            <summary>
            Updated  with the agent's position, even if UpdatePosition is false
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.SetAgentPosition(Vector3)">
            <summary>
            If you want to move the agent from one position to another
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.MoveTo(Vector3)">
            <summary>
            Navigate to the position
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.Stop">
            <summary>
            Stop moving, or whatever we're doing
            </summary>
        </member>
        <member name="M:Sandbox.NavMeshAgent.GetLookAhead(System.Single)">
            <summary>
            Get a point on the current path, distance away from here. This is a simplified path so 
            only includes the first few corners.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleAttractor">
            <summary>
            Attract particles to a GameObject in the scene
            </summary>
        </member>
        <member name="T:Sandbox.ParticleController">
            <summary>
            Particles can have extra controllers that can modify the particles every frame.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleController.ParticleEffect">
            <summary>
            The particle we're controlling
            </summary>
        </member>
        <member name="M:Sandbox.ParticleController.OnBeforeStep(System.Single)">
            <summary>
            Called before the particle step
            </summary>
        </member>
        <member name="M:Sandbox.ParticleController.OnAfterStep(System.Single)">
            <summary>
            Called after the particle step
            </summary>
        </member>
        <member name="M:Sandbox.ParticleController.OnParticleStep(Sandbox.Particle,System.Single)">
            <summary>
            Called for each particle during the particle step. This is super threaded
            so you better watch out.
            </summary>
        </member>
        <member name="M:Sandbox.ParticleController.OnParticleCreated(Sandbox.Particle)">
            <summary>
            By default we create and return the listener
            </summary>
        </member>
        <member name="T:Sandbox.ParticleEmitter">
            <summary>
            Creates particles. Should be attached to a <see cref="T:Sandbox.ParticleEffect"/>.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.Burst">
            <summary>
            How many particles to emit, in a burst
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.Rate">
            <summary>
            How many particles to emit over time
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.RateOverDistance">
            <summary>
            How many particles to emit per 100 units moved
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.Delta">
            <summary>
            0-1, the life time of the emitter
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.IsBursting">
            <summary>
            True if we're doing a burst
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEmitter.EmitRandom">
            <summary>
            0-1, a random number to be used for this loop of the emitter
            </summary>
        </member>
        <member name="M:Sandbox.ParticleEmitter.GetBurstCount">
            <summary>
            Allows child emitters to override how many particles are in a burst
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.ParticleEmitter.GetRateCount">
            <summary>
            Allows child emitters to override how many particles are in a rate
            </summary>
            <returns></returns>
        </member>
        <member name="T:Sandbox.ParticleRingEmitter">
            <summary>
            Emits particles in a ring. The ring can be flat or have a tube-like quality.
            
            Velocity can either be added from the center of the ring, or from the ring itself.
            </summary>
        </member>
        <member name="F:Sandbox.Particle.LifeDelta">
            <summary>
            A range from 0 to 1 descriving how long this particle has been alive
            </summary>
        </member>
        <member name="F:Sandbox.Particle.DeathTime">
            <summary>
            The time that this particle is scheduled to die
            </summary>
        </member>
        <member name="M:Sandbox.Particle.Get``1(System.String)">
            <summary>
            Get an arbituary data value
            </summary>
        </member>
        <member name="M:Sandbox.Particle.Set``1(System.String,``0)">
            <summary>
            Set an arbituary data value
            </summary>
        </member>
        <member name="T:Sandbox.Particle.BaseListener">
            <summary>
            Allows creating a class that will exist for as long as a particle.
            The methods get called in the particle thread, which removes the need to run through
            the particle list again, but it has the danger and restrictions that come with threaded code.
            </summary>
        </member>
        <member name="P:Sandbox.Particle.BaseListener.Source">
            <summary>
            The component that created this listener. May be null.
            </summary>
        </member>
        <member name="M:Sandbox.Particle.BaseListener.OnEnabled(Sandbox.Particle)">
            <summary>
            Called in a thread. The particle is in its first position.
            </summary>
        </member>
        <member name="M:Sandbox.Particle.BaseListener.OnUpdate(Sandbox.Particle,System.Single)">
            <summary>
            Called in a thread, guarenteed to be called after OnEnabled
            </summary>
        </member>
        <member name="M:Sandbox.Particle.BaseListener.OnDisabled(Sandbox.Particle)">
            <summary>
            Called in a thread. OnUpdate won't be called again.
            </summary>
        </member>
        <member name="M:Sandbox.Particle.AddListener(Sandbox.Particle.BaseListener,Sandbox.Component)">
            <summary>
            Add a listener.
            </summary>
        </member>
        <member name="M:Sandbox.Particle.RemoveListener(Sandbox.Particle.BaseListener)">
            <summary>
            Remove a listener
            </summary>
        </member>
        <member name="M:Sandbox.Particle.DisableListenersForComponent(Sandbox.Component)">
            <summary>
            Remove all listeners with this component set as the source. This is most commonly called when
            the passed component is destroyed or disabled, to remove any effects created.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleEffect">
            <summary>
            Defines and holds particles. This is the core of the particle system.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.PreWarm">
            <summary>
            How many seconds to pre-warm this effect by when creating
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.StartDelay">
            <summary>
            The particle can wait until it properly spawns.
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.SequenceId">
            <summary>
            Which sequence to use
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.SequenceTime">
            <summary>
            Allows control of the sequence time, which spans from 0 to 1 for one loop
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.SequenceSpeed">
            <summary>
            Increment the sequence time by this much
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnParticleDestroyed">
            <summary>
            Called any time a particle is destroyed
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnParticleCreated">
            <summary>
            Called any time a particle is created
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnPreStep">
            <summary>
            Called before the particles are stepped
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnPostStep">
            <summary>
            Called after the particles are stepped
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.OnStep">
            <summary>
            Called after the particles are stepped
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.ParticleBounds">
            <summary>
            The bounds of the current particles
            </summary>
        </member>
        <member name="P:Sandbox.ParticleEffect.MaxParticleSize">
            <summary>
            The biggest particle scale (x, y or z of scale)
            </summary>
        </member>
        <member name="M:Sandbox.ParticleEffect.Emit(Vector3,System.Single)">
            <summary>
            Emit a particle at the given position.
            </summary>
            <param name="position">The position in which to spawn the particle</param>
            <param name="delta">The time delta of the spawn. The first spawned particle is 0, the last spawned particle is 1. This is used to evaluate the spawn particles like lifetime and delay.</param>
            <returns>A particle, will never be null. It's up to you to obey max particles.</returns>
        </member>
        <member name="T:Sandbox.ParticleGameSystem">
            <summary>
            Ticks the physics in FrameStage.PhysicsStep
            </summary>
        </member>
        <member name="M:Sandbox.ParticleGameSystem.ProcessWork(Sandbox.ParticleEffect.ParticleWork)">
            <summary>
            We process the particles in chunks, in parallel. We don't do one particle at a time because 
            it'd spend more time doing all the admin of giving them to threads than it would actually take.
            </summary>
            <param name="work"></param>
        </member>
        <member name="T:Sandbox.ParticleRandomNumber">
            <summary>
            Create a bunch of random numbers that can be looked up by index. This lets
            particles look up a number by index, so they can have consistent random numbers
            in different parts of their update, without generating a bunch of them.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleRandomNumber.Count">
            <summary>
            Total number of available randoms
            </summary>
        </member>
        <member name="P:Sandbox.ParticleLightRenderer.Ratio">
            <summary>
            If 1, then every particle will get a light. If 0, no particles will get a light. If 0.5, half will get a particle.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleRenderer">
            <summary>
            Renders a set of particles. Should be attached to a <see cref="P:Sandbox.ParticleRenderer.ParticleEffect"/>.
            </summary>
        </member>
        <member name="T:Sandbox.ParticleSpriteRenderer">
            <summary>
            Renders particles as 2D sprites
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Opaque">
            <summary>
            If opaque there's no need to sort particles, because they will write to
            the depth buffer during the opaque pass.
            </summary>
        </member>
        <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.LookAtCamera">
            <summary>
            Look directly at the camera, apply roll
            </summary>
        </member>
        <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.RotateToCamera">
            <summary>
            Look at the camera but don't pitch up and down, up is always up, can roll
            </summary>
        </member>
        <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.Particle">
            <summary>
            Use rotation provided by the particle, pitch yaw and roll
            </summary>
        </member>
        <member name="P:Sandbox.ParticleSpriteRenderer.Alignment">
            <summary>
            Should th
            </summary>
        </member>
        <member name="M:Sandbox.ParticleSpriteSceneObject.RenderSceneObject">
            <summary>
            WARNING - this is running in a thread!
            </summary>
        </member>
        <member name="T:Sandbox.AmbientOcclusion">
            <summary>
            Adds an approximation of ambient occlusion using Screen Space Ambient Occlusion (SSAO).
            It darkens areas where ambient light is generally occluded from such as corners, crevices
            and surfaces that are close to each other.
            You can look at the AO value directly by using the "r_ssao_debug" convar.
            </summary>
        </member>
        <member name="P:Sandbox.AmbientOcclusion.Intensity">
            <summary>
            The intensity of the darkening effect. Has no impact on performance.
            </summary>
        </member>
        <member name="F:Sandbox.AmbientOcclusion.SampleQuality.Low">
            <summary>
            9 samples
            </summary>
        </member>
        <member name="F:Sandbox.AmbientOcclusion.SampleQuality.Medium">
            <summary>
            16 samples
            </summary>
        </member>
        <member name="F:Sandbox.AmbientOcclusion.SampleQuality.High">
            <summary>
            25 samples
            </summary>
        </member>
        <member name="P:Sandbox.AmbientOcclusion.Quality">
            <summary>
            Number of pixel samples taken to determine occlusion
            </summary>
        </member>
        <member name="P:Sandbox.AmbientOcclusion.Radius">
            <summary>
            Maximum distance of samples from pixel when determining its occlusion
            </summary>
        </member>
        <member name="M:Sandbox.AmbientOcclusion.RenderEffect(Sandbox.SceneCamera)">
            <summary>
            Render the effect onto given scene camera.
            </summary>
        </member>
        <member name="P:Sandbox.ChromaticAberration.Scale">
            <summary>
            Enable chromatic aberration
            </summary>
        </member>
        <member name="P:Sandbox.ChromaticAberration.Offset">
            <summary>
            The pixel offset for each color channel. These values should
            be very small as it's in UV space. (0.004 for example)
            X = Red
            Y = Green
            Z = Blue
            </summary>
        </member>
        <member name="M:Sandbox.ColorGrading.ProcessCurve(Sandbox.Curve,System.String)">
            <summary>
            Represent our curves into shaders
            </summary>
        </member>
        <member name="M:Sandbox.ColorGrading.RenderEffect(Sandbox.SceneCamera)">
            <summary>
            Render the effect onto given scene camera.
            </summary>
        </member>
        <member name="P:Sandbox.DepthOfField.FocalDistance">
            <summary>
            How far away from the camera to focus
            </summary>
        </member>
        <member name="P:Sandbox.DepthOfField.BlurSize">
            <summary>
            How blurry to make stuff that isn't in focus
            </summary>
        </member>
        <member name="P:Sandbox.DepthOfField.FrontBlur">
            <summary>
            Should we blur what's ahead the focal point towards us?
            </summary>
        </member>
        <member name="P:Sandbox.DepthOfField.BackBlur">
            <summary>
            Should we blur what's behind the focal point?
            </summary>
        </member>
        <member name="M:Sandbox.DepthOfField.RenderEffect(Sandbox.SceneCamera)">
            <summary>
            Render the effect onto given scene camera.
            </summary>
        </member>
        <member name="T:Sandbox.Highlight">
            <summary>
            This should be added to a camera that you want to outline stuff
            </summary>
        </member>
        <member name="T:Sandbox.HighlightOutline">
            <summary>
            This component should be added to stuff you want to be outlined. You will also need to 
            add the Highlight component to the camera you want to render the outlines.
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.Material">
            <summary>
            If defined, the glow will use this material rather than a generated one.
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.Color">
            <summary>
            The colour of the glow outline
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.ObscuredColor">
            <summary>
            The colour of the glow when the mesh is obscured by something closer.
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.InsideColor">
            <summary>
            Color of the inside of the glow
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.InsideObscuredColor">
            <summary>
            Color of the inside of the glow when the mesh is obscured by something closer.
            </summary>
        </member>
        <member name="P:Sandbox.HighlightOutline.Width">
            <summary>
            The width of the line of the glow
            </summary>
        </member>
        <member name="T:Sandbox.PostProcess">
            <summary>
            Adds an effect to the camera
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Color">
            <summary>
            The color of the vignette or the "border"
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Intensity">
            <summary>
            How strong the vignette is. This is a value between 0 -> 1
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Smoothness">
            <summary>
            How much fall off or how blurry the vignette is
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Roundness">
            <summary>
            How circular or round the vignette is
            </summary>
        </member>
        <member name="P:Sandbox.Vignette.Center">
            <summary>
            The center of the vignette in relation to UV space. This means
            a value of {0.5, 0.5} is the center of the screen
            </summary>
        </member>
        <member name="T:Sandbox.DecalRenderer">
            <summary>
            Component that creates a projected decal relative to its GameObject.
            </summary>
        </member>
        <member name="P:Sandbox.DecalRenderer.Material">
            <summary>
            The material to use for this decal
            </summary>
        </member>
        <member name="P:Sandbox.DecalRenderer.Size">
            <summary>
            The size of the decal. x being width, y being the height, z being the projection distance
            </summary>
        </member>
        <member name="P:Sandbox.DecalRenderer.TintColor">
            <summary>
            Tint the decal
            </summary>
        </member>
        <member name="P:Sandbox.DecalRenderer.TriPlanar">
            <summary>
            Triplanar - projects in multiple directions
            </summary>
        </member>
        <member name="P:Sandbox.DecalRenderer.Mod2XBlending">
            <summary>
            Triplanar - projects in multiple directions
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.SetBodyGroup(System.String,System.Int32)">
            <summary>
            Set body group value by name
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.SetBodyGroup(System.Int32,System.Int32)">
            <summary>
            Set body group value by index
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.GetBodyGroup(System.String)">
            <summary>
            Get body group value by name
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.GetBodyGroup(System.Int32)">
            <summary>
            Get body group value by index
            </summary>
        </member>
        <member name="M:Sandbox.ModelRenderer.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our scene object tags
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.GetBoneObject(System.Int32)">
            <summary>
            Get the GameObject of a specific bone.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.GetBoneObject(System.String)">
            <summary>
            Find a bone's GameObject by bone name. 
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.GetBoneObject(Sandbox.BoneCollection.Bone)">
            <inheritdoc cref="M:Sandbox.SkinnedModelRenderer.GetBoneObject(System.Int32)"/>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.UseAnimGraph">
            <summary>
            Usually used for turning off animation on ragdolls.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.ReadBonesFromGameObjects">
            <summary>
            For Procedural Bones, copy the current value to the animation bone
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.UpdateGameObjectsFromBones">
            <summary>
            For non procedural bones, copy the "parent space" bone from to the GameObject transform. Will
            return true if any transforms have changed.
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.OnFootstepEvent">
            <summary>
            Called when a footstep event happens
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.OnGenericEvent">
            <summary>
            Called when a generic animation event happens
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.OnSoundEvent">
            <summary>
            Called when a sound event happens
            </summary>
        </member>
        <member name="P:Sandbox.SkinnedModelRenderer.OnAnimTagEvent">
            <summary>
            Called when an anim tag event happens
            </summary>
        </member>
        <member name="F:Sandbox.SkinnedModelRenderer.parameters">
            <summary>
            If something sets parameters before the model is spawned, then we store them
            and apply them when it does spawn. This isn't ideal, but it is what it is.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.ClearParameters">
            <summary>
            Remove any stored parameters
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.SetLookDirection(System.String,Vector3)">
            <summary>
            Converts value to vector local to this entity's eyepos and passes it to SetAnimVector
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.SetLookDirection(System.String,Vector3,System.Single)">
            <summary>
            Converts value to vector local to this entity's eyepos and passes it to SetAnimVector. 
            This also sets {name}_weight to the weight value.
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.SetIk(System.String,Transform)">
            <summary>
            Sets an IK parameter. This sets 3 variables that should be set in the animgraph:
            1. ik.{name}.enabled
            2. ik.{name}.position
            3. ik.{name}.rotation
            </summary>
        </member>
        <member name="M:Sandbox.SkinnedModelRenderer.ClearIk(System.String)">
            <summary>
            This sets ik.{name}.enabled to false.
            </summary>
        </member>
        <member name="M:Sandbox.SkyBox2D.OnTagsChanged">
            <summary>
            Tags have been updated
            </summary>
        </member>
        <member name="M:Sandbox.SpriteRenderer.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our scene object tags
            </summary>
        </member>
        <member name="M:Sandbox.TextRenderer.OnTagsChanged">
            <summary>
            Tags have been updated - lets update our scene object tags
            </summary>
        </member>
        <member name="T:Sandbox.TrailRenderer">
            <summary>
            Renders a trail behind the object, when it moves.
            </summary>
        </member>
        <member name="T:Sandbox.VolumetricFogController">
            <summary>
            Internal component for storing the baked fog texture
            We don't need to expose the volumetric fog controller like we did previously with entities,
            But we need to be fetch the baked fog texture from the map file
            </summary>
        </member>
        <member name="P:Sandbox.VolumetricFogVolume.GlobalScale">
            <summary>
            The global scale of the fog volume from the legacy VolumetricFogController entity
            Used for Hammer maps that used the value to scale the fog volume
            </summary>
        </member>
        <member name="T:Sandbox.Terrain">
            <summary>
            Terrain renders heightmap based terrain.
            </summary>
        </member>
        <member name="P:Sandbox.Terrain.Storage">
            <summary>
            Storage contains pretty much everything: heightmap, controlmaps, materials, grass, etc etc
            </summary>
        </member>
        <member name="P:Sandbox.Terrain.TerrainSize">
            <summary>
            Uniform world size of the width and length of the terrain.
            </summary>
        </member>
        <member name="P:Sandbox.Terrain.TerrainHeight">
            <summary>
            World size of the maximum height of the terrain.
            </summary>
        </member>
        <member name="M:Sandbox.Terrain.OnTagsChanged">
            <summary>
            Tags have been updated
            </summary>
        </member>
        <member name="M:Sandbox.Terrain.RayIntersects(Ray,System.Single,Vector3@)">
            <summary>
            Given a world ray, finds out the LOCAL position it intersects with this terrain.
            </summary>
        </member>
        <member name="P:Sandbox.Terrain.MaterialOverride">
            <summary>
            Override the terrain rendering with your own material shader.
            This needs to be explicitly set up to work with the Terrain Shader API.
            </summary>
        </member>
        <member name="M:Sandbox.TerrainClipmap.GenerateMesh_DiamondSquare(System.Int32,System.Int32,Sandbox.Material)">
            <summary>
            Inefficient implementation of diamond square, it's not merging verticies.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Sandbox.TerrainLayer">
            <summary>
            Describes a terrain layer and what textures it uses.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.HasClass(System.String)">
            <inheritdoc cref="M:Sandbox.UI.Panel.HasClass(System.String)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.RemoveClass(System.String)">
            <inheritdoc cref="M:Sandbox.UI.Panel.RemoveClass(System.String)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.AddClass(System.String)">
            <inheritdoc cref="M:Sandbox.UI.Panel.AddClass(System.String)"/>
        </member>
        <member name="M:Sandbox.PanelComponent.BindClass(System.String,System.Func{System.Boolean})">
            <inheritdoc cref="M:Sandbox.UI.Panel.BindClass(System.String,System.Func{System.Boolean})"/>
        </member>
        <member name="M:Sandbox.PanelComponent.SetClass(System.String,System.Boolean)">
            <inheritdoc cref="M:Sandbox.UI.Panel.SetClass(System.String,System.Boolean)"/>
        </member>
        <member name="P:Sandbox.PanelComponent.Panel">
            <summary>
            The panel. Can be null if the panel doesn't exist yet.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.BuildRenderTree(Sandbox.Razor.RenderTreeBuilder)">
            <summary>
            Gets overridden by .razor file
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.GetRenderTreeChecksum">
            <summary>
            Gets overridden by .razor file
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.OnTreeFirstBuilt">
            <summary>
            Called when the razor ui has been built.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.OnTreeBuilt">
            <summary>
            Called after the tree has been built. This can happen any time the contents change.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.BuildHash">
            <summary>
            When this has changes, we will re-render this panel. This is usually
            implemented as a HashCode.Combine containing stuff that causes the
            panel's content to change.
            </summary>
        </member>
        <member name="M:Sandbox.PanelComponent.StateHasChanged">
            <summary>
            Should be called when you want the component to be re-rendered.
            </summary>
        </member>
        <member name="T:Sandbox.CustomBuildPanel">
            <summary>
            A panel where we control the tree build.
            </summary>
        </member>
        <member name="T:Sandbox.WorldInput">
            <summary>
            A router for world input, the best place to put this is on your player's camera.
            </summary>
        </member>
        <member name="P:Sandbox.WorldInput.LeftMouseAction">
            <summary>
            Which action is our left clicking button?
            </summary>
        </member>
        <member name="P:Sandbox.WorldInput.RightMouseAction">
            <summary>
            Which action is our right clicking button?
            </summary>
        </member>
        <member name="P:Sandbox.WorldPanel.InteractionRange">
            <summary>
            How far can we interact with this world panel?
            </summary>
        </member>
        <member name="M:Sandbox.WorldPanel.OnTagsChanged">
            <summary>
            Tags have been updated
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRAnchor">
            <summary>
            Updates the the VR anchor based on a GameObject's transform.
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRAnchor.UpdateAnchor">
            <summary>
            Update the VR anchor based on the GameObject's transform
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRHand">
            <summary>
            Updates the parameters on an <see cref="T:Sandbox.SkinnedModelRenderer"/> on this GameObject based on the skeletal data from SteamVR.
            Useful for quick hand posing based on controller input.
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRHand.SkinnedModelComponent">
            <summary>
            Which <see cref="T:Sandbox.SkinnedModelRenderer"/> to use when updating this component
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRHand.HandSources">
            <summary>
            Represents a controller to use when fetching skeletal data (finger curl/splay values)
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRHand.HandSources.Left">
            <summary>
            The left controller
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRHand.HandSources.Right">
            <summary>
            The right controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRHand.HandSource">
            <summary>
            Which hand should we use to update the parameters?
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRModelRenderer">
            <summary>
            Renders a device-specific model for a VR device
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRModelRenderer.ModelSources">
            <summary>
            Represents a controller to use when fetching the model (which device)
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRModelRenderer.ModelSources.LeftHand">
            <summary>
            The left controller
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRModelRenderer.ModelSources.RightHand">
            <summary>
            The right controller
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRModelRenderer.ModelSource">
            <summary>
            Which device should we use to fetch the model?
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRModelRenderer.ModelRenderer">
            <summary>
            Which model renderer should we use as the target?
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRTrackedObject">
            <summary>
            Updates this GameObject's transform based on a given tracked object (e.g. left controller, HMD).
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRTrackedObject.PoseSources">
            <summary>
            Represents tracked devices to use when updating
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.PoseSources.Head">
            <summary>
            Retrieve data from the head-mounted display
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.PoseSources.LeftHand">
            <summary>
            Retrieve data from the left controller
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.PoseSources.RightHand">
            <summary>
            Retrieve data from the right controller
            </summary>
        </member>
        <member name="T:Sandbox.VR.VRTrackedObject.TrackingTypes">
            <summary>
            Represents transform values to update
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.None">
            <summary>
            Don't update the position or the rotation
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.Rotation">
            <summary>
            Update the rotation only
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.Position">
            <summary>
            Update the rotation only
            </summary>
        </member>
        <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.All">
            <summary>
            Update both the position and rotation
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRTrackedObject.PoseSource">
            <summary>
            Which tracked object should we use to update the transform?
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRTrackedObject.TrackingType">
            <summary>
            Which parts of the transform should be updated? (eg. rotation, position)
            </summary>
        </member>
        <member name="P:Sandbox.VR.VRTrackedObject.UseRelativeTransform">
            <summary>
            If this is checked, then the transform used will be relative to the VR anchor (rather than an absolute world position).
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRTrackedObject.GetTransform">
            <summary>
            Get the appropriate VR transform for the specified <see cref="P:Sandbox.VR.VRTrackedObject.PoseSource"/>
            </summary>
        </member>
        <member name="M:Sandbox.VR.VRTrackedObject.UpdatePose">
            <summary>
            Set the GameObject's transform based on the <see cref="P:Sandbox.VR.VRTrackedObject.PoseSource"/> and <see cref="P:Sandbox.VR.VRTrackedObject.TrackingType"/>
            </summary>
        </member>
        <member name="T:Sandbox.VR.VROverlayPanel">
            <summary>
            <para>A <see cref="T:Sandbox.VR.VROverlay"/> that draws and handles input of a <see cref="T:Sandbox.UI.RootPanel"/>.</para>
            
            <para>VR overlays draw over the top of the 3D scene, they will not be affected by lighting,
            post processing effects or anything else in the world.<br />
            This makes them ideal for HUDs or menus, or anything else that should be local to the
            HMD or tracked devices.</para>
            
            <para>If you need something in the world, consider using WorldPanel
            and <see cref="T:Sandbox.UI.WorldInput"/> instead.</para>
            </summary>
        </member>
        <member name="P:Sandbox.VR.VROverlayPanel.RootPanel">
            <summary>
            The <see cref="P:Sandbox.VR.VROverlayPanel.RootPanel"/> to render to the VR overlay
            </summary>
        </member>
        <member name="M:Sandbox.VR.VROverlayPanel.#ctor(Sandbox.UI.RootPanel)">
            <summary>
            Create a VR overlay panel using a given <see cref="P:Sandbox.VR.VROverlayPanel.RootPanel"/>.
            </summary>
            <param name="panel">The panel to render to the VR overlay</param>
        </member>
        <member name="T:Sandbox.CollisionSoundSystem">
            <summary>
            This system exists to collect pending collision sounds and filter them into a unique set, to avoid
            unnesssary sounds playing, when they're going to be making the same sound anyway.
            </summary>
        </member>
        <member name="M:Sandbox.CollisionSoundSystem.RegisterCollision(Sandbox.Collision@)">
            <summary>
            Register this physics collision with the sound system
            </summary>
        </member>
        <member name="M:Sandbox.CollisionSoundSystem.AddShapeCollision(Sandbox.PhysicsShape,Sandbox.Surface,Vector3@,System.Single)">
            <summary>
            Add a collision sound for this shape
            </summary>
        </member>
        <member name="M:Sandbox.CollisionSoundSystem.AddShapeCollision(Sandbox.PhysicsShape,Sandbox.Surface,Sandbox.PhysicsContact@)">
            <summary>
            Add a collision sound for this shape
            </summary>
        </member>
        <member name="M:Sandbox.CollisionSoundSystem.ProcessQueue">
            <summary>
            Create the pending sounds
            </summary>
        </member>
        <member name="T:Sandbox.HitboxSystem">
            <summary>
            Ticks the physics in FrameStage.PhysicsStep
            </summary>
        </member>
        <member name="T:Sandbox.InterpolationSystem">
            <summary>
            Updates interpolation for any <see cref="T:Sandbox.GameTransform"/> that needs it.
            </summary>
        </member>
        <member name="M:Sandbox.InterpolationSystem.AddGameObject(Sandbox.GameObject)">
            <summary>
            Add a <see cref="T:Sandbox.GameObject"/> to the interpolation list.
            </summary>
        </member>
        <member name="M:Sandbox.InterpolationSystem.RemoveGameObject(Sandbox.GameObject)">
            <summary>
            Remove a <see cref="T:Sandbox.GameObject"/> from the interpolation list.
            </summary>
        </member>
        <member name="T:Sandbox.NetworkDebugSystem">
            <summary>
            Draws networking diagnostic data
            </summary>
        </member>
        <member name="T:Sandbox.ScenePhysicsSystem">
            <summary>
            Ticks the physics in FrameStage.PhysicsStep
            </summary>
        </member>
        <member name="T:Sandbox.SceneSoundscapeSystem">
            <summary>
            Implements logic for the SoundScape system
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectSystem">
            <summary>
            Allows creation of a system that always exists in every scene, 
            is hooked into the scene's lifecycle, 
            and is disposed when the scene is disposed.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectSystem.Listen(Sandbox.GameObjectSystem.Stage,System.Int32,System.Action,System.String)">
            <summary>
            Listen to a frame stage. Order is used to determine the order in which listeners are called, the default action always happens at 0, so if you
            want it to happen before you should go to -1, if you want it to happen after go to 1 etc.
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectSystem.Stage">
            <summary>
            A list of stages in the scene tick in which we can hook
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.StartUpdate">
            <summary>
            At the very start of the scene update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.UpdateBones">
            <summary>
            Bones are worked out
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.PhysicsStep">
            <summary>
            Physics step, called in fixed update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.Interpolation">
            <summary>
            When transforms are interpolated
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.FinishUpdate">
            <summary>
            At the very end of the scene update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.StartFixedUpdate">
            <summary>
            Called at the start of fixed update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.FinishFixedUpdate">
            <summary>
            Called at the end of fixed update
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectSystem.Stage.SceneLoaded">
            <summary>
            Called after a scene has been loaded
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectSystem.ITraceProvider">
            <summary>
            When implementing an ITraceProvider, the most importannt thing to keep in mind 
            is that the call to DoTrace should be thread safe. This might be called from 
            multiple threads at once, so you better watch out.
            </summary>
        </member>
        <member name="T:Sandbox.TimedCallbackList">
            <summary>
            Keeps a list of callbacks
            The intention of this is that in the future we'll have a nice window that will
            show the relative performance of each callback, and allow you to disable them to debug.
            </summary>
        </member>
        <member name="T:Sandbox.CallbackBatch">
            <summary>
            We want to execute callbacks in a predictable order. This happens
            naturally when spawning one GameObject, but when spawning a scene, or a 
            prefab, we want to hold the calls to things like OnEnable and call them all
            after OnStart or whatever has been called on all the objects in the batch.
            </summary>
        </member>
        <member name="M:Sandbox.CallbackBatch.Batch">
            <summary>
            Add callbacks to the previous batch (or create one). This allows for one single batch, the
            most outer one, and won't create a new batch for inner ones. This is used when doing things like
            deserializing a map, so all the OnEnable etc are executed at the same time, and in the right order.
            </summary>
        </member>
        <member name="M:Sandbox.CallbackBatch.Isolated">
            <summary>
            Collect callbacks in this scope and execute them immediately at the end of this batch. This is used
            for things like gameobject Clones, where we're going to want access to the object straight after 
            creating it.. and if we're inside a Batch then OnEnable etc won't have been called, so it will be
            confusing to everyone.
            </summary>
        </member>
        <member name="T:Sandbox.CommonCallback">
            <summary>
            A list of component methods that are deferred and batched into groups, and exected in group order.
            This is used to ensure that components are initialized in a predictable order.
            The order of this enum is critical.
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Deserialize">
            <summary>
            The component is deserializing.
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Validate">
            <summary>
            The component has been deserialized, or edited in the editor
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Loading">
            <summary>
            An opportunity for the component to load any data they need to load
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Awake">
            <summary>
            The component is awake. Called only once, on first enable.
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Enable">
            <summary>
            Component has been enabled
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Dirty">
            <summary>
            The component has become dirty, usually due to a property changing
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Disable">
            <summary>
            Component has been disabled
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Destroy">
            <summary>
            Component has been destroyed
            </summary>
        </member>
        <member name="F:Sandbox.CommonCallback.Term">
            <summary>
            GameObject actually deleted
            </summary>
        </member>
        <member name="T:Sandbox.FindMode">
            <summary>
            Flags to search for Components.
            I've named this something generic because I think we can re-use it to search for GameObjects too.
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.Enabled">
            <summary>
            Components that are enabled
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.Disabled">
            <summary>
            Components that are disabled
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InSelf">
            <summary>
            Components in this object
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InParent">
            <summary>
            Components in our parent
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InAncestors">
            <summary>
            Components in all ancestors (parent, their parent, their parent, etc)
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InChildren">
            <summary>
            Components in our children
            </summary>
        </member>
        <member name="F:Sandbox.FindMode.InDescendants">
            <summary>
            Components in all decendants (our children, their children, their children etc)
            </summary>
        </member>
        <member name="F:Sandbox.ComponentList._list">
            <summary>
            This is the hard list of components.
            This isn't a HashSet because we need the order to stay.
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetAll">
            <summary>
            Get all components, including disabled ones
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Create(Sandbox.TypeDescription,System.Boolean)">
            <summary>
            Add a component of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Create``1(System.Boolean)">
            <summary>
            Add a component of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Get``1(Sandbox.FindMode)">
            <summary>
            Get a component of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Get(System.Type,Sandbox.FindMode)">
            <summary>
            Get a component of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetAll(System.Type,Sandbox.FindMode)">
            <summary>
            Get all components of this type
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetAll(Sandbox.FindMode)">
            <summary>
            Get all components
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetAll``1(Sandbox.FindMode)">
            <summary>
            Get a list of components on this game object, optionally recurse when deep is true
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.TryGet``1(``0@,Sandbox.FindMode)">
            <summary>
            Try to get this component
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.FirstOrDefault(System.Func{Sandbox.Component,System.Boolean})">
            <summary>
            Allows linq style queries
            </summary>
        </member>
        <member name="P:Sandbox.ComponentList.Count">
            <summary>
            Amount of components - including disabled
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Move(Sandbox.Component,System.Int32)">
            <summary>
            Move the position of the component in the list by delta (-1 means up one, 1 means down one)
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Get``1(System.Boolean)">
            <summary>
            Find component on this gameobject
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetOrCreate``1(Sandbox.FindMode)">
            <summary>
            Find this component, if it doesn't exist - create it.
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInAncestorsOrSelf``1(System.Boolean)">
            <summary>
            Find component on this gameobject's ancestors or on self
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInAncestors``1(System.Boolean)">
            <summary>
            Find component on this gameobject's ancestors
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInDescendantsOrSelf``1(System.Boolean)">
            <summary>
            Find component on this gameobject's decendants or on self
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInDescendants``1(System.Boolean)">
            <summary>
            Find component on this gameobject's decendants
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInChildrenOrSelf``1(System.Boolean)">
            <summary>
            Find component on this gameobject's immediate children or on self
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInChildren``1(System.Boolean)">
            <summary>
            Find component on this gameobject's immediate children
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInParentOrSelf``1(System.Boolean)">
            <summary>
            Find component on this gameobject's parent or on self
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.GetInParent``1(System.Boolean)">
            <summary>
            Find component on this gameobject's parent
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.Get(System.Guid)">
            <summary>
            Find component on this gameobject with the specified id
            </summary>
        </member>
        <member name="M:Sandbox.ComponentList.AddMissing(Sandbox.MissingComponent)">
            <summary>
            Adds a special component that will keep information about a missing component.
            This component just holds the raw json of this component.
            </summary>
        </member>
        <member name="T:Sandbox.IComponentLister">
            <summary>
            Interface for types that reference a <see cref="T:Sandbox.ComponentList"/>, to provide
            convenience method for accessing that list.
            </summary>
        </member>
        <member name="T:Sandbox.GameObject">
            <summary>
            An object in the scene. Functionality is added using Components. A GameObject has a transform, which explains its position,
            rotation and scale, relative to its parent. It also has a name, and can be enabled or disabled. When disabled, the GameObject
            is still in the scene, but the components don't tick and are all disabled.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Sandbox.CloneConfig@)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.InstantiatePrefab(Sandbox.PrefabFile,Sandbox.CloneConfig@)">
            <summary>
            Create from a PrefabFile. The public shouldn't be calling this, they should be encouraged to go through the GameObject route
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.CreateEmptyObject(Sandbox.CloneConfig@)">
            <summary>
            Create an empty object. This gets called if you Clone a GameObject and their json returns null for some reason.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(System.String,System.Nullable{Sandbox.CloneConfig})">
            <summary>
            Clone a prefab from path
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(System.String,Transform,Sandbox.GameObject,System.Boolean,System.String)">
            <summary>
            Clone a prefab from path
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Sandbox.PrefabFile,System.Nullable{Sandbox.CloneConfig})">
            <summary>
            Clone a prefab from path
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Sandbox.PrefabFile,Transform,Sandbox.GameObject,System.Boolean,System.String)">
            <summary>
            Clone a prefab from path
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Transform,Sandbox.GameObject,System.Boolean,System.String)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Vector3)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Vector3,Rotation)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Vector3,Rotation,Vector3)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clone(Sandbox.GameObject,Vector3,Rotation,Vector3)">
            <summary>
            Create a unique copy of the GameObject
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Scene">
            <summary>
            The scene that this GameObject is in.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Transform">
            <summary>
            Our position relative to our parent, or the scene if we don't have any parent.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Name">
            <summary>
            The GameObject's name is usually used for debugging, and for finding it in the scene.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Lerping">
            <summary>
            Should the <see cref="P:Sandbox.GameObject.Transform"/> of this object be interpolated?
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsRoot">
            <summary>
            Returns true of this is a root object. Root objects are parented to the scene.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Root">
            <summary>
            Return the root GameObject. The root is the object that is parented to the scene - which could very much be this object.
            </summary>
        </member>
        <member name="F:Sandbox.GameObject.enabledTokenSource">
            <summary>
            This token source is expired when leaving the game session, or when the GameObject is disabled/destroyed.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.EnabledToken">
            <summary>
            This token is cancelled when the GameObject ceases to exist, or is disabled
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Components">
            <summary>
            Access components on this GameObject
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Enabled">
            <summary>
            Is this gameobject enabled?
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.CreateTaskSource">
            <summary>
            Creates a new task source. Any Waits etc created by Task will be cancelled
            when the GameObject is disabled, or destroyed, or the game is exited.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.CancelTaskSource">
            <summary>
            Cancel this task source
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Active">
            <summary>
            Is this gameobject active. For it to be active, it needs to be enabled, all of its ancestors
            need to be enabled, and it needs to be in a scene.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.UpdateEnabledStatus">
            <summary>
            Should be called whenever we change anything that we suspect might
            cause the active status to change on us, or our components. Don't call
            this directly. Only call it via SceneUtility.ActivateGameObject( this );
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.IsDescendant(Sandbox.GameObject)">
            <summary>
            Returns true if the passed in object is a decendant of ours
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.IsAncestor(Sandbox.GameObject)">
            <summary>
            Returns true if the passed in object is an ancestor
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetBounds">
            <summary>
            This is slow, and somewhat innacurate. Don't call it every frame!
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetNextSibling(System.Boolean)">
            <summary>
            Get the GameObject after us,
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsValid">
            <summary>
            True if the GameObject is not destroyed
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Term">
            <summary>
            Actually destroy the object and its children. Turn off and destroy components.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.TermSilent">
            <summary>
            Destroy the object and its children and destroy any components without
            invoking any callbacks.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.TermFinal">
            <summary>
            The last thing ever called.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Destroy">
            <summary>
            Destroy this object. Will actually be destroyed at the start of the next frame.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.DestroyImmediate">
            <summary>
            Destroy this object immediately. Calling this might cause some problems if functions
            are expecting the object to still exist, so it's not always a good idea.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.RemoveChild(Sandbox.GameObject)">
            <summary>
            Remove all children
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Sandbox.GameObject.Clear">
            <summary>
            Destroy all components and child objects
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.ShouldSurviveSceneTransition">
            <summary>
            True if this GameObject should survive a scene load
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Clear(System.Boolean)">
            <summary>
            Destroy all components and child objects
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.ForceChangeId(System.Guid)">
            <summary>
            Should only be called by <see cref="M:Sandbox.GameObjectDirectory.Add(Sandbox.GameObject)"/>.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsProxy">
            <summary>
            True if this is a networked object and is owned by another client. This means that we're
            not controlling this object, so shouldn't try to move it or anything.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.IsNetworkRoot">
            <summary>
            If true then this object is the root of a networked object.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Networked">
            <summary>
            OBSOLETE: Use NetworkMode instead.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkMode">
            <summary>
            How should this object be networked to other clients? By default, a <see cref="T:Sandbox.GameObject"/> will be
            networked as part of the <see cref="P:Sandbox.GameObject.Scene"/> snapshot.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.OwnerTransfer">
            <summary>
            If this object is networked, who can control ownership of it?
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkOrphaned">
            <summary>
            Determines what happens when the owner disconnects.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkInterpolation">
            <summary>
            Whether or not our networked transform will be interpolated.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawn">
            <summary>
            Spawn on the network. If you have permission to spawn entities, this will spawn on
            everyone else's clients and you will be the owner.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawn(Sandbox.Connection)">
            <summary>
            Spawn on the network. If you have permission to spawn entities, this will spawn on
            everyone else's clients and the owner will be the connection provided.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawnRemote(Sandbox.ObjectCreateMsg)">
            <summary>
            Initialize this object from the network
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_RequestDropOwnership">
            <summary>
            Make a request from the host to stop being the network owner of this game object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_DropOwnership">
            <summary>
            Stop being the network owner of this game object, or clear ownership if you're the host.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_RequestTakeOwnership">
            <summary>
            Make a request from the host to become the network owner of this game object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_TakeOwnership">
            <summary>
            Become the network owner of this game object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_RequestAssignOwnership(System.Guid)">
            <summary>
            Make a request from the host to assign ownership of this game object to the specified connection <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.Msg_AssignOwnership(System.Guid)">
            <summary>
            Assign ownership of this game object to the specified connection <see cref="T:System.Guid"/>.
            </summary>
            <param name="guid"></param>
        </member>
        <member name="P:Sandbox.GameObject.NetworkRoot">
            <summary>
            The network root is the first networked GameObject above this.
            This gets set from the parent's NetworkSpawn and invalidated when the parent changes.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkRefresh(System.Text.Json.Nodes.JsonObject)">
            <summary>
            Update hierarchy from a network refresh.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkPrune(System.Collections.Generic.Dictionary{System.Guid,System.Text.Json.Nodes.JsonNode})">
            <summary>
            Prune children based on valid ids from a network refresh.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkSpawnRecursive(Sandbox.Connection)">
            <summary>
            Loop all of our children, and any with networking enabled, we should spawn them
            with the same creator + owner as this.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.Network">
            <summary>
            Access network information for this GameObject
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.Active">
            <summary>
            Is this object networked
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.IsOwner">
            <summary>
            Are we the owner of this network object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.OwnerId">
            <summary>
            The Id of the owner of this object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.IsCreator">
            <summary>
            Are we the creator of this network object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.CreatorId">
            <summary>
            The Id of the create of this object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.IsProxy">
            <summary>
            Is this object a network proxy. A network proxy is a network object that is not being simulated on the local pc.
            This means it's either owned by no-one and is being simulated by the host, or owned by another client.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.OwnerConnection">
            <summary>
            Try to get the connection that owns this object. This can and will return null
            if we don't have information for this connection.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer">
            <summary>
            Who can control ownership of this networked object?
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.NetworkOrphaned">
            <summary>
            Determines what happens when the owner disconnects.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.NetworkAccessor.Interpolation">
            <summary>
            Whether the networked object's transform is interpolated.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.EnableInterpolation">
            <summary>
            Enable interpolation for the networked object's transform.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.DisableInterpolation">
            <summary>
            Disable interpolation for the networked object's transform.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.ClearInterpolation">
            <summary>
            <inheritdoc cref="M:Sandbox.GameTransform.ClearInterpolation"/>
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.SetOrphanedMode(Sandbox.NetworkOrphaned)">
            <summary>
            Set what happens to this networked object when the owner disconnects.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.SetOwnerTransfer(Sandbox.OwnerTransfer)">
            <summary>
            Set who can control ownership of this networked object. Only the current owner can change this.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.Refresh">
            <summary>
            Send a complete refresh snapshot of this networked object to other clients. This is useful if you have
            made vast changes to components or children.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.TakeOwnership">
            <summary>
            Become the network owner of this object.
            <br/>
            <br/>
            Note: whether or not you can take ownership of this object depends on the
            <see cref="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer"/> of this networked object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.AssignOwnership(Sandbox.Connection)">
            <summary>
            Set the owner of this object to the specified <see cref="T:Sandbox.Connection"/>.
            <br/>
            <br/>
            Note: whether or not you can assign ownership of this object depends on the
            <see cref="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer"/> of this networked object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.AssignOwnership(System.Guid)">
            <summary>
            Assign ownership to the specific connection id. This should only be used internally
            when we want to force an ownership change, such as for a <see cref="P:Sandbox.GameObject.NetworkAccessor.NetworkOrphaned"/> action.
            </summary>
            <param name="connectionId"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.DropOwnership">
            <summary>
            Stop being the owner of this object. Will clear the owner so the object becomes
            controlled by the server, and owned by no-one.
            <br/>
            <br/>
            Note: whether or not you can drop ownership of this object depends on the
            <see cref="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer"/> of this networked object.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.Spawn">
            <summary>
            <inheritdoc cref="M:Sandbox.GameObject.NetworkSpawn"/>
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.NetworkAccessor.Spawn(Sandbox.Connection)">
            <summary>
            <inheritdoc cref="M:Sandbox.GameObject.NetworkSpawn(Sandbox.Connection)"/>
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.PrefabSource">
            <summary>
            The filename of the prefab
            </summary>
        </member>
        <member name="F:Sandbox.GameObject._guidToInstance">
            <summary>
            Translate from prefab guid to this object's guid
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.BreakFromPrefab">
            <summary>
            We are cloned from a prefab. Stop that.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.InitPrefabTable(System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
            <summary>
            Create a two way lookup allowing from prefab to instance, instance to prefab
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.PrefabToInstance(System.Guid@)">
            <summary>
            Translate a Prefab guid to the instanced version
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.InstanceToPrefab(System.Guid@)">
            <summary>
            Translate an instanced Prefab guid to the original prefab version
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.FindPrefabObject(System.Guid)">
            <summary>
            Given a prefab object guid, return the instance object on this current object. This
            could be a GameObject or a Component.
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.SceneForNetwork">
            <summary>
            If we're serializing for network, we won't include any networked objects
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.Cloning">
            <summary>
            We're cloning this object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.SingleNetworkObject">
            <summary>
            We're going to send a single network object
            </summary>
        </member>
        <member name="P:Sandbox.GameObject.SerializeOptions.UpdatingFromPrefab">
            <summary>
            We're updating from a changed prefab
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.GetFlattenedHierarchy(System.Text.Json.Nodes.JsonNode,System.Collections.Generic.Dictionary{System.Guid,System.Text.Json.Nodes.JsonNode})">
            <summary>
            Get a flattened hierarchy of all <see cref="T:Sandbox.GameObject"/> nodes from the providied JSON node as a dictionary
            with the key being the <see cref="P:Sandbox.GameObject.Id"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameObject.OnTagsUpdatedInternal">
            <summary>
            Called by GameTags when the tags change
            </summary>
        </member>
        <member name="T:Sandbox.CloneConfig">
            <summary>
            The low level input of a GameObject.Clone
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Hidden">
            <summary>
            Hide this object in heirachy/inspector
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.NotSaved">
            <summary>
            Don't save this object to disk, or when duplicating
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Bone">
            <summary>
            Auto created - it's a bone, driven by animation
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Attachment">
            <summary>
            Auto created - it's an attachment
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Error">
            <summary>
            There's something wrong with this
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Loading">
            <summary>
            Loading something
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Deserializing">
            <summary>
            Is in the process of deserializing
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.DontDestroyOnLoad">
            <summary>
            When loading a new scene, keep this gameobject active
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.NotNetworked">
            <summary>
            Keep local - don't network this object as part of the scene snapshot
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.Refreshing">
            <summary>
            In the process of refreshing from the network
            </summary>
        </member>
        <member name="F:Sandbox.GameObjectFlags.ProceduralBone">
            <summary>
            Stops animation stopmping the bone, will use the bone's local position
            </summary>
        </member>
        <member name="T:Sandbox.GameTags">
            <summary>
            Entity Tags are strings you can set and check for on any entity. Internally
            these strings are tokenized and networked so they're also available clientside.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.TryGetAll">
            <summary>
            Returns all the tags this object has.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.TryGetAll(System.Boolean)">
            <summary>
            Returns all the tags this object has.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Has(System.String)">
            <summary>
            Returns true if this object (or its parents) has given tag.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Has(System.String,System.Boolean)">
            <summary>
            Returns true if this object has given tag.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.HasAny(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Returns true if this object has one or more tags from given tag list.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.HasAny(System.String[])">
            <summary>
            Returns true if this object has one or more tags from given tag list.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Add(System.String)">
            <summary>
            Try to add the tag to this object.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Add(System.String[])">
            <summary>
            Adds multiple tags. Calls <see cref="M:Sandbox.GameTags.Add(System.String)">EntityTags.Add</see> for each tag.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.Remove(System.String)">
            <summary>
            Try to remove the tag from this entity.
            </summary>
        </member>
        <member name="M:Sandbox.GameTags.RemoveAll">
            <summary>
            Remove all tags
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.FixedUpdateInterpolation">
            <summary>
            Automatically interpolate the transform over multiple frames when changed within the context
            of a fixed update. This results in a smoother appearance for a moving <see cref="P:Sandbox.GameTransform.GameObject"/>.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.InterpolatedLocal">
            <summary>
            The current interpolated local transform.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.Local">
            <summary>
            The current local transform.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.TargetLocal">
            <summary>
            The desired local transform. If we are interpolating we'll use the last value in the interpolation buffer.
            This is useful for networking because we always want to send the "real" transform.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.TransformChanged(System.Boolean)">
            <summary>
            Our transform has changed, which means our children transforms changed too
            tell them all.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.HasAuthority">
            <summary>
            Do we have permission to change this transform?
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.SetLocalTransformFast(Transform@)">
            <summary>
            Sets the local transform without firing a bunch of "transform changed" callbacks.
            The assumption is that you're changing a bunch of child transforms, and will then call
            transform changed on the root, which will then invoke all the callbacks just once.
            This is what the animation system does!
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.InterpolatedWorld">
            <summary>
            The interpolated world transform.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.World">
            <summary>
            The current world transform.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.Position">
            <summary>
            The position in world coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.Rotation">
            <summary>
            The rotation in world coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.Scale">
            <summary>
            The scale in world coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.LocalPosition">
            <summary>
            Position in local coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.LocalRotation">
            <summary>
            Rotation in local coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.GameTransform.LocalScale">
            <summary>
            Scale in local coordinates.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.LerpTo(Transform@,System.Single)">
            <summary>
            Performs linear interpolation between this and the given transform.
            </summary>
            <param name="target">The destination transform.</param>
            <param name="frac">Fraction, where 0 would return this, 0.5 would return a point between this and given transform, and 1 would return the given transform.</param>
        </member>
        <member name="M:Sandbox.GameTransform.ClearInterpolation">
            <summary>
            Clear any interpolation and force us to reach our final destination immediately. If we own this object
            we'll tell other clients to clear interpolation too when they receive the next transform update from us.
            </summary>
        </member>
        <member name="M:Sandbox.GameTransform.DisableInterpolation">
            <summary>
            Temporarily disable Fixed Update Interpolation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.GameTransform.DisableProxy">
            <summary>
            Disable the proxy temporarily
            </summary>
        </member>
        <member name="T:Sandbox.TransformProxyComponent">
            <summary>
            Help to implement a component that completely overrides the transform. This is useful for scenarios
            where you will want to keep the local transform of a GameObject, but want to offset based on that 
            for some reason.
            Having multiple of these on one GameObject is not supported, and will result in weirdness.
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.GetLocalTransform">
            <summary>
            Override to provide the local transform
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.SetLocalTransform(Transform@)">
            <summary>
            Called when the local transform is being set
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.GetWorldTransform">
            <summary>
            Override to provide the world transform. The default implementation will calculate it using GetLocalTransform() based on the parent.
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.SetWorldTransform(Transform)">
            <summary>
            Called when the world transform is being set
            </summary>
        </member>
        <member name="M:Sandbox.TransformProxyComponent.MarkTransformChanged">
            <summary>
            Tell our other components, and our children that our transform has changed. This will
            update things like Renderers to update their render positions.
            </summary>
        </member>
        <member name="T:Sandbox.NetDictionary`2">
            <summary>
            A networkable dictionary for use with the <see cref="T:Sandbox.SyncAttribute"/> and <see cref="T:Sandbox.HostSyncAttribute"/>. Only changes will be
            networked instead of sending the whole dictionary every time, so it's more efficient.
            <br/>
            <para>
            <b>Example usage:</b>
            <code>
            public class MyComponent : Component
            {
            	[Sync] public NetDictionary&lt;string,bool&gt; MyBoolTable { get; set; } = new();
            	<br/>
            	public void SetBoolState( string key, bool state )
            	{
            		if ( IsProxy ) return;
            		MyBoolTable[key] = state;
            	}
            }
            </code>
            </para>
            </summary>
        </member>
        <member name="T:Sandbox.NetDictionary`2.Change">
            <summary>
            Represents a change in the dictionary.
            </summary>
        </member>
        <member name="P:Sandbox.NetDictionary`2.Values">
            <summary>
            <inheritdoc cref="P:System.Collections.ObjectModel.ObservableDictionary`2.Values"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IDictionary.Contains(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IDictionary.Remove(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Add(`0,`1)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Add(`0,`1)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Clear">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Clear"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.ContainsKey(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.ContainsKey(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetDictionary`2.Keys">
            <summary>
            <inheritdoc cref="P:System.Collections.ObjectModel.ObservableDictionary`2.Keys"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Remove(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Remove(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.TryGetValue(`0,`1@)"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetDictionary`2.Count">
            <summary>
            <inheritdoc cref="P:System.Collections.ObjectModel.ObservableDictionary`2.Count"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.IDictionary.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.GetEnumerator"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#HasControl">
            <summary>
            Whether we have control (write permission) over this dictionary.
            </summary>
        </member>
        <member name="P:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#HasChanges">
            <summary>
            Do we have any pending changes?
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#WriteChanged(Sandbox.ByteStream@)">
            <summary>
            Write any changed items to a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#Read(Sandbox.ByteStream@)">
            <summary>
            Read a network update from a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#WriteAll(Sandbox.ByteStream@)">
            <summary>
            Write all items to a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.ReadAll(Sandbox.ByteStream@)">
            <summary>
            Read all changes in the dictionary as if we're building it for the first time.
            </summary>
        </member>
        <member name="M:Sandbox.NetDictionary`2.ReadChanged(Sandbox.ByteStream@)">
            <summary>
            Read any changed items from a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="T:Sandbox.NetList`1">
            <summary>
            A networkable list for use with the <see cref="T:Sandbox.SyncAttribute"/> and <see cref="T:Sandbox.HostSyncAttribute"/>. Only changes will be
            networked instead of sending the whole list every time, so it's more efficient.
            <br/>
            <para>
            <b>Example usage:</b>
            <code>
            public class MyComponent : Component
            {
            	[Sync] public NetList&lt;int&gt; MyIntegerList { get; set; } = new();
            	<br/>
            	public void AddNumber( int number )
            	{
            		if ( IsProxy ) return;
            		MyIntegerList.Add( number );
            	}
            }
            </code>
            </para>
            </summary>
        </member>
        <member name="T:Sandbox.NetList`1.Change">
            <summary>
            Represents a change in the list.
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#Add(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.Add(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Remove(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.Contains(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.IndexOf(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.Insert(System.Int32,System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            <inheritdoc cref="M:System.Collections.IList.Remove(System.Object)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Clear">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Clear"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Contains(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Contains(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.CopyTo(`0[],System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Add(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Add(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Remove(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Remove(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.IndexOf(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.IndexOf(`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Insert(System.Int32,`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.RemoveAt(System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetList`1.Count">
            <summary>
            <inheritdoc cref="P:System.Collections.Generic.List`1.Count"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.GetEnumerator"/>
            </summary>
        </member>
        <member name="P:Sandbox.NetList`1.Sandbox#INetworkCustom#HasControl">
            <summary>
            Whether we have control (write permission) over this list.
            </summary>
        </member>
        <member name="P:Sandbox.NetList`1.Sandbox#INetworkCustom#HasChanges">
            <summary>
            Do we have any pending changes?
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Sandbox#INetworkCustom#WriteChanged(Sandbox.ByteStream@)">
            <summary>
            Write any changed items to a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Sandbox#INetworkCustom#Read(Sandbox.ByteStream@)">
            <summary>
            Read a network update from a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.Sandbox#INetworkCustom#WriteAll(Sandbox.ByteStream@)">
            <summary>
            Write all items to a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="M:Sandbox.NetList`1.ReadAll(Sandbox.ByteStream@)">
            <summary>
            Read all changes in the list as if we're building it for the first time.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.NetList`1.ReadChanged(Sandbox.ByteStream@)">
            <summary>
            Read any changed items from a <see cref="T:Sandbox.ByteStream"/>.
            </summary>
        </member>
        <member name="T:Sandbox.HostSyncAttribute">
            <summary>
            Automatically synchronize a property of a networked object from the host to other clients.
            </summary>
        </member>
        <member name="T:Sandbox.NetPermission">
            <summary>
            Specifies who can invoke an action over the network.
            </summary>
        </member>
        <member name="F:Sandbox.NetPermission.Anyone">
            <summary>
            Anyone can invoke this.
            </summary>
        </member>
        <member name="F:Sandbox.NetPermission.HostOnly">
            <summary>
            Only the host can invoke this.
            </summary>
        </member>
        <member name="F:Sandbox.NetPermission.OwnerOnly">
            <summary>
            Only the owner can invoke this. If the action is static, this works the same way as <see cref="F:Sandbox.NetPermission.HostOnly"/>.
            </summary>
        </member>
        <member name="T:Sandbox.NetworkMode">
            <summary>
            Specifies how a <see cref="T:Sandbox.GameObject"/> should be networked.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkMode.Never">
            <summary>
            Never network this <see cref="T:Sandbox.GameObject"/>.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkMode.Object">
            <summary>
            Network this <see cref="T:Sandbox.GameObject"/> as a single network object. Objects networked in this
            way can have an owner, and synchronized properties with <see cref="T:Sandbox.SyncAttribute"/>.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkMode.Snapshot">
            <summary>
            Network this <see cref="T:Sandbox.GameObject"/> to other clients as part of the <see cref="T:Sandbox.Scene"/> snapshot.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.Creator">
            <summary>
            The <see cref="T:System.Guid"/> of the connection that created this.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.Owner">
            <summary>
            The <see cref="T:System.Guid"/> of the connection that owns this.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.IsOwner">
            <summary>
            Are we the owner of this networked object?
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.IsUnowned">
            <summary>
            Is this networked object unowned?
            </summary>
        </member>
        <member name="P:Sandbox.NetworkObject.IsProxy">
            <summary>
            This is this a proxy if we don't own this networked object.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.RegisterForUpdate">
            <summary>
            Something has changed about this network object and we should send a network update.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.UnregisterForUpdate">
            <summary>
            We've checked whether this object needs a network update and sent one if required. Unregister it.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.SendNetworkUpdate(Sandbox.Network.NetTransmission)">
            <summary>
            Try to send a network update or do nothing if no update is required.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.GetPropertySlot(System.Int32,System.Guid)">
            <summary>
            Get a deterministic property slot for use with a network table. This kind of sucks but it's easy
            to change it later if there's a better / faster way.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.WriteDataTable(System.Boolean)">
            <summary>
            Send any pending network table changes.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkObject.ReadDataTable(System.Byte[])">
            <summary>
            Read the network table data.
            </summary>
        </member>
        <member name="T:Sandbox.NetworkOrphaned">
            <summary>
            Specifies what happens when the owner of a networked object disconnects.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkOrphaned.Destroy">
            <summary>
            Destroy the networked object.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkOrphaned.Host">
            <summary>
            Assign the host as the owner.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkOrphaned.Random">
            <summary>
            Randomly assign another connection as the owner.
            </summary>
        </member>
        <member name="F:Sandbox.NetworkOrphaned.ClearOwner">
            <summary>
            Clear the owner of the networked object.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkTable.IsReadingChanges">
            <summary>
            Internal flag set while reading changes. Useful when you want to force
            something to be set when we otherwise wouldn't have permission to.
            </summary>
        </member>
        <member name="P:Sandbox.NetworkTable.HasChanges">
            <summary>
            Do we have any pending changes for entries we control?
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.Unregister(System.Int32)">
            <summary>
            Unregister a variable assigned to a slot id.
            </summary>
            <param name="slot"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.Register(System.Int32,Sandbox.NetworkTable.Entry)">
            <summary>
            Register a variable assigned to a slot id.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.GetValue(System.Int32)">
            <summary>
            Get a variable from a slot id.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.IsRegistered(System.Int32)">
            <summary>
            Does a variable with the specified slot exist?
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.HasControl(System.Int32)">
            <summary>
            Do we have control over the value for a specific slot id?
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.UpdateSlotHash(System.Int32,System.Object)">
            <summary>
            Update the hash for a specific slot id.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.SetValue(System.Int32,System.Object)">
            <summary>
            Set a variable from a slot id.
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.WriteAll(Sandbox.ByteStream@)">
            <summary>
            Write all variables to the provided <see cref="T:Sandbox.ByteStream"/>.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.WriteChanged(Sandbox.ByteStream@)">
            <summary>
            Write any changes to the provided <see cref="T:Sandbox.ByteStream"/>. Calling this will clear the changes.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.Read(Sandbox.ByteStream@)">
            <summary>
            Read and apply any variables from the provided <see cref="T:Sandbox.ByteStream"/>.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:Sandbox.NetworkTable.QueryValues">
            <summary>
            If any properties are "query" types, we'll copy the new values to ourselves
            and mark as changed, if changed.
            </summary>
        </member>
        <member name="T:Sandbox.OwnerTransfer">
            <summary>
            Specifies who can control ownership of a networked object.
            </summary>
        </member>
        <member name="F:Sandbox.OwnerTransfer.Takeover">
            <summary>
            Anyone can control ownership.
            </summary>
        </member>
        <member name="F:Sandbox.OwnerTransfer.Fixed">
            <summary>
            Only the host can change the ownership.
            </summary>
        </member>
        <member name="F:Sandbox.OwnerTransfer.Request">
            <summary>
            Anyone can request ownership changes from the host.
            </summary>
        </member>
        <member name="T:Sandbox.BroadcastAttribute">
            <summary>
            Marks a method as being an RPC that when invoked will be called for all connected clients including the host.
            You can filter who receives the RPC by calling the RPC within the scope of <see cref="M:Sandbox.Rpc.FilterInclude(System.Collections.Generic.IEnumerable{Sandbox.Connection})"/> or
            <see cref="M:Sandbox.Rpc.FilterExclude(System.Collections.Generic.IEnumerable{Sandbox.Connection})"/>.
            <br/><br/>
            The state of the object the RPC is called on will be up-to-date including its <see cref="T:Sandbox.GameTransform"/> and any
            properties with the <see cref="T:Sandbox.SyncAttribute"/> or <see cref="T:Sandbox.HostSyncAttribute"/> attributes by the time the method
            is called on remote clients. The only except is any synchronized properties marked with <see cref="P:Sandbox.SyncAttribute.Query"/> which
            will generally only be received every network tick.
            </summary>
        </member>
        <member name="T:Sandbox.AuthorityAttribute">
            <summary>
            Marks a method as being an RPC specifically targeted to the owner of the <see cref="T:Sandbox.GameObject"/>, or the host
            if the <see cref="T:Sandbox.GameObject"/> doesn't have an owner.
            <br/><br/>
            The state of the object the RPC is called on will be up-to-date including its <see cref="T:Sandbox.GameTransform"/> and any
            properties with the <see cref="T:Sandbox.SyncAttribute"/> or <see cref="T:Sandbox.HostSyncAttribute"/> attributes by the time the method
            is called on remote clients. The only except is any synchronized properties marked with <see cref="P:Sandbox.SyncAttribute.Query"/> which
            will generally only be received every network tick.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.Resume(Sandbox.WrappedMethod)">
            <summary>
            Resume a method from an RPC. If the RPC caller is our local connection then we'll
            first disable any active filter and restore it afterwards.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:Sandbox.Rpc.PreCall">
            <summary>
            Called right before calling an RPC function.
            </summary>
        </member>
        <member name="M:Sandbox.Rpc.FilterInclude(System.Collections.Generic.IEnumerable{Sandbox.Connection})">
            <summary>
            Filter the recipients of any Rpc called in this scope to only include the specified <see cref="T:Sandbox.Connection"/> set.
            </summary>
            <param name="connections">Only send the RPC to these connections.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterInclude(System.Predicate{Sandbox.Connection})">
            <summary>
            Filter the recipients of any Rpc called in this scope to only include a <see cref="T:Sandbox.Connection"/> based on a predicate.
            </summary>
            <param name="predicate">Only send the RPC to connections that meet the criteria of the predicate.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterInclude(Sandbox.Connection)">
            <summary>
            Filter the recipients of any Rpc called in this scope to only include the specified <see cref="T:Sandbox.Connection"/>.
            </summary>
            <param name="connection">Only send the RPC to this connection.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterExclude(System.Predicate{Sandbox.Connection})">
            <summary>
            Filter the recipients of any Rpc called in this scope to exclude a <see cref="T:Sandbox.Connection"/> based on a predicate.
            </summary>
            <param name="predicate">Exclude connections that don't meet the criteria of the predicate from receiving the RPC.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterExclude(System.Collections.Generic.IEnumerable{Sandbox.Connection})">
            <summary>
            Filter the recipients of any Rpc called in this scope to exclude the specified <see cref="T:Sandbox.Connection"/> set.
            </summary>
            <param name="connections">Exclude these connections from receiving the RPC.</param>
        </member>
        <member name="M:Sandbox.Rpc.FilterExclude(Sandbox.Connection)">
            <summary>
            Filter the recipients of any Rpc called in this scope to exclude the specified <see cref="T:Sandbox.Connection"/>.
            </summary>
            <param name="connection">Exclude this connection from receiving the RPC.</param>
        </member>
        <member name="M:Sandbox.Rpc.HasPermission(Sandbox.GameObject,Sandbox.NetPermission)">
            <summary>
            Does the current caller have permission to invoke the RPC?
            </summary>
        </member>
        <member name="T:Sandbox.SceneNetworkSystem">
            <summary>
            This is created and referenced by the network system, as a way to route.
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.OnChangingLevelMsg(Sandbox.ChangingLevelMsg,Sandbox.Connection)">
            <summary>
            Called when <see cref="T:Sandbox.ChangingLevelMsg"/> is sent to us
            </summary>
            <param name="msg"></param>
            <param name="connection"></param>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.GetSnapshot(Sandbox.Connection,Sandbox.Network.SnapshotMsg@)">
            <summary>
            A client has joined and wants a snapshot of the world
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.SetSnapshotAsync(Sandbox.Network.SnapshotMsg)">
            <summary>
            We have recieved a snapshot of the world
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.OnChangingLevel">
            <summary>
            Called when we're changing level (in this case, the scene)
            </summary>
        </member>
        <member name="M:Sandbox.SceneNetworkSystem.OnHeartbeat(System.Single,System.Single)">
            <summary>
            A heartbeat has been received from the host. We should make sure our times are in sync.
            </summary>
        </member>
        <member name="T:Sandbox.SyncAttribute">
            <summary>
            Automatically synchronize a property of a networked object from the owner to other clients.
            </summary>
        </member>
        <member name="P:Sandbox.SyncAttribute.Query">
            <summary>
            Query this value for changes rather than counting on set being called. This is appropriate
            if the value returned by its getter can change without calling its setter.
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.MakeIdGuidsUnique(System.Text.Json.Nodes.JsonObject,System.Nullable{System.Guid})">
            <summary>
            Find all "__guid" guids, and replace them with new guids. This is used to make GameObject serializations unique,
            so when you duplicate stuff, it copies over uniquely and keeps associations.
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.MakeGameObjectsUnique(System.Text.Json.Nodes.JsonObject,System.Nullable{System.Guid})">
            <summary>
            Find all "Id" guids, and replace them with new guids. This is used to make GameObject serializations unique,
            so when you duplicate stuff, it copies over uniquely and keeps associations.
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject,Transform)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject,Vector3,Rotation)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject,Vector3)">
            <summary>
            Create a unique copy of the passed in GameObject
            </summary>
        </member>
        <member name="M:Sandbox.SceneUtility.GetPrefabScene(Sandbox.PrefabFile)">
            <summary>
            Get a (cached) scene from a PrefabFile
            </summary>
        </member>
        <member name="T:Sandbox.GameObjectDirectory">
            <summary>
            New GameObjects and Components are registered with this class when they're created, and 
            unregistered when they're removed. This gives us a single place to enforce
            Id uniqueness in the scene, and allows for fast lookups by Id.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectDirectory.FindComponentByGuid(System.Guid)">
            <summary>
            Find a Component in the scene by Guid. This should be really really fast.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectDirectory.FindByGuid(System.Guid)">
            <summary>
            Find a GameObject in the scene by Guid. This should be really really fast.
            </summary>
        </member>
        <member name="M:Sandbox.GameObjectDirectory.FindByName(System.String,System.Boolean)">
            <summary>
            Find objects with this name. Not performant.
            </summary>
        </member>
        <member name="M:Sandbox.PrefabScene.CreateCachedScene(Sandbox.PrefabFile)">
            <summary>
            Creates a scene from the PrefabFile. Doesn't actually contain anything, just used as a pointer to the PrefabFile.
            You probably want to be calling PrefabScene.CreateCachedScene instead
            </summary>
        </member>
        <member name="P:Sandbox.PrefabScene.Variables">
            <summary>
            A list of variables and their targets for this prefab scene
            </summary>
        </member>
        <member name="T:Sandbox.PrefabScene.VariableCollection">
            <summary>
            A collection of variabnles that have been configured for this scene
            </summary>
        </member>
        <member name="M:Sandbox.Scene.RegisterComponent(Sandbox.Component)">
            <summary>
            Called for every enabled component
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetAllComponents``1">
            <summary>
            Get all components of type. This can include interfaces.
            This function can only find enabled/active components.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetAllComponents(System.Type)">
            <summary>
            Get all components of type. This can include interfaces.
            This function can only find enabled/active components.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.RenderAttributes">
            <summary>
            Global render attributes accessible on any renderable in this Scene.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.CreateObject(System.Boolean)">
            <summary>
            Create a GameObject on this scene. This doesn't require the scene to be the active scene.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Push">
            <summary>
            Push this scene as the active scene, for a scope
            </summary>
        </member>
        <member name="M:Sandbox.Scene.PreCameraRender">
            <summary>
            Should be called before rendering. This allows things like reflections to render.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.QueueDelete(Sandbox.GameObject)">
            <summary>
            Adds a GameObject to delete later
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ProcessDeletes">
            <summary>
            Delete any GameObjects waiting to be deleted
            </summary>
        </member>
        <member name="P:Sandbox.Scene.Editor">
            <summary>
            Allows access to the scene's editor session from the game. This will be null if there is no
            editor session active on this scene.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.ISceneEditorSession.HasUnsavedChanges">
            <summary>
            True if this scene has unsaved changes
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ISceneEditorSession.AddSelectionUndo">
            <summary>
            You have changed the editor's selection, add a new undo entry
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ISceneEditorSession.FrameTo(BBox@)">
            <summary>
            Focus the editor camera onto this box
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ISceneEditorSession.Save(System.Boolean)">
            <summary>
            Save this scene to disk
            </summary>
        </member>
        <member name="P:Sandbox.Scene.IsLoading">
            <summary>
            Return true if we're in an initial loading phase
            </summary>
        </member>
        <member name="M:Sandbox.Scene.WaitForLoading">
            <summary>
            Wait for scene loading to finish
            </summary>
        </member>
        <member name="M:Sandbox.Scene.CreateSceneFile">
            <summary>
            Create a new SceneFile from this scene
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ToSceneFile(Sandbox.SceneFile)">
            <summary>
            Save the contents of this scene to the SceneFile
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Nav_Update">
            <summary>
            In editor this gets called every frame
            In game this gets called every fixed update
            </summary>
        </member>
        <member name="P:Sandbox.Scene.NetworkFrequency">
            <summary>
            How many times a second network update runs
            </summary>
        </member>
        <member name="P:Sandbox.Scene.NetworkRate">
            <summary>
            One divided by <see cref="P:Sandbox.Scene.NetworkFrequency"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.SceneNetworkUpdate">
            <summary>
            Send any pending network updates at our desired <see cref="P:Sandbox.Scene.NetworkRate"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.FlushPendingUpdates">
            <summary>
            Send any pending network updates for all <see cref="T:Sandbox.NetworkObject"/> instances in the scene.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.DoOrphanedActions(Sandbox.Connection)">
            <summary>
            Do appropriate actions based on the <see cref="T:Sandbox.NetworkOrphaned"/> mode for all networked objects owned by a specific connection.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ShutdownSystems">
            <summary>
            Call dispose on all installed hooks
            </summary>
        </member>
        <member name="M:Sandbox.Scene.InitSystems">
            <summary>
            Find all types of SceneHook, create an instance of each one and install it.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.Signal(Sandbox.GameObjectSystem.Stage)">
            <summary>
            Signal a hook stage
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetCallbacks(Sandbox.GameObjectSystem.Stage)">
            <summary>
            Get the hook container for this stage
            </summary>
        </member>
        <member name="M:Sandbox.Scene.ResetListenerMetrics">
            <summary>
            Reset the listener metrics to 0, like before a benchmark or something
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetListenerMetrics">
            <summary>
            Get a JSON serializable list of metrics from the scene's listeners.
            (this is just internal object[] right now because I can't be fucked to exose it properly)
            </summary>
        </member>
        <member name="M:Sandbox.Scene.AddHook(Sandbox.GameObjectSystem.Stage,System.Int32,System.Action,System.String,System.String)">
            <summary>
            Call this method on this stage. This returns a disposable that will remove the hook when disposed.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetSystem``1">
            <summary>
            Get a specific system
            </summary>
        </member>
        <member name="M:Sandbox.Scene.GetSystem``1(``0@)">
            <summary>
            Get a specific system
            </summary>
        </member>
        <member name="P:Sandbox.Scene.FixedUpdateFrequency">
            <summary>
            How many times a second FixedUpdate runs
            </summary>
        </member>
        <member name="P:Sandbox.Scene.MaxFixedUpdates">
            <summary>
            If the frame took longer than a FixedUpdate step, we need to run multiple
            steps for that frame, to catch up. How many are allowed? Too few, and the 
            simluation will run slower than the game. If you allow an unlimited amount
            then the frame time could snowball to infinity and never catch up.
            </summary>
        </member>
        <member name="P:Sandbox.Scene.UseFixedUpdate">
            <summary>
            If false, then instead of operating physics, and UpdateFixed in a fixed update frequency
            they will be called the same as Update - every frame, with a time delta.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.PreTickReset">
            <summary>
            The update loop will turn certain settings on
            Here we turn them to their defaults.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.UpdateTimeFromHost(System.Single)">
            <summary>
            Update the current time from the host
            </summary>
        </member>
        <member name="M:Sandbox.Scene.SharedTick">
            <summary>
            This is called in EditorTick and GameTick. It's only called in EditorTick if we're actually
            an editor scene. 
            </summary>
        </member>
        <member name="M:Sandbox.Scene.FindInPhysics(Sandbox.Sphere)">
            <summary>
            Find game objects in a sphere using physics.
            </summary>
        </member>
        <member name="M:Sandbox.Scene.FindInPhysics(BBox)">
            <summary>
            Find game objects in a box using physics.
            </summary>
        </member>
        <member name="P:Sandbox.SceneLoadOptions.DeleteEverything">
            <summary>
            If true, on load we'll even delete objects that are marked as DontDelete
            </summary>
        </member>
        <member name="P:Sandbox.SceneTrace.NeedsFilterCallback">
            <summary>
            returns true if we need to do some managed side filtering
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Sphere(System.Single,Vector3@,Vector3@)">
            <summary>
            Casts a sphere from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Sphere(System.Single,Ray@,System.Single@)">
            <summary>
            Casts a sphere from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Box(Vector3,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Box(Vector3,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Box(BBox,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Box(BBox,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Capsule(Capsule)">
            <summary>
            Casts a capsule
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Capsule(Capsule,Vector3@,Vector3@)">
            <summary>
            Casts a capsule from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Capsule(Capsule,Ray@,System.Single@)">
            <summary>
            Casts a capsule from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Ray(Vector3@,Vector3@)">
            <summary>
            Casts a ray from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Ray(Ray@,System.Single@)">
            <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Body(Sandbox.PhysicsBody)">
            <summary>
            Casts a <see cref="T:Sandbox.PhysicsBody"/>.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Body(Sandbox.PhysicsBody,Vector3@)">
            <summary>
            Casts a PhysicsBody from its current position and rotation to desired end point.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Body(Sandbox.PhysicsBody,Transform@,Vector3@)">
            <summary>
            Casts a PhysicsBody from a position and rotation to desired end point.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Sweep(Sandbox.PhysicsBody@,Transform@,Transform@)">
            <summary>
            Sweeps each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of given PhysicsBody and returns the closest collision. Does not support Mesh PhysicsShapes.
            Basically 'hull traces' but with physics shapes.
            Same as tracing a body but allows rotation to change during the sweep.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Sweep(Sandbox.PhysicsBody@,Transform@)">
            <summary>
            Creates a Trace.Sweep using the <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see>'s position as the starting position.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.FromTo(Vector3@,Vector3@)">
            <summary>
            Sets the start and end positions of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.FromTo(Transform@,Vector3@)">
            <summary>
            Sets the start transform and end position of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Size(BBox@)">
            <summary>
            Makes this trace an axis aligned box of given size. Extracts mins and maxs from the Bounding Box.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Size(Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size. Calculates mins and maxs by assuming given size is (maxs-mins) and the center is in the middle.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Size(Vector3@,Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Radius(System.Single)">
            <summary>
            Makes this trace a sphere of given radius.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.UseHitboxes(System.Boolean)">
            <summary>
            Should we hit hitboxes
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.UseRenderMeshes(System.Boolean)">
            <summary>
            Should we hit meshes too? This can be slow and only really recommended for editor work.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.UsePhysicsWorld(System.Boolean)">
            <summary>
            Should we hit physics objects?
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithTag(System.String)">
            <summary>
            Only return entities with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the entity will need all tags).
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithAllTags(System.String[])">
            <summary>
            Only return entities with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithAllTags(Sandbox.ITagSet)">
            <summary>
            Only return entities with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithAnyTags(System.String[])">
            <summary>
            Only return entities with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithAnyTags(Sandbox.ITagSet)">
            <summary>
            Only return entities with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithoutTags(System.String[])">
            <summary>
            Only return entities without any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithoutTags(Sandbox.ITagSet)">
            <summary>
            Only return entities without any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.WithCollisionRules(System.String,System.Boolean)">
            <summary>
            Use the collision rules of an object with the given tags.
            </summary>
            <param name="tag">Which tag this trace will adopt the collision rules of.</param>
            <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
        </member>
        <member name="M:Sandbox.SceneTrace.WithCollisionRules(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Use the collision rules for the given set of tags.
            </summary>
            <param name="tags">Which tags this trace will adopt the collision rules of.</param>
            <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreGameObject(Sandbox.GameObject)">
            <summary>
            Do not hit this object
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreGameObjectHierarchy(Sandbox.GameObject)">
            <summary>
            Do not hit this object
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.HitTriggers">
            <summary>
            Hit Triggers
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.HitTriggersOnly">
            <summary>
            Hit Only Triggers
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreStatic">
            <summary>
            Do not hit static objects
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreDynamic">
            <summary>
            Do not hit dynamic objects
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.IgnoreKeyframed">
            <summary>
            Do not hit keyframed objects
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.Run">
            <summary>
            Run the trace and return the result. The result will return the first hit.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.RunAll">
            <summary>
            Run the trace and record everything we hit along the way. The result will be an array of hits.
            </summary>
        </member>
        <member name="M:Sandbox.SceneTrace.FilterCallback(Sandbox.PhysicsShape)">
            <summary>
            Return true if we should hit this shape.
            We puposely keep this locked down, don't offer a user specified callback.
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Hit">
            <summary>
            Whether the trace hit something or not
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.StartedSolid">
            <summary>
            Whether the trace started in a solid
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.StartPosition">
            <summary>
            The start position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.EndPosition">
            <summary>
            The end or hit position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.HitPosition">
            <summary>
            The hit position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Normal">
            <summary>
            The hit surface normal (direction vector)
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Fraction">
            <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.GameObject">
            <summary>
            The GameObject that was hit
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Component">
            <summary>
            The Component that was hit
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Body">
            <summary>
            The physics object that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Shape">
            <summary>
            The physics shape that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Surface">
            <summary>
            The physical properties of the hit surface
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Bone">
            <summary>
            The id of the hit bone (either from hitbox or physics shape)
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Direction">
            <summary>
            The direction of the trace ray
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Triangle">
            <summary>
            The triangle index hit, if we hit a mesh <see cref="T:Sandbox.PhysicsShape">physics shape</see>
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Tags">
            <summary>
            The tags that the hit shape had
            </summary>
        </member>
        <member name="F:Sandbox.SceneTraceResult.Hitbox">
            <summary>
            The hitbox that we hit
            </summary>
        </member>
        <member name="P:Sandbox.SceneTraceResult.Distance">
            <summary>
            The distance between start and end positions.
            </summary>
        </member>
        <member name="T:Sandbox.Speech.SpeechRecognitionResult">
            <summary>
            A result from speech recognition.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.SpeechRecognitionResult.Confidence">
            <summary>
            From 0-1 how confident are we that this is the correct result?
            </summary>
        </member>
        <member name="P:Sandbox.Speech.SpeechRecognitionResult.Text">
            <summary>
            The text result from speech recognition.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.SpeechRecognitionResult.Success">
            <summary>
            Did we successfully find a match?
            </summary>
        </member>
        <member name="T:Sandbox.Speech.Recognition.OnSpeechResult">
            <summary>
            Called when we have a result from speech recognition.
            </summary>
            <param name="result"></param>
        </member>
        <member name="P:Sandbox.Speech.Recognition.IsListening">
            <summary>
            Whether or not we are currently listening for speech.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.Recognition.IsSupported">
            <summary>
            Whether or not speech recognition is supported and a language is available.
            </summary>
        </member>
        <member name="M:Sandbox.Speech.Recognition.Start(Sandbox.Speech.Recognition.OnSpeechResult,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Start listening for speech to recognize as text. When speech has been recognized the callback
            will be invoked, the callback will also be invoked if recognition fails.
            </summary>
            <param name="callback">
            A callback that will be invoked when recognition has finished.
            </param>
            <param name="choices">
            An array of possible choices. If specified, the closest match will be chosen and passed to
            the callback.
            </param>
        </member>
        <member name="M:Sandbox.Speech.Recognition.Stop">
            <summary>
            Stop any active listening for speech.
            </summary>
        </member>
        <member name="T:Sandbox.Speech.Synthesizer">
            <summary>
            A speech synthesis stream. Lets you write text into speech and output it to a <see cref="T:Sandbox.SoundHandle"/>.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.Synthesizer.OnVisemeReachedEvent">
            <summary>
            Called by SpeechSynthesizer to populate viseme data.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.Synthesizer.InstalledVoices">
            <summary>
            Gets a list of currently installed voices on the user's system.
            </summary>
        </member>
        <member name="P:Sandbox.Speech.Synthesizer.CurrentVoice">
            <summary>
            Gets the current voice being used by <see cref="F:Sandbox.Speech.Synthesizer.SpeechSynthesizer"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.TrySetVoice(System.String)">
            <summary>
            Tries to set the voice to a matching voice name installed on the user's system.
            </summary>
            <param name="voiceName"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.TrySetVoice(System.String,System.String)">
            <summary>
            Tries to set the voice matching gender and age criteria.
            </summary>
            <param name="gender"></param>
            <param name="age"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.WithText(System.String)">
            <summary>
            Adds some text to the speech.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.OnVisemeReached(System.Action{System.Int32,System.TimeSpan})">
            <summary>
            Registers an action to fetch all viseme data.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.WithRate(System.Int32)">
            <summary>
            Sets the playback rate of the synthesizer.
            </summary>
            <param name="rate"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.WithBreak">
            <summary>
            Adds a break to the speech.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Speech.Synthesizer.Play">
            <summary>
            Takes info from <see cref="F:Sandbox.Speech.Synthesizer.Builder"/> and creates a <see cref="T:System.Speech.Synthesis.SpeechSynthesizer"/>, outputting to a stream object.
            Using <see cref="T:Sandbox.Speech.Synthesizer.AudioStreamHelpers"/> we then read all the PCM samples, and write it to a SoundStream.
            This means it'll work like any other sound.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Sandbox.Speech.Synthesizer.AudioStreamHelpers">
            <summary>
            A collection of helper methods to help read PCM samples. Taken mostly from https://github.com/Facepunch/sbox-arcade/
            </summary>
        </member>
        <member name="T:Sandbox.UI.KeyFrames">
            <summary>
            Represents a CSS <c>@keyframes</c> rule.
            </summary>
        </member>
        <member name="P:Sandbox.UI.KeyFrames.Name">
            <summary>
            Name of the <c>@keyframes</c> rule.
            </summary>
        </member>
        <member name="T:Sandbox.UI.KeyFrames.Block">
            <summary>
            A keyframe within the animation.
            </summary>
        </member>
        <member name="P:Sandbox.UI.KeyFrames.Block.Interval">
            <summary>
            The position of the keyframe within the overall animation. 0 to 1, where 0 is the start, and 1 is the end of the animation.
            </summary>
        </member>
        <member name="P:Sandbox.UI.KeyFrames.Block.Styles">
            <summary>
            The styles that should be applied at this position in the animation.
            </summary>
        </member>
        <member name="F:Sandbox.UI.KeyFrames.Blocks">
            <summary>
            List of keyframes with in the <c>@keyframes</c> rule.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Clipboard.SetText(System.String)">
            <summary>
            Sets the clipboard text
            </summary>
        </member>
        <member name="T:Sandbox.UI.Image">
            <summary>
            A generic box that displays a given texture within itself.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Image.Texture">
            <summary>
            The texture being displayed by this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Image.SetTexture(System.String)">
            <summary>
            Set <see cref="P:Sandbox.UI.Image.Texture"/> from a file path. URLs supported.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Construct.ImageConstructor.Image(Sandbox.UI.Construct.PanelCreator,System.String,System.String)">
            <summary>
            Create an image with given texture and CSS classname.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Construct.LabelConstructor.Label(Sandbox.UI.Construct.PanelCreator,System.String,System.String)">
            <summary>
            Create a simple text label with given text and CSS classname.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Construct.PanelCreator">
            <summary>
            Used for <see cref="P:Sandbox.UI.Panel.Add"/> for quick panel creation with certain settings. Other panels types are added via extension methods.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Construct.PanelCreator.panel">
            <summary>
            The panel to add children to.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Construct.PanelCreator.Panel">
            <summary>
            Add a new blank panel as a child.
            </summary>
            <returns>The crated panel.</returns>
        </member>
        <member name="M:Sandbox.UI.Construct.PanelCreator.Panel(System.String)">
            <summary>
            Add a new blank panel with given CSS classes as a child.
            </summary>
            <returns>The crated panel.</returns>
        </member>
        <member name="T:Sandbox.UI.Label">
            <summary>
            A generic text label. Can be made editable.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Label.StringInfo">
            <summary>
            Information about the <see cref="P:Sandbox.UI.Label.Text"/> on a per-element scale. It handles multi-character Unicode units (graphemes) correctly.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.Selectable">
            <summary>
            Can be selected
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.Text">
            <summary>
            Text to display on the label.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.CaretPosition">
            <summary>
            Position of the text cursor/caret within the text, at which newly typed characters are inserted.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.TextLength">
            <summary>
            Amount of characters in the text of the text entry. Not bytes.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.CaretSantity">
            <summary>
            Ensure the text caret and selection are in sane positions, that is, not outside of the text bounds.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.GetSelectedText">
            <summary>
            Returns the selected text.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.LanguageChanged">
            <summary>
            When the language changes, if we're token based we need to update to the new phrase.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Label.Multiline">
            <summary>
            Enables multi-line support for editing purposes.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.ReplaceSelection(System.String)">
            <summary>
            Replace the currently selected text with given text.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.SetSelection(System.Int32,System.Int32)">
            <summary>
            Sets the text selection.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.SetCaretPosition(System.Int32,System.Boolean)">
            <summary>
            Set the text caret position to the given index.
            </summary>
            <param name="pos">Where to move the text caret to within the text.</param>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.MoveToWordBoundaryLeft(System.Boolean)">
            <summary>
            Move the text caret to the closest word start or end to the left of current position.<br/>
            This simulates holding Control key while pressing left arrow key.
            </summary>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.MoveToWordBoundaryRight(System.Boolean)">
            <summary>
            Move the text caret to the closest word start or end to the right of current position.<br/>
            This simulates holding Control key while pressing right arrow key.
            </summary>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.MoveCaretPos(System.Int32,System.Boolean)">
            <summary>
            Move the text caret by given amount.
            </summary>
            <param name="delta">How many characters to the right to move. Negative values move left.</param>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.InsertText(System.String,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Insert given text at given position.
            </summary>
            <param name="text">Text to insert.</param>
            <param name="pos">Position to insert the text at.</param>
            <param name="endpos">If set, the end position in the current <see cref="P:Sandbox.UI.Label.Text"/>,
            which will be used to replace portion of the existing text with the given <paramref name="text"/>.</param>
        </member>
        <member name="M:Sandbox.UI.Label.RemoveText(System.Int32,System.Int32)">
            <summary>
            Remove given amount of characters from the label at given <paramref name="start"/> position.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.MoveToLineStart(System.Boolean)">
            <summary>
            Move the text caret to the start of the current line.
            </summary>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.MoveToLineEnd(System.Boolean)">
            <summary>
            Move the text caret to the end of the current line.
            </summary>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.MoveCaretLine(System.Int32,System.Boolean)">
            <summary>
            Move the text caret to next or previous line.
            </summary>
            <param name="offset_line">How many lines to offset. Negative values move up.</param>
            <param name="select">Whether to also add the characters we passed by to the selection.</param>
        </member>
        <member name="M:Sandbox.UI.Label.SelectWord(System.Int32)">
            <summary>
            Select a work at given word position.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.GetWordBoundaryIndices">
            <summary>
            Returns a list of positions in the text of each side of each word within the <see cref="P:Sandbox.UI.Label.Text"/>.<br/>
            This is used for Control + Arrow Key navigation.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Label.IsNewline(System.String)">
            <summary>
            Returns true if the input string is a 1 or 2 (\r\n) character newline symbol.
            </summary>
        </member>
        <member name="T:Sandbox.UI.ScenePanel">
            <summary>
            Allows to render a scene world onto a panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.World">
            <summary>
            Shortcut to Camera.World
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.Camera">
            <summary>
            The camera we're going to be using to render
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.RenderOnce">
            <summary>
            If enabled, the scene will only render once. That isn't totally accurate though, because we'll
            also re-render the scene when the size of the panel changes.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.RenderTexture">
            <summary>
            The texture that the panel is rendering to internally. This will change to a different
            texture if the panel changes size, so I wouldn't hold onto this object.
            </summary>
        </member>
        <member name="M:Sandbox.UI.ScenePanel.RenderNextFrame">
            <summary>
            Render the panel again next frame. This is meant to be used with RenderOnce, where
            you might want to render on demand or only once.
            </summary>
        </member>
        <member name="T:Sandbox.UI.SvgPanel">
            <summary>
            A generic panel that draws an SVG scaled to size
            </summary>
        </member>
        <member name="P:Sandbox.UI.SvgPanel.Src">
            <summary>
            Content path to the SVG file
            </summary>
        </member>
        <member name="P:Sandbox.UI.SvgPanel.Color">
            <summary>
            Optional color to draw the SVG with
            </summary>
        </member>
        <member name="T:Sandbox.UI.WebPanel">
            <summary>
            A panel that displays an interactive web page.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WebPanel.Surface">
            <summary>
            Access to the HTML surface to change URL, etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.WebPanel.BrowserDataChanged(System.ReadOnlySpan{System.Byte},Vector2)">
            <summary>
            The texture has changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.LayoutCascade.ApplyCascading(Sandbox.UI.Styles)">
            <summary>
            Some properties cascade from their parent onto children if the children
            don't set them. Things like font size, color, cursor.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TransitionDesc">
            <summary>
            Describes transition of a single CSS property, a.k.a. the values of a <c>transition</c> CSS property.
            <para>Utility to create a transition by comparing the
            panel style before and after the scope.</para>
            </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionDesc.Property">
            <summary>
            The CSS property to transition.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionDesc.Duration">
            <summary>
            Duration of the transition between old value and new value.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionDesc.Delay">
            <summary>
            If set, delay before starting the transition after the property was changed.
            </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionDesc.TimingFunction">
            <summary>
            The timing or "easing" function. <c>transition-timing-function</c> CSS property.
            Example values would be <c>ease</c>,  <c>ease-in</c>,  <c>ease-out</c> and  <c>ease-in-out</c>.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TransitionList">
             <summary>
             A list of CSS properties that should transition when changed.
            
             Utility to create a transition by comparing the
             panel style before and after the scope.
             </summary>
        </member>
        <member name="F:Sandbox.UI.TransitionList.List">
            <summary>
            The actual list of CSS properties that should be transitioned.
            </summary>
        </member>
        <member name="M:Sandbox.UI.TransitionList.Clear">
            <summary>
            Clear the list of CSS transitions.
            </summary>
        </member>
        <member name="M:Sandbox.UI.TextBlock.Render(Sandbox.UI.PanelRenderer,Sandbox.UI.RenderState@,Sandbox.UI.Styles,Sandbox.Rect,System.Single)">
            <summary>
            Proper Rendering
            </summary>
        </member>
        <member name="M:Sandbox.UI.TextBlock.SizeFinalized(System.Single,System.Single)">
            <summary>
            Called on layout. We should decide here if we actually need to rebuild
            </summary>
        </member>
        <member name="M:Sandbox.UI.TextBlock.RebuildTexture(System.Single,System.Single)">
            <summary>
            Actually recreate the texture
            </summary>
        </member>
        <member name="T:Sandbox.UI.ButtonEvent">
            <summary>
            Keyboard (and mouse) key press <see cref="T:Sandbox.UI.PanelEvent"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.Button">
            <summary>
            The button that triggered the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.Pressed">
            <summary>
            Whether the button was pressed in, or release.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.KeyboardModifiers">
            <summary>
            The keyboard modifier keys that were held down at the moment the event triggered.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.HasShift">
            <summary>
            Whether <c>Shift</c> key was being held down at the time of the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.HasCtrl">
            <summary>
            Whether <c>Control</c> key was being held down at the time of the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.HasAlt">
            <summary>
            Whether <c>Alt</c> key was being held down at the time of the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.ButtonEvent.StopPropagation">
            <summary>
            Set to <see langword="true"/> to prevent the event from propagating to the parent panel.
            </summary>
        </member>
        <member name="T:Sandbox.UI.InputEventQueue">
            <summary>
            Queue input events on here to be processed by the UISystem.
            </summary>
        </member>
        <member name="T:Sandbox.UI.InputFocus">
            <summary>
            Handles input focus for <see cref="T:Sandbox.UI.Panel"/>s.
            </summary>
        </member>
        <member name="P:Sandbox.UI.InputFocus.Current">
            <summary>
            The panel that currently has input focus.
            </summary>
        </member>
        <member name="P:Sandbox.UI.InputFocus.Next">
            <summary>
            The panel that will have the input focus next.
            </summary>
        </member>
        <member name="M:Sandbox.UI.InputFocus.Set(Sandbox.UI.Panel)">
            <summary>
            Set the focus to this panel (or its nearest ancestor with AcceptsFocus).
            Note that <see cref="P:Sandbox.UI.InputFocus.Current"/> won't change until the next frame.
            </summary>
        </member>
        <member name="M:Sandbox.UI.InputFocus.Clear(Sandbox.UI.Panel)">
            <summary>
            Clear focus away from this panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelInput.Hovered">
            <summary>
            Panel we're currently hovered over
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelInput.Active">
            <summary>
            Panel we're currently pressing down
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelInput.AddMouseWheel(Vector2,Sandbox.KeyboardModifiers)">
            <summary>
            Called from input when mouse wheel changes
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelInput.AddMouseButton(NativeEngine.ButtonCode,System.Boolean,Sandbox.KeyboardModifiers)">
            <summary>
            Called from input when mouse wheel changes
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelInput.SetCursor(System.String)">
            <summary>
            The cursor should change. Name could be null, meaning default.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelInput.MouseButtonState.DragTarget">
            <summary>
            Then panel that is potentially being dragged
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelInput.MouseButtonState.StartHoldOffsetLocal">
            <summary>
            The point where we first pressed on the Active element
            </summary>
        </member>
        <member name="T:Sandbox.UI.WorldInput">
            <summary>
            WorldInput can be used to simulate standard mouse inputs on WorldPanels.
            </summary>
            <remarks>
            <para>
            You need to set <see cref="P:Sandbox.UI.WorldInput.Ray"/> and <see cref="P:Sandbox.UI.WorldInput.MouseLeftPressed"/> to simulate inputs,
            ideally this should be done in a BuildInput event.
            </para>
            </remarks>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Enabled">
            <summary>
            This input won't tick when this is false.
            Any hovered panels will be cleared.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Ray">
            <summary>
            The Ray used to intersect with your world panels, simulating mouse position.
            </summary>
            <remarks>
            This should ideally be set in BuildInput or FrameSimulate.
            </remarks>
        </member>
        <member name="P:Sandbox.UI.WorldInput.MouseWheel">
            <summary>
            Simulate the mouse scroll wheel.
            You could use <seealso cref="P:Sandbox.Input.MouseWheel"/>
            Or you could simulate it with the camera view delta for example.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.UseMouseInput">
            <summary>
            Instead of simulating mouse input, this will simply use the mouse input.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Hovered">
            <summary>
            The <see cref="T:Sandbox.UI.Panel"/> that is currently hovered by this input.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Active">
            <summary>
            The <see cref="T:Sandbox.UI.Panel"/> that is currently pressed by this input.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.activeRules">
            <summary>
            This could be a local variable if we wanted to create a new class every time
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.LastActiveRules">
            <summary>
            Store the last active rules so we can compare them when they change and trigger sounds etc on new styles
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.ActiveRulesGuid">
            <summary>
            Cache of the active rules that are applied, that way we can trigger stuff only if they actually changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelStyle.UnderlyingStyleHasChanged">
            <summary>
            Should be called when a stylesheet in our bundle has changed. This can happen as a result of
            editing it in the style editor.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.StyleBlocks">
            <summary>
            All these styles could possibly apply to us. To get this list we get the stylesheets from
            ourself and our anscestors and then filter them by the broadphase. The broadphase is a check
            against classes, element names and ids, things that don't change in a recursive way.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.broadPhaseHash">
            <summary>
            A hash of the things that are checked in the broadphase.
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelStyle.InvalidateBroadphase">
            <summary>
            Called when a stylesheet has been added or removed from ourselves or one of
            our ancestor panels - because under that condition we need to rebuild our
            broadphase.
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelStyle.BuildRulesInThread">
            <summary>
            Called from the root panel in a thread. We replace activeRules with all of the rules that
            we want applied and return true if the rules changed.
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelStyle.ContainsStyle(Sandbox.UI.Styles)">
            <summary>
            Returns true if we have the style
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.MouseDelta">
            <summary>
            For ondrag event - the delta of the mouse movement
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.LocalGrabPosition">
            <summary>
            The position on the Target panel where the drag started
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.ScreenGrabPosition">
            <summary>
            The position relative to the screen where the drag started
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.LocalPosition">
            <summary>
            The current mouse position relative to target
            </summary>
        </member>
        <member name="F:Sandbox.UI.DragEvent.ScreenPosition">
            <summary>
            The current position relative to the screen
            </summary>
        </member>
        <member name="T:Sandbox.UI.MousePanelEvent">
            <summary>
            Mouse related <see cref="T:Sandbox.UI.PanelEvent"/>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.MousePanelEvent.LocalPosition">
            <summary>
            Position of the cursor relative to the panel's top left corner at the time the event was triggered.
            </summary>
        </member>
        <member name="F:Sandbox.UI.MousePanelEvent.Button">
            <summary>
            Which button triggered the event, in string form.
            </summary>
        </member>
        <member name="P:Sandbox.UI.MousePanelEvent.MouseButton">
            <summary>
            Which button triggered the event, as a <see cref="T:Sandbox.MouseButtons"/> enum.
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelEvent">
            <summary>
            Base <see cref="T:Sandbox.UI.Panel"/> event.<br/>
            See <see cref="M:Sandbox.UI.Panel.CreateEvent(Sandbox.UI.PanelEvent)"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelEvent.This">
            <summary>
            The panel on which the event is being called. For example, if you have a button with a label.. when the
            button gets clicked the actual click event might come from the label. When the event is called on the
            label, This will be the label. When the event propagates up to the button This will be the button - but
            Target will be the label. This is mainly of use with Razor callbacks, where you want to get the actual
            panel that created the event.
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelEventAttribute">
            <summary>
            Add an event listener to a <see cref="T:Sandbox.UI.Panel"/> event with the given name.<br/>
            See <see cref="M:Sandbox.UI.Panel.CreateEvent(System.String,System.Object,System.Nullable{System.Single})"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.PanelEventAttribute.Name">
            <summary>
            Name of the event to listen to.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Panel">
            <summary>
            A simple User Interface panel. Can be styled with <a href="https://en.wikipedia.org/wiki/CSS">CSS</a>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Add">
            <summary>
            Quickly add common panels with certain values as children.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel._children">
            <inheritdoc cref="P:Sandbox.UI.Panel.Children"/>
        </member>
        <member name="F:Sandbox.UI.Panel._parent">
            <inheritdoc cref="P:Sandbox.UI.Panel.Parent"/>
        </member>
        <member name="P:Sandbox.UI.Panel.Children">
            <summary>
            List of panels that are attached/<see cref="P:Sandbox.UI.Panel.Parent">parented</see> directly to this one.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasChildren">
            <summary>
            Whether this panel has any <see cref="P:Sandbox.UI.Panel.Children">child panels</see> at all.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Parent">
            <summary>
            The panel we are directly attached to. This panel will be positioned relative to the given parent, and therefore move with it, typically also be hidden by the parents bounds.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RemoveChild(Sandbox.UI.Panel)">
            <summary>
            Called internally when a child is removed, to remove from our Children list
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnChildRemoved(Sandbox.UI.Panel)">
            <summary>
            A child panel has been removed from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DeleteChildren(System.Boolean)">
            <summary>
            Deletes all child panels via <see cref="M:Sandbox.UI.Panel.Delete(System.Boolean)"/>.
            </summary>
            <inheritdoc cref="M:Sandbox.UI.Panel.Delete(System.Boolean)"/>
        </member>
        <member name="M:Sandbox.UI.Panel.AddChild(Sandbox.UI.Panel)">
            <summary>
            Add given panel as a child to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InternalAddChild(Sandbox.UI.Panel)">
            <summary>
            Called internally when a child is added, to add to our <see cref="P:Sandbox.UI.Panel.Children">children</see> list.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnChildAdded(Sandbox.UI.Panel)">
            <summary>
            A child panel has been added to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren(System.Comparison{Sandbox.UI.Panel})">
            <summary>
            Sort the <see cref="P:Sandbox.UI.Panel.Children">children</see> using given comparison function.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren``1(System.Func{``0,System.Int32})">
            <summary>
            Sort the <see cref="P:Sandbox.UI.Panel.Children">children</see> using given comparison function.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren(System.Func{Sandbox.UI.Panel,System.Int32})">
            <summary>
            Sort the <see cref="P:Sandbox.UI.Panel.Children">children</see> using given comparison function.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.SiblingIndex">
            <summary>
            The index of this panel in its parent's child list.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddChild``1(System.String)">
            <summary>
            Creates a panel of given type and makes it our child.
            </summary>
            <typeparam name="T">The panel to create.</typeparam>
            <param name="classnames">Optional CSS class names to apply to the newly created panel.</param>
            <returns>The created panel.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.AddChild``1(``0@,System.String)">
            <summary>
            Creates a panel of given type and makes it our child, returning it as an out argument.
            </summary>
            <typeparam name="T">The panel to create.</typeparam>
            <param name="outPanel">The created panel.</param>
            <param name="classnames">Optional CSS class names to apply to the newly created panel.</param>
            <returns>Always returns <see langword="true"/>.</returns>
        </member>
        <member name="P:Sandbox.UI.Panel.AncestorsAndSelf">
            <summary>
            Returns this panel and all its <see cref="P:Sandbox.UI.Panel.Ancestors">ancestors</see>, i.e. the <see cref="P:Sandbox.UI.Panel.Parent">Parent</see>, parent of its parent, etc.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Ancestors">
            <summary>
            Returns all ancestors, i.e. the parent, parent of our parent, etc.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Descendants">
            <summary>
            List of all panels that are attached to this panel, recursively, i.e. all <see cref="P:Sandbox.UI.Panel.Children">children</see> of this panel, children of those children, etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.IsAncestor(Sandbox.UI.Panel)">
            <summary>
            Is the given panel a parent, grandparent, etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FindRootPanel">
            <summary>
            Returns the <see cref="T:Sandbox.UI.RootPanel"/> we are ultimately attached to, if any.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FindPopupPanel">
            <summary>
            Returns the first <see cref="P:Sandbox.UI.Panel.Ancestors">ancestor</see> panel that has no parent.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Scene">
            <summary>
            Returns the scene that this panel belongs to
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetChildIndex(Sandbox.UI.Panel)">
            <summary>
            Returns the index at which the given panel is <see cref="P:Sandbox.UI.Panel.Parent">parented</see> to this panel, or -1 if it is not.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetChild(System.Int32,System.Boolean)">
            <summary>
            Return a child at given index.
            </summary>
            <param name="index">Index at which to look.</param>
            <param name="loop">Whether to loop indices when out of bounds, i.e. -1 becomes last child, 11 becomes second child in a list of 10, etc.</param>
            <returns>Returns the requested child, or <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="P:Sandbox.UI.Panel.ChildrenCount">
            <summary>
            Amount of panels directly <see cref="P:Sandbox.UI.Panel.Parent">parented</see> to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ChildrenOfType``1">
            <summary>
            Returns a list of <see cref="P:Sandbox.UI.Panel.Children">child panels</see> of given type.
            </summary>
            <typeparam name="T">The type of panels to retrieve.</typeparam>
        </member>
        <member name="P:Sandbox.UI.Panel.Class">
            <summary>
            A list of CSS classes applied to this panel.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel._class">
            <inheritdoc cref="P:Sandbox.UI.Panel.Class"/>
        </member>
        <member name="P:Sandbox.UI.Panel.Classes">
            <summary>
            All CSS classes applied to this panel, separated with spaces.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddClass(System.String)">
            <summary>
            Adds CSS class(es) separated by spaces to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetClass(System.String,System.Boolean)">
            <summary>
            Sets a specific CSS class active or not.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ToggleClass(System.String)">
            <summary>
            Add a class if we don't have it, remove a class if we do have it
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddClasses(System.String)">
            <summary>
            Add multiple CSS classes separated by spaces to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RemoveClass(System.String)">
            <summary>
            Removes given CSS class from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.HasClass(System.String)">
            <summary>
            Whether we have the given CSS class or not.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.HasClasses(System.String[])">
            <summary>
            Whether if we have <b>all</b> of these CSS classes.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DirtyStylesRecursive">
            <summary>
            Dirty the styles on this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DirtyStylesWithStyle(Sandbox.UI.Styles,System.Boolean)">
            <summary>
            Dirty the styles of this class and its children recursively.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.BindClass(System.String,System.Func{System.Boolean})">
            <summary>
            Switch the class on or off depending on the value of the bool.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ElementName">
            <summary>
            The element name. If you've created this Panel via a template this will be whatever the element
            name is on there. If not then it'll be the name of the class (ie Panel, Button)
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Id">
            <summary>
            Works the same as the html id="" attribute. If you set Id to "poop", it'll match any styles
            that define #poop in their selector.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.SourceFile">
            <summary>
            If this was created by razor, this is the file in which it was created
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.SourceLine">
            <summary>
            If this was created by razor, this is the line number in the file
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.Task">
            <summary>
            Quick access to timing events, for async/await.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.StyleSheet">
            <summary>
            A collection of stylesheets applied to this panel directly.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.PseudoClass">
            <summary>
            Special flags used by the styling system for hover, active etc..
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasFocus">
            <summary>
            Whether this panel has the <c>:focus</c> pseudo class active.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasActive">
            <summary>
            Whether this panel has the <c>:active</c> pseudo class active.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasHovered">
            <summary>
            Whether this panel has the <c>:hover</c> pseudo class active.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasIntro">
            <summary>
            Whether this panel has the <c>:intro</c> pseudo class active.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasOutro">
            <summary>
            Whether this panel has the <c>:outro</c> pseudo class active.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnHotloaded">
            <summary>
            Called when a hotload happened. (Not necessarily on this panel)
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.AllStyleSheets">
            <summary>
            List of all <see cref="T:Sandbox.UI.StyleSheet"/>s applied to this panel and all its <see cref="P:Sandbox.UI.Panel.AncestorsAndSelf">ancestors</see>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Switch(Sandbox.UI.PseudoClass,System.Boolean)">
            <summary>
            Switch a pseudo class on or off.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsVisible">
            <summary>
            Return true if this panel isn't hidden by opacity or displaymode.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsVisibleSelf">
            <summary>
            Return true if this panel isn't hidden by opacity or displaymode.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Tick">
            <summary>
            Called every frame. This is your "Think" function.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnParentChanged">
            <summary>
            Called after the parent of this panel has changed.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.WantsMouseInput">
            <summary>
            Returns true if this panel would like the mouse cursor to be visible.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelDelta(Vector2)">
            <summary>
            Convert a point from the screen to a point representing a delta on this panel where
            the top left is [0,0] and the bottom right is [1,1]
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelPosition(Vector2)">
            <summary>
            Convert a point from the screen to a position relative to the top left of this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PanelPositionToScreenPosition(Vector2)">
            <summary>
            Convert a point from local space to screen space
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FindInRect(Sandbox.Rect,System.Boolean)">
            <summary>
            Find and return any children of this panel (including self) within the given rect.
            </summary>
            <param name="box">The area to look for panels in, in screen-space coordinates.</param>
            <param name="fullyInside">Whether we want only the panels that are completely within the given bounds.</param>
        </member>
        <member name="P:Sandbox.UI.Panel.AllowChildSelection">
            <summary>
            Allow selecting child text
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDragSelect(Sandbox.UI.SelectionEvent)">
            <summary>
            Called when the player moves the mouse after "press and holding" (or dragging) the panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.LanguageChanged">
            <summary>
            Called when the current language has changed. This allows you to rebuild
            anything that might need rebuilding. Tokenized text labels should automatically update.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.StringValue">
            <summary>
            Set via <c>"value"</c> property from HTML.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateValueEvent(System.String,System.Object)">
            <summary>
            Call this when the value has changed due to user input etc. This updates any
            bindings, backwards. Also triggers $"{name}.changed" event, with value being the Value on the event.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsDeleting">
            <summary>
            Whether <see cref="M:Sandbox.UI.Panel.Delete(System.Boolean)"/> was called on this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Delete(System.Boolean)">
            <summary>
            Deletes the panel.
            </summary>
            <param name="immediate">If <see langword="true"/>, will skip any outros. (<c>:outro</c> CSS pseudo class)</param>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDeleted">
            <summary>
            Called when the panel is about to be deleted.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDeleteRecursive">
            <summary>
            Called on delete.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.WantsDrag">
            <summary>
            Return true if this panel wants to be dragged
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.CanDragScroll">
            <summary>
            Set this to false if you want to opt out of drag scrolling
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FindDragTarget">
            <summary>
            Find a panel in our heirachy that wants to be dragged
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InternalDragEvent(Sandbox.UI.DragEvent)">
            <summary>
            Distribute the drag events to specific virtual functions
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasScrollX">
            <summary>
            Return true if this panel is scrollable on the X axis
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasScrollY">
            <summary>
            Return true if this panel is scrollable on the Y axis
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InitializeEvents">
            <summary>
            Called on creation and hotload to delete and re-initialize event listeners.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddEventListener(System.String,System.Action{Sandbox.UI.PanelEvent})">
            <summary>
            Runs given callback when the given event is triggered.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddEventListener(System.String,System.Action)">
            <summary>
            Runs given callback when the given event is triggered, without access to the <see cref="T:Sandbox.UI.PanelEvent"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateEvent(System.String,System.Object,System.Nullable{System.Single})">
            <summary>
            Create a new event and pass it to the panels event queue.
            </summary>
            <param name="name">Event name.</param>
            <param name="value">Event value.</param>
            <param name="debounce">Time, in seconds, to wait before firing the event.<br/>
            All subsequent calls to <see cref="M:Sandbox.UI.Panel.CreateEvent(System.String,System.Object,System.Nullable{System.Single})"/> with the same event
            name will update the original event instead of creating a new event, until it finally triggers.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateEvent(Sandbox.UI.PanelEvent)">
            <summary>
            Pass given event to the event queue.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnEvent(Sandbox.UI.PanelEvent)">
            <summary>
            Called when various <see cref="T:Sandbox.UI.PanelEvent"/>s happen. Handles event listeners and many standard events by default.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnClick(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player releases their left mouse button (Mouse 1) while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMiddleClick(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player releases their middle mouse button (Mouse 3) while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnRightClick(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player releases their right mouse button (Mouse 2) while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseDown(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player presses down the left or right mouse buttons while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseUp(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player releases left or right mouse button.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDoubleClick(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the player double clicks the panel with the left mouse button.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseMove(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the cursor moves while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseOver(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the cursor enters this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseOut(Sandbox.UI.MousePanelEvent)">
            <summary>
            Called when the cursor leaves this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnBack(Sandbox.UI.PanelEvent)">
            <summary>
            Called when the player presses the "Back" button while hovering this panel, which is typically "mouse 5", aka one of the mouse buttons on its side.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnForward(Sandbox.UI.PanelEvent)">
            <summary>
            Called when the player presses the "Forward" button while hovering this panel, which is typically "mouse 4", aka one of the mouse buttons on its side.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnEscape(Sandbox.UI.PanelEvent)">
            <summary>
            Called when the escape key is pressed
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnFocus(Sandbox.UI.PanelEvent)">
            <summary>
            Called when this panel receives input focus.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnBlur(Sandbox.UI.PanelEvent)">
            <summary>
            Called when this panel loses input focus.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.MousePosition">
            <summary>
            Current mouse position local to this panels top left corner.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetTransformPosition(Vector2)">
            <summary>
            Called by <see cref="M:Sandbox.UI.PanelInput.CheckHover(Sandbox.UI.Panel,Vector2,Sandbox.UI.Panel@)" /> to transform
            the current mouse position using the panel's LocalMatrix (by default). This can be overriden for special cases.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.UI.Panel.IsInside(Vector2)">
            <summary>
            Whether given screen position is within this panel. This will accurately handle border radius as well.
            </summary>
            <param name="pos">The position to test, in screen coordinates.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.IsInside(Sandbox.Rect,System.Boolean)">
            <summary>
            Whether the given rect is inside this panels bounds. (<see cref="F:Sandbox.UI.Box.Rect"/>)
            </summary>
            <param name="rect">The rect to test, which should have screen-space coordinates.</param>
            <param name="fullyInside"><see langword="true"/> to test if the given rect is completely inside the panel. <see langword="false"/> to test for an intersection.</param>
        </member>
        <member name="P:Sandbox.UI.Panel.AcceptsFocus">
            <summary>
            False by default, can this element accept keyboard focus. If an element accepts
            focus it'll be able to receive keyboard input.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ButtonInput">
            <summary>
            Describe what to do with keyboard input. The default is InputMode.UI which means that when
            focused, this panel will receive Keys Typed and Button Events.
            If you set this to InputMode.Game, this panel will redirect its inputs to the game, which means
            for example that if you're focused on this panel and press space, it'll send the jump button to the game.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.AcceptsImeInput">
            <summary>
            False by default. Anything that is capable of accepting IME input should return true. Which is probably just a TextEntry.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Focus">
            <summary>
            Give input focus to this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Blur">
            <summary>
            Remove input focus from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnButtonEvent(Sandbox.UI.ButtonEvent)">
            <summary>
            Called when any button, mouse (except for mouse4/5) and keyboard, are pressed or depressed while hovering this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnKeyTyped(System.Char)">
            <summary>
            Called when a printable character has been typed (pressed) while this panel has input focus. (<see cref="M:Sandbox.UI.Panel.Focus"/>)
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnButtonTyped(Sandbox.UI.ButtonEvent)">
            <summary>
            Called when any keyboard button has been typed (pressed) while this panel has input focus. (<see cref="M:Sandbox.UI.Panel.Focus"/>)
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnPaste(System.String)">
            <summary>
            Called when the user presses CTRL+V while this panel has input focus.
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Sandbox.UI.Panel.GetClipboardValue(System.Boolean)">
            <summary>
            If we have a value that can be copied to the clipboard, return it here.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnMouseWheel(Vector2)">
            <summary>
            Called when the player scrolls their mouse wheel while hovering this panel.
            </summary>
            <param name="value">The scroll wheel delta. Positive values are scrolling down, negative - up.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.TryScroll(Vector2)">
            <summary>
            Called from <see cref="M:Sandbox.UI.Panel.OnMouseWheel(Vector2)"/> to try to scroll.
            </summary>
            <param name="value">The scroll wheel delta. Positive values are scrolling down, negative - up.</param>
            <returns>Return true to NOT propagate the event to the <see cref="P:Sandbox.UI.Panel.Parent"/>.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.TryScrollToBottom">
            <summary>
            Scroll to the bottom, if the panel has scrolling enabled.
            </summary>
            <returns>Whether we scrolled to the bottom or not.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.SetMouseCapture(System.Boolean)">
            <summary>
            Captures the mouse cursor while active. The cursor will be hidden and will be stuck in place.
            <para>You will want to use <see cref="P:Sandbox.Mouse.Delta"/> in
            <see cref="M:Sandbox.UI.Panel.Tick"/> while <see cref="P:Sandbox.UI.Panel.HasMouseCapture"/> to read mouse movements.</para>
            <para>You can call this from <see cref="M:Sandbox.UI.Panel.OnButtonEvent(Sandbox.UI.ButtonEvent)"/> for mouse clicks.</para>
            </summary>
            <param name="b">Whether to enable or disable the capture.</param>
        </member>
        <member name="P:Sandbox.UI.Panel.HasMouseCapture">
            <summary>
            Whether this panel is capturing the mouse cursor. See <see cref="M:Sandbox.UI.Panel.SetMouseCapture(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RayToLocalPosition(Ray,Vector2@,System.Single@)">
            <summary>
            Transform a ray in 3D space to a position on the panel. This is used for world panel input.
            </summary>
            <param name="ray">The ray in 3D world space to test against this panel.</param>
            <param name="position">Position on the panel where the intersection happened, local to the panel's top left corner.</param>
            <param name="distance">Distance from the ray's origin to the intersection in 3D space.</param>
            <returns>Return true if a hit/intersection was detected.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.Sandbox#Internal#IPanel#UpdateTooltip(Sandbox.Internal.IPanel)">
            <summary>
            If the tooltip text changed, we'll update it here. I haven't exposed this to game code yet
            because I doubt the usefulness to people that are manually creating tooltip panels.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PushLayer(Sandbox.UI.PanelRenderer)">
            <summary>
            Called before rendering this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PopLayer(Sandbox.UI.PanelRenderer,Sandbox.RenderTarget)">
            <summary>
            Called after rendering this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DrawPreFilterShadows">
            <summary>
            Draws shadows for the current layer 
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DrawPreFilterBorder">
            <summary>
            Draws borders for the current layer
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Box">
            <summary>
            Access to various bounding boxes of this panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasContent">
            <summary>
            If true, calls <see cref="M:Sandbox.UI.Panel.DrawContent(Sandbox.UI.RenderState@)"/>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.ScrollVelocity">
            <summary>
            The velocity of the current scroll
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ScrollOffset">
            <summary>
            Offset of the panel's children position for scrolling purposes.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ScaleToScreen">
            <summary>
            Scale of the panel on the screen.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ScaleFromScreen">
            <summary>
            Inverse scale of <see cref="P:Sandbox.UI.Panel.ScaleToScreen"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.LocalMatrix">
            <summary>
            If this panel has transforms, they'll be reflected here
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.GlobalMatrix">
            <summary>
            If this panel or its parents have transforms, they'll be compounded here.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.TransformMatrix">
            <summary>
            The matrix that is applied as a result of transform: styles
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasBackdropFilter">
            <summary>
            The computed style has a non-default backdrop filter property
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasFilter">
            <summary>
            The computed style has a non-default filter property
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasBackground">
            <summary>
            The computed style has a renderable background
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Opacity">
            <summary>
            The currently calculated opacity.
            This is set by multiplying our current style opacity with our parent's opacity.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnLayout(Sandbox.Rect@)">
            <summary>
            This panel has just been laid out. You can modify its position now and it will affect its children.
            This is a useful place to restrict shit to the screen etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FinalLayout(Vector2)">
            <summary>
            Takes a <see cref="T:Sandbox.UI.LayoutCascade"/> and returns an outer rect
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.PreferScrollToBottom">
            <summary>
            If true, we'll try to stay scrolled to the bottom when the panel changes size
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsScrollAtBottom">
            <summary>
            Whether the scrolling is currently pinned to the bottom of the panel as dictated by <see cref="P:Sandbox.UI.Panel.PreferScrollToBottom"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ScrollSize">
            <summary>
            The size of the scrollable area within this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FinalLayoutChildren(Vector2)">
            <summary>
            Layout the children of this panel.
            </summary>
            <param name="offset">The parent's position.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.ConstrainScrolling(Vector2)">
            <summary>
            Constrain <see cref="P:Sandbox.UI.Panel.ScrollOffset">scrolling</see> to the given size.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PlaySound(System.String)">
            <summary>
            Play a sound from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.MoveAfterSibling(Sandbox.UI.Panel)">
            <summary>
            Move this panel to be after the given sibling.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetChildIndex(Sandbox.UI.Panel,System.Int32)">
            <summary>
            Move given child panel to be given index, where 0 is the first child.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.templateBindsChanged">
            <summary>
            True when a bind has changed and OnParametersSet call is pending a call
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetPropertyObject(System.String,System.Object)">
            <summary>
            Same as <see cref="M:Sandbox.UI.Panel.SetProperty(System.String,System.String)"/>, but first tries to set the property on the panel object, then process any special properties such as <c>class</c>.
            </summary>
            <inheritdoc cref="M:Sandbox.UI.Panel.SetProperty(System.String,System.String)"/>
        </member>
        <member name="M:Sandbox.UI.Panel.SetProperty(System.String,System.String)">
            <summary>
            Set a property on the panel, such as special properties (<c>class</c>, <c>id</c>, <c>style</c> and <c>value</c>, etc.) and properties of the panel's C# class.
            </summary>
            <param name="name">name of the property to modify.</param>
            <param name="value">Value to assign to the property.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.SetAttribute(System.String,System.String)">
            <summary>
            Used in templates, gets an attribute that was set in the template.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetAttribute(System.String,System.String)">
            <summary>
            Used in templates, try to get the attribute that was set in creation.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Bind(System.String,System.Object,System.String)">
             <summary>
             Bind property of this panel to the value of a property of a given panel.
            
             When our property changes due to the bind, <see cref="M:Sandbox.UI.Panel.OnParametersSet"/> will be called.
             </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnParametersSet">
            <summary>
            Called after all templated panel binds have been set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnParametersSetAsync">
            <summary>
            Called after all templated panel binds have been set.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetContent(System.String)">
            <summary>
            Called by the templating system when an element has content between its tags.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Panel.razorTreeDirty">
            <summary>
            true when the tree should be re-rendered next frame.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.StateHasChanged">
            <summary>
            For razor panels, call when the state of the render tree has changed such that
            it would be a good idea to re-render the tree. You would usually not need to call
            this manually.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetRenderTreeChecksum">
            <summary>
            Overridden/implemented by Razor templating, contains render tree checksum to determine when the render tree content has changed.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.BuildRenderTree(Sandbox.Razor.RenderTreeBuilder)">
            <summary>
            Overridden/implemented by Razor templating to build a render tree.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.BuildHash">
            <summary>
            By overriding this you can return a hash of variables used by the Razor layout, which
            will cause a rebuild when changed. This is useful when your layout uses a global variable
            because by adding it to a HashCode.Combine here you can easily trigger a build when it changes.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InternalRenderTree">
            <summary>
            Allows building render tree from outside of the class.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnAfterTreeRender(System.Boolean)">
            <summary>
            Called after the razor tree has been created/rendered.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ClearRenderTree">
            <summary>
            Delete all children generated by the Razor render tree.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DrawContent(Sandbox.UI.RenderState@)">
            <summary>
            Called when <see cref="P:Sandbox.UI.Panel.HasContent"/> is set to <see langword="true"/> to custom draw the panels content.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DrawBackground(Sandbox.UI.RenderState@)">
            <summary>
            Called to draw the panels background.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ComputedStyle">
            <summary>
            This is the style that we computed last. If you're looking to see which
            styles are set on this panel then this is what you're looking for.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ActiveStyleBlocks">
            <summary>
            A importance sorted list of style blocks that are active on this panel
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Style">
            <summary>
            Allows you to set styles specifically on this panel. Setting the style will
            only affect this panel and no others and will override any other styles.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.TryFindKeyframe(System.String,Sandbox.UI.KeyFrames@)">
            <summary>
            Try to find <c>@keyframes</c> CSS rule with given name in <see cref="P:Sandbox.UI.Panel.AllStyleSheets"/>.
            </summary>
            <param name="name">The name to search for.</param>
            <param name="keyframes">The keyframes, if any are found, or <see langword="null"/>.</param>
            <returns><see langword="true"/> if <c>@keyframes</c> with given name were found.</returns>
        </member>
        <member name="M:Sandbox.UI.Panel.StyleSelectorsChanged(System.Boolean,System.Boolean,Sandbox.UI.RootPanel)">
            <summary>
            Should be called when something happens that means that this panel's stylesheets need to be
            re-evaluated. Like becoming hovered or classes changed. You don't call this when changing styles
            directly on the panel, just on anything that will change which stylesheets should get selected.
            </summary>
            <param name="ancestors">Also re-evaluate all ancestor panels. (for <c>:has()</c>)</param>
            <param name="descendants">Also re-evaluate all child panels. (for parent selectors)</param>
            <param name="root">Root panel cache so we don't need to keep looking it up.</param>
        </member>
        <member name="M:Sandbox.UI.Panel.OnTemplateSlot(Sandbox.Html.INode,System.String,Sandbox.UI.Panel)">
            <summary>
            TODO: Obsolete this and instead maybe we have something like [PanelSlot( "slotname" )] that 
            is applied on properties. Then when we find a slot="slotname" we chase up the heirachy and set the property.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Tooltip">
            <summary>
            A string to show when hovering over this panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.TooltipClass">
            <summary>
            The created tooltip element will have this class, if set.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasTooltip">
            <summary>
            You should override and return true if you're overriding <see cref="M:Sandbox.UI.Panel.CreateTooltipPanel"/>.
            Otherwise this will return true if <see cref="P:Sandbox.UI.Panel.Tooltip"/> is not empty.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateTooltipPanel">
            <summary>
            Create a tooltip panel. You can override this to create a custom tooltip panel.<br/>
            If you're overriding this and not setting <see cref="P:Sandbox.UI.Panel.Tooltip"/>, then you must override and return true in <see cref="P:Sandbox.UI.Panel.HasTooltip"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Transitions">
            <summary>
            Handles the storage, progression and application of CSS transitions.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasActiveTransitions">
            <summary>
            Returns true if this panel has any active CSS transitions.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SkipTransitions">
            <summary>
            Any transitions running, or about to run, will jump straight to the end.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.UserData">
            <summary>
            Can be used to store random data without sub-classing the panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.DeletionToken">
            <summary>
            Get a token that is cancelled when the panel is deleted
            </summary>
        </member>
        <member name="T:Sandbox.UI.Box">
            <summary>
            Represents position and size of a <see cref="T:Sandbox.UI.Panel"/> on the screen.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.RectOuter">
            <summary>
            Position and size of the element on the screen, <b>including both - its padding AND margin</b>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.RectInner">
            <summary>
            Position and size of only the element's inner content on the screen, <i>without padding OR margin</i>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.Padding">
            <summary>
            The size of padding.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.Border">
            <summary>
            The size of border.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.Margin">
            <summary>
            The size of border.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.Rect">
            <summary>
            Position and size of the element on the screen, <b>including its padding</b>, <i>but not margin</i>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Box.ClipRect">
            <summary>
            <see cref="F:Sandbox.UI.Box.Rect"/> minus the border sizes.
            Used internally to "clip" (hide) everything outside of these bounds, if the panels <see cref="T:Sandbox.UI.OverflowMode"/> is not set to <see cref="F:Sandbox.UI.OverflowMode.Visible"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Box.Left">
            <summary>
            Position of the left edge in screen coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Box.Right">
            <summary>
            Position of the right edge in screen coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Box.Top">
            <summary>
            Position of the top edge in screen coordinates.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Box.Bottom">
            <summary>
            Position of the bottom edge in screen coordinates.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.ParseStyles(Sandbox.Parse@,Sandbox.UI.Styles,System.Boolean)">
            <summary>
            Parse the styles as you would if they were passed in an style="width: 100px" attribute
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.Selector(System.String,Sandbox.UI.StyleBlock)">
            <summary>
            Here we divide the selectors into groups
            .fucker, .cocks, .hairy
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.ParseSingleSelector(System.String,Sandbox.UI.StyleBlock)">
            <summary>
            Parse a single rule, which as "panel.closed.error:hover"
            </summary>
            <returns></returns>
        </member>
        <member name="F:Sandbox.UI.PanelRenderer.Scissor">
            <summary>
            Software scissor, panels outside of this should not be rendered
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelRenderer.ScissorGPU">
            <summary>
            Scissor passed to gpu shader to be transformed
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.ShouldEarlyCull(Sandbox.UI.Panel)">
            <summary>
            Quick check to see if a panel should be culled based on the current scissor
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.Render(Sandbox.UI.Panel,Sandbox.UI.RenderState)">
            <summary>
            Render a panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.PopLayer(Sandbox.RenderTarget)">
            <returns>Will return <c>false</c> if we're at the top of the layer stack.</returns>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.DrawBoxShadows(Sandbox.UI.Panel,Sandbox.UI.RenderState@,System.Boolean)">
            <summary>
            Draw the outset box shadows - this is called *before* drawing the background
            </summary>
        </member>
        <member name="T:Sandbox.UI.RootPanel">
            <summary>
            A root panel. Serves as a container for other panels, handles things such as rendering.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.PanelBounds">
            <summary>
            Bounds of the panel, i.e. its size and position on the screen.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.ChildrenWantMouseInput">
            <summary>
            If any of our panels are visible and want mouse input (pointer-events != none) then
            this will be set to true.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.Scale">
            <summary>
            The scale of this panel and its children.
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.RenderedManually">
            <summary>
            If set to true this panel won't be rendered to the screen like a normal panel.
            This is true when the panel is drawn via other means (like as a world panel).
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.IsWorldPanel">
            <summary>
            True if this is a world panel, so should be skipped when determining cursor visibility etc
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.IsVR">
            <summary>
            If this panel belongs to a VR overlay
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.IsHighQualityVR">
            <summary>
            If this panel should be rendered with ~4K resolution.
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.Layout">
            <summary>
            This is called from tests to emulate the regular root panel simulate loop
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.UpdateBounds(Sandbox.Rect)">
            <summary>
            Called before layout to lock the bounds of this root panel to the screen size (which is passed).
            Internally this sets PanelBounds to rect and calls UpdateScale.
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.UpdateScale(Sandbox.Rect)">
            <summary>
            Work out scaling here. Default is to scale relative to the screen being
            1920 wide. ie - scale = screensize.Width / 1920.0f;
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.RenderManual(System.Single)">
            <summary>
            Render this panel manually. This gives more flexibility to where UI is rendered, to texture for example.
            <see cref="P:Sandbox.UI.RootPanel.RenderedManually"/> must be set to true.
            </summary>
        </member>
        <member name="F:Sandbox.UI.RootPanel.styleRuleUpdates">
            <summary>
            A list of panels that are waiting to have their styles re-evaluated
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.AddToBuildStyleRulesList(Sandbox.UI.Panel)">
            <summary>
            Add this panel to a list to have their styles re-evaluated. This should be done any
            time the panel changes in a way that could affect its style selector.. like if its child
            index changed, or classes added or removed, or became hovered etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.BuildStyleRules">
            <summary>
            Run through all panels that are pending a re-check on their style rules.
            Only properly invalidate them if their rules actually change.
            </summary>
        </member>
        <member name="T:Sandbox.UI.IStyleTarget">
            <summary>
            Everything the style system needs to work out a style
            </summary>
        </member>
        <member name="T:Sandbox.UI.StyleBlock">
            <summary>
            A CSS rule - ie ".chin { width: 100%; height: 100%; }"
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.Selectors">
            <summary>
            A list of appropriate selectors for this block (ie ".button")
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.SelectorStrings">
            <summary>
            A list of selectors for this block
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleBlock.GetRawValues">
            <summary>
            Get the list of raw style values
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleBlock.SetRawValue(System.String,System.String,System.String)">
            <summary>
            Update a raw style value
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.FileName">
            <summary>
            The filename of the file containing this style block (or null if none)
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.AbsolutePath">
            <summary>
            The absolute on disk filename for this style block (or null if not on disk)
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleBlock.FileLine">
            <summary>
            The line in the file containing this style block
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleBlock.Styles">
            <summary>
            The styles that are defined in this block
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleBlock.TestBroadphase(Sandbox.UI.IStyleTarget)">
            <summary>
            Tests a few broadphase conditions to build a list of feasible
            styleblocks tailored for a panel.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Styles">
            <summary>
            Represents all supported CSS properties and their currently assigned values.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Styles.HasTransitions">
            <summary>
            Whether this style sheet has any transitions that would need to be run.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Styles.Transitions">
            <summary>
            List of transitions this style sheet has.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Styles.BuildTransformMatrix(Vector2)">
            <summary>
            Creates a matrix based on this style's "transform" and other related properties
            </summary>
        </member>
        <member name="M:Sandbox.UI.Styles.MarkPanelsDirty">
            <summary>
            Try to find all panels using this style and mark them dirty so they'll
            redraw with the style. This should be called when the style is changed. Which
            is only technically when done via the editor.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Styles.SetImage(System.String,System.Func{System.Lazy{Sandbox.Texture},System.Boolean},System.Func{System.String,System.Boolean},System.Func{System.String,System.Boolean},System.Func{System.Single,System.Boolean})">
            <param name="value"></param>
            <param name="setImage">Optional</param>
            <param name="setSize">Optional</param>
            <param name="setRepeat">Optional</param>
            <param name="setAngle">Optional</param>
        </member>
        <member name="T:Sandbox.UI.StyleSelector">
            <summary>
            A CSS selector like "Panel.button.red:hover .text"
            </summary>
        </member>
        <member name="P:Sandbox.UI.StyleSelector.Id">
            <summary>
            The Id selector - minus the #
            https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleSelector.Parent">
            <summary>
            Descendant combinator
            A B
            Child combinator
            A > B
            Adjacent sibling combinator
            A + B
            General sibling combinator
            A ~B
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleSelector.UniversalSelector">
            <summary>
            True if this has a universal selector (*)
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheet.InitStyleSheets">
            <summary>
            Between sessions we clear the stylesheets, so one gamemode can't accidentally
            use cached values from another.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheet.Release">
            <summary>
            Releases the filesystem watcher so we won't get file changed events.
            </summary>
        </member>
        <member name="T:Sandbox.UI.StyleSheetCollection">
            <summary>
            A collection of <see cref="T:Sandbox.UI.StyleSheet"/> objects applied directly to a panel.
            See <see cref="F:Sandbox.UI.Panel.StyleSheet"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Add(Sandbox.UI.StyleSheet)">
            <summary>
            Add a stylesheet directly
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Load(System.String,System.Boolean)">
            <summary>
            Load the stylesheet from a file.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Parse(System.String,System.Boolean)">
            <summary>
            Load the stylesheet from a string.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Remove(Sandbox.UI.StyleSheet)">
            <summary>
            Remove a specific <see cref="T:Sandbox.UI.StyleSheet"/> from the collection.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Remove(System.String)">
            <summary>
            Remove all stylesheets whose filename matches this wildcard glob.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.CollectVariables">
            <summary>
            Returns all CSS variables from the owning panel and its ancestors.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Transitions">
            <summary>
            Handles the storage, progression and application of CSS transitions for a single <see cref="T:Sandbox.UI.Panel"/>.
            </summary>
        </member>
        <member name="F:Sandbox.UI.Transitions.Entries">
            <summary>
            Active CSS transitions.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Transitions.HasAny">
            <summary>
            Whether there are any active CSS transitions.
            </summary>
        </member>
        <member name="T:Sandbox.UI.Emoji">
            <summary>
            Helper class for working with Unicode emoji.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Emoji.FindEmoji(System.String)">
            <summary>
            Find a Unicode emoji from a <c>:emoji_name:</c> format.
            </summary>
            <param name="lookup">Input emoji text in <c>:emoji_name:</c> format.</param>
            <returns>The emoji or <see langword="null"/>.</returns>
        </member>
        <member name="T:Sandbox.UI.ImageRect">
            <summary>
            We share a lot of code between mask-image and background-image - so this handles all image rect calculations.
            </summary>
        </member>
        <member name="T:Sandbox.UI.WorldPanel">
            <summary>
            An interactive 2D panel rendered in the 3D world.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.SceneObject">
            <summary>
            Scene object that renders the panel.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.Transform">
            <summary>
            Transform of the world panel in 3D space.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.Tags">
            <summary>
            Tags that are applied to the underlying SceneObject
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.Position">
            <summary>
            Position of the world panel in 3D space.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.Rotation">
            <summary>
            Rotation of the world panel in 3D space.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.WorldScale">
            <summary>
            Scale of the world panel in 3D space.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldPanel.MaxInteractionDistance">
            <summary>
            Maximum distance at which a player can interact with this world panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.WorldPanel.UpdateBounds(Sandbox.Rect)">
            <summary>
            Update the bounds for this panel. We purposely do nothing here because
            on world panels you can change the bounds by setting <see cref="P:Sandbox.UI.RootPanel.PanelBounds"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.WorldPanel.UpdateScale(Sandbox.Rect)">
            <summary>
            We override this to prevent the scale automatically being set based on screen
            size changing.. because that's obviously not needed here.
            </summary>
        </member>
        <member name="T:Sandbox.Razor.RenderFragment">
            <summary>
            Represents a segment of UI content, implemented as a delegate that
            writes the content to a <see cref="T:Sandbox.Razor.RenderTreeBuilder"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Razor.RenderFragment`1">
            <summary>
            Represents a segment of UI content for an object of type <typeparamref name="TValue"/>, implemented as
            a function that returns a <see cref="T:Sandbox.Razor.RenderFragment"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Razor.RenderTreeBuilder">
            <summary>
            This is a tree renderer for panels. If we ever use razor on other ui we'll want to make a copy of
            this class and do the specific things to that.
            </summary>
            <summary>
            This is a tree renderer for panels. If we ever use razor on other ui we'll want to make a copy of
            this class and do the specific things to that.
            </summary>
            <summary>
            This is a tree renderer for panels. If we ever use razor on other ui we'll want to make a copy of 
            this class and do the specific things to that.
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.Block.Reset">
            <summary>
            Reset to an unseen, unlooped state
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.Block.CheckCacheValue(System.Int32,System.Int32)">
            <summary>
            Allows caching a block so you can avoid repeating unnecessary steps. 
            Calling this will return true if it's already cached, false if it's not.
            If it's not it'll add to the cache so that next time it will return true.
            </summary>
        </member>
        <member name="F:Sandbox.Razor.RenderTreeBuilder.Block.increments">
            <summary>
            For loops, how many times has this been seen
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.Start">
            <summary>
            Called once before building the tree
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.Finish">
            <summary>
            Called once after building the tree
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddLocation(System.String,System.Int32,System.Int32)">
            <summary>
            Add the current source location. Used to record in which file the element was created.
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.OpenElement(System.Int32,System.String)">
            <summary>
            Start working on this element
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Object)">
            <summary>
            Handles "style" and "class" attributes..
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddStyleDefinitions(System.Int32,System.String)">
            <summary>
            Styles from a style block
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddAttribute``1(System.Int32,System.Action{``0})">
            <summary>
             <![CDATA[ <Icon OnSomething=@Function></Icon> ]]>
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.CloseElement">
            <summary>
            Finish working on this element
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddContent``1(System.Int32,``0)">
            <summary>
            Handles text content within an element
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.Clear">
            <summary>
            Delete all of the elements created by this render tree
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddReferenceCapture``1(System.Int32,``0,System.Action{``0})">
            <summary>
            Implements @ref
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Action)">
            <summary>
            Handles @onclick=@( () => DoSomething( "boobies" ) )
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Handles @onclick=@( () => await DoSomethingAsync( "boobies" ) )
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Action{Sandbox.UI.PanelEvent})">
            <summary>
            Handles @onclick=@( ( PanelEvent e ) => DoSomething( e.This, "boobies" ) )
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddMarkupContent(System.Int32,System.String)">
            <summary>
            Add markup to the current element
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.OpenElement``1(System.Int32)">
            <summary>
            Create a panel of type T
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddAttribute``1(System.Int32,System.Object,System.Action{``0})">
            <summary>
            Called to set attributes on a panel directly
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.AddBind``1(System.Int32,System.String,System.Func{``0},System.Action{``0})">
            <summary>
            Called to set attributes on a panel directly
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RenderTreeBuilder.UpdateBinds">
            <summary>
            Update bound variables and return true if any of them changed
            </summary>
        </member>
        <member name="P:Sandbox.Razor.RouteAttribute.Url">
            <summary>
            The full url of this route (ie "/home/section/page")
            </summary>
        </member>
        <member name="P:Sandbox.Razor.RouteAttribute.Parts">
            <summary>
            The url split into parts (ie "home" "section" "page" )
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RouteAttribute.FindValidTarget(System.String,System.String)">
            <summary>
            Given a URL, check out TypeLibrary and find a valid target
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RouteAttribute.IsUrl(System.String)">
            <summary>
            True if this matches the passed in url.
            Queries are trimmed and ignored <c>( ?query=fff )</c>
            Variables are tested (but not type matched or anything)
            </summary>
        </member>
        <member name="M:Sandbox.Razor.RouteAttribute.ExtractProperties(System.String)">
            <summary>
            Given a Url, check for {properties} and convert them to key values
            </summary>
        </member>
        <member name="M:Sandbox.UISystem.AddDeferredDeletion(Sandbox.UI.Panel)">
            <summary>
            This panel should get deleted at some point
            </summary>
        </member>
        <member name="M:Sandbox.UISystem.RunDeferredDeletion(System.Boolean)">
            <summary>
            Delete all panels that were deferred and are no longer playing outro transitions
            </summary>
        </member>
        <member name="T:Sandbox.ScenePanelObject">
            <summary>
            Renders a panel in a scene world. You are probably looking for <a href="https://sbox.game/api/Sandbox.UI.WorldPanel">WorldPanel</a>.
            </summary>
        </member>
        <member name="F:Sandbox.ScenePanelObject.ScreenToWorldScale">
            <summary>
            Global scale for panel rendering within a scene world.
            </summary>
        </member>
        <member name="P:Sandbox.ScenePanelObject.Panel">
            <summary>
            The panel that will be rendered.
            </summary>
        </member>
        <member name="T:Sandbox.ColorGradient">
            <summary>
            A color gradient for use as entity and asset properties
            TODO: Gradient property editor
            </summary>
        </member>
        <member name="P:Sandbox.ColorGradient.IsValid">
            <summary>
            Whether the curve was loaded correctly or not
            </summary>
        </member>
        <member name="T:Sandbox.DamageInfo">
            <summary>
            Describes the damage that should be done to something. This is purposefully a class
            so it can be derived from, allowing games to create their own special types of damage, while
            not having to create a whole new system.
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Attacker">
            <summary>
            Usually a player or Npc
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Weapon">
            <summary>
            The weapon that did the damage, or a vehicle etc
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Hitbox">
            <summary>
            The hitbox that we hit (if any)
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.IsExplosion">
            <summary>
            True if this is explosive damage
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Damage">
            <summary>
            Amount of damage this should do
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Position">
            <summary>
            The location of the damage
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Shape">
            <summary>
            The physics shape that we hit (if any)
            </summary>
        </member>
        <member name="T:Sandbox.Utility.EditorTools">
            <summary>
            Functions to interact with the tools system. Does nothing if tools aren't enabled.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.EditorTools.InspectorObject">
            <summary>
            Set the object to be inspected by the inspector in the editor
            </summary>
        </member>
        <member name="P:Sandbox.Utility.ProjectSettings.CollisionRules">
            <summary>
            Get the <see cref="P:Sandbox.Utility.ProjectSettings.CollisionRules"/> from the active project settings.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.ProjectSettings.LoadCollisionRules">
            <summary>
            Load or reload the <see cref="P:Sandbox.Utility.ProjectSettings.CollisionRules"/> from the active project settings.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.ProjectSettings.LoadMixerSettings">
            <summary>
            Load or reload the <see cref="T:Sandbox.Audio.MixerSettings"/> from the active project settings.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.ProjectSettings.LoadCursors">
            <summary>
            Load or reload the <see cref="T:Sandbox.CursorSettings"/> from the active project settings.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.ProjectSettings.Reset">
            <summary>
            Reset any stored references to Project Settings.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.ProjectSettings.ReadWithFallback``1(System.String,Sandbox.Package,System.String)">
            <summary>
            One day it'd be nice to get rid of this. Maybe on package load we extract the old stuff from the meta?
            </summary>
        </member>
        <member name="M:Sandbox.Utility.ProjectSettings.Read``1(System.String)">
            <summary>
            Read a config file
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.PathFillType">
            <summary>
            How to determine which sections of the path are filled.
            </summary>
        </member>
        <member name="F:Sandbox.Utility.Svg.PathFillType.Winding">
            <summary>
            Clockwise paths are filled, counter-clockwise are empty.
            </summary>
        </member>
        <member name="F:Sandbox.Utility.Svg.PathFillType.EvenOdd">
            <summary>
            Regions that are enclosed by an odd number of paths are filled, other regions are empty.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.PathArcSize">
            <summary>
            Controls arc size in <see cref="T:Sandbox.Utility.Svg.ArcToPathCommand"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.PathDirection">
            <summary>
            Controls arc direction in <see cref="T:Sandbox.Utility.Svg.ArcToPathCommand"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.PathCommand">
            <summary>
            Base class for SVG path commands.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddCirclePathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddCirclePathCommand.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddOvalPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/ellipse"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddOvalPathCommand.#ctor(Sandbox.Rect)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/ellipse"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddPolyPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline"/>, <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddPolyPathCommand.#ctor(System.Collections.Generic.IReadOnlyList{Vector2},System.Boolean)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline"/>, <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddRectPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddRectPathCommand.#ctor(Sandbox.Rect)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.AddRoundRectPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.AddRoundRectPathCommand.#ctor(Sandbox.Rect,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.ArcToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#arcs"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.ArcToPathCommand.#ctor(System.Single,System.Single,System.Single,Sandbox.Utility.Svg.PathArcSize,Sandbox.Utility.Svg.PathDirection,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#arcs"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.ClosePathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.CubicToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.CubicToPathCommand.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.LineToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.LineToPathCommand.#ctor(System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.MoveToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.MoveToPathCommand.#ctor(System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.QuadToPathCommand">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.QuadToPathCommand.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves"/>.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.SvgPath">
            <summary>
            A shape in a <see cref="T:Sandbox.Utility.Svg.SvgDocument"/>, described as a vector path.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.FillType">
            <summary>
            How to determine which sections of the path are filled.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.Commands">
            <summary>
            Description of how the path is constructed out of basic elements.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.IsEmpty">
            <summary>
            If true, this path has no commands.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.Bounds">
            <summary>
            Enclosing bounding box for this path.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.StrokeColor">
            <summary>
            Optional outline color for this path.
            </summary>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgPath.FillColor">
            <summary>
            Optional fill color for this path.
            </summary>
        </member>
        <member name="T:Sandbox.Utility.Svg.SvgDocument">
            <summary>
            Helper class for reading Scalable Vector Graphics files.
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Svg.SvgDocument.FromString(System.String)">
            <summary>
            Reads an SVG document from the given string, returning a list of path elements
            describing the shapes in the image.
            </summary>
            <param name="contents">SVG document contents.</param>
        </member>
        <member name="P:Sandbox.Utility.Svg.SvgDocument.Paths">
            <summary>
            List of all shapes in the document.
            </summary>
        </member>
        <member name="T:Sandbox.FGDCurve">
            <summary>
            A helper class to handle 'curve' FGD type.
            TOOD: Get rid of in favor of new curve stuff.
            </summary>
        </member>
        <member name="M:Sandbox.FGDCurve.Get(System.Single,System.Boolean)">
            <summary>
            The cubic spline function in ranges as defined in Hammer/Asset editor.
            </summary>
        </member>
        <member name="M:Sandbox.FGDCurve.GetNormalized(System.Single,System.Boolean)">
            <summary>
            The cubic spline function normalized to ranges [0,1] on both input and output.
            </summary>
        </member>
        <member name="P:Sandbox.FGDCurve.Mins">
            <summary>
            The bottom left corner of the curve. Mins and Maxs represent the range of inputs and outputs of the curve function.
            </summary>
        </member>
        <member name="P:Sandbox.FGDCurve.Maxs">
            <summary>
            The top right corner of the curve. Mins and Maxs represent the range of inputs and outputs of the curve function.
            </summary>
        </member>
        <member name="P:Sandbox.FGDCurve.IsValid">
            <summary>
            Whether the curve was loaded correctly or not
            </summary>
        </member>
        <member name="T:Sandbox.Language">
            <summary>
            Allows access to translated phrases, allowing the translation of gamemodes etc
            </summary>
        </member>
        <member name="P:Sandbox.Language.SelectedCode">
            <summary>
            The abbreviation for the language the user wants. This is set by the user in the options menu.
            </summary>
        </member>
        <member name="P:Sandbox.Language.Current">
            <summary>
            Information about the current selected language. Will default to English if the current language isn't found.
            </summary>
        </member>
        <member name="M:Sandbox.Language.OnFileChanged">
            <summary>
            Called when a localization file has changed (and we should reload)
            </summary>
        </member>
        <member name="M:Sandbox.Language.GetPhrase(System.String)">
            <summary>
            Lookup a phrase
            </summary>
            <param name="textToken">The token used to identify the phrase</param>
            <returns>If found will return the phrase, else will return the token itself</returns>
        </member>
        <member name="M:Sandbox.Language.GetPhrase(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Look up a phrase
            </summary>
            <param name="textToken">The token used to identify the phrase</param>
            <param name="data">Key values of data used by the string. Example: {Variable} -> { "Variable", someVar }</param>
            <returns>If found will return the phrase, else will return the token itself</returns>
        </member>
        <member name="T:Sandbox.Mouse">
            <summary>
            Gives access to mouse position etc
            </summary>
        </member>
        <member name="M:Sandbox.Mouse.Frame">
            <summary>
            Called once per frame
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.Position">
            <summary>
            Access to local clients' cursor position, relative to game windows' top left corner.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.Delta">
            <summary>
            Change in local clients' cursor position since last frame.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.CursorType">
            <summary>
            Sets the cursor type until another panel stomps this value.
            Doesn't affect main menu.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.Active">
            <summary>
            Whether the local clients' cursor is active or not, meaning it can interact with UI elements, etc.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.Visible">
            <summary>
            Whether the local clients' cursor is visible or not.
            </summary>
        </member>
        <member name="P:Sandbox.Mouse.OverridingVisibility">
            <summary>
            Whether the local clients' cursor should be visible (overriding pointer-events: none).
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Username">
            <summary>
            Your own username
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.UserId">
            <summary>
            Your own user id
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Service">
            <summary>
            The service type (ie "Twitch")
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.IsActive">
            <summary>
            Are we connected to a service
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.GetUser(System.String)">
            <summary>
            Get user information. If no username is specified, the user returned is ourself
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.GetUserFollowing(System.String)">
            <summary>
            Get user following "Who is X following"
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.GetUserFollowers(System.String)">
            <summary>
            Get user followers "Who is following X"
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.CreatePoll(System.String,System.String,System.Int32,System.String[])">
            <summary>
            Start a poll with choices, save the poll id so you can end it later on
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.EndPoll(System.String,System.String,System.Boolean)">
            <summary>
            End a poll using a saved poll id, you can optionally archive the poll or just terminate it
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.CreatePrediction(System.String,System.String,System.Int32,System.String,System.String)">
            <summary>
            Create a prediction to bet with channel points
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.LockPrediction(System.String,System.String)">
            <summary>
            Lock a current prediction with prediction id
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.CancelPrediction(System.String,System.String)">
            <summary>
            Cancel a current prediction with prediction id
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.ResolvePrediction(System.String,System.String,System.String)">
            <summary>
            Resolve a current prediction with prediction id and choose winning outcome to pay out channel points
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.SendMessage(System.String)">
            <summary>
            Send a message to chat, optionally specify channel you want to send the message, otherwise it is sent to your own chat
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.ClearChat">
            <summary>
            Clear your own chat
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.BanUser(System.String,System.String,System.Int32)">
            <summary>
            Ban user from your chat by username, the user will no longer be able to chat.
            Optionally specify the duration, a duration of zero means perm ban
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.UnbanUser(System.String)">
            <summary>
            Unban user from your chat by username
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Game">
            <summary>
            Set the game you're playing by game id
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Language">
            <summary>
            Set the language of your stream
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Title">
            <summary>
            Set the title of your stream
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Delay">
            <summary>
            Set the delay of your stream
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.ViewerCount">
            <summary>
            Amount of concurrent viewer your stream has.
            </summary>
        </member>
        <member name="T:Sandbox.GameTask">
            <summary>
            A generic <see cref="T:Sandbox.TaskSource"/>.
            </summary>
        </member>
        <member name="M:Sandbox.GameTask.Yield">
            <inheritdoc cref="M:Sandbox.TaskSource.Yield"/>
        </member>
        <member name="M:Sandbox.GameTask.Delay(System.Int32)">
            <inheritdoc cref="M:Sandbox.TaskSource.Delay(System.Int32)"/>
        </member>
        <member name="M:Sandbox.GameTask.Delay(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.Delay(System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelaySeconds(System.Single)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelaySeconds(System.Single)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelaySeconds(System.Single,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelaySeconds(System.Single,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelayRealtime(System.Int32)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtime(System.Int32)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelayRealtime(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtime(System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelayRealtimeSeconds(System.Single)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtimeSeconds(System.Single)"/>
        </member>
        <member name="M:Sandbox.GameTask.DelayRealtimeSeconds(System.Single,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtimeSeconds(System.Single,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sandbox.GameTask.RunInThreadAsync(System.Action)">
            <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync(System.Action)"/>
        </member>
        <member name="M:Sandbox.GameTask.RunInThreadAsync``1(System.Func{``0})">
            <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync``1(System.Func{``0})"/>
        </member>
        <member name="M:Sandbox.GameTask.RunInThreadAsync(System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync(System.Func{System.Threading.Tasks.Task})"/>
        </member>
        <member name="M:Sandbox.GameTask.RunInThreadAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync``1(System.Func{System.Threading.Tasks.Task{``0}})"/>
        </member>
        <member name="P:Sandbox.GameTask.CompletedTask">
            <inheritdoc cref="P:Sandbox.TaskSource.CompletedTask"/>
        </member>
        <member name="M:Sandbox.GameTask.FromResult``1(``0)">
            <inheritdoc cref="M:Sandbox.TaskSource.FromResult``1(``0)"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAll(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAll(System.Threading.Tasks.Task[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAll``1(System.Threading.Tasks.Task{``0}[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAny(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAny(System.Threading.Tasks.Task[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAny``1(System.Threading.Tasks.Task{``0}[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:Sandbox.TaskSource.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})"/>
        </member>
        <member name="M:Sandbox.GameTask.WaitAll(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WaitAll(System.Threading.Tasks.Task[])"/>
        </member>
        <member name="M:Sandbox.GameTask.WaitAny(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:Sandbox.TaskSource.WaitAny(System.Threading.Tasks.Task[])"/>
        </member>
        <member name="M:Sandbox.GameTask.MainThread">
            <inheritdoc cref="M:Sandbox.TaskSource.MainThread"/>
        </member>
        <member name="M:Sandbox.GameTask.MainThread(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.MainThread"/>
        </member>
        <member name="M:Sandbox.GameTask.WorkerThread">
            <inheritdoc cref="M:Sandbox.TaskSource.WorkerThread"/>
        </member>
        <member name="M:Sandbox.GameTask.WorkerThread(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sandbox.TaskSource.WorkerThread"/>
        </member>
        <member name="T:Sandbox.TaskSource">
            <summary>
            Provides a way for us to cancel tasks after common async shit is executed.
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.CreateLinkedTokenSource">
            <summary>
            Create a token source, which will also be cancelled when sessions end
            </summary>
        </member>
        <member name="P:Sandbox.TaskSource.IsValid">
            <inheritdoc cref="P:Sandbox.IValid.IsValid"/>
        </member>
        <member name="M:Sandbox.TaskSource.Expire">
            <summary>
            Marks this task source as invalid. All associated running tasks will be canceled ASAP.
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.Delay(System.Int32)">
            <summary>
            A task that does nothing for given amount of time in milliseconds.
            </summary>
            <param name="ms">Time to wait in milliseconds.</param>
        </member>
        <member name="M:Sandbox.TaskSource.Delay(System.Int32,System.Threading.CancellationToken)">
            <summary>
            A task that does nothing for given amount of time in milliseconds.
            </summary>
            <param name="ms">Time to wait in milliseconds.</param>
            <param name="ct">Token to cancel the delay early.</param>
        </member>
        <member name="M:Sandbox.TaskSource.DelaySeconds(System.Single)">
            <summary>
            A task that does nothing for given amount of time in seconds.
            </summary>
            <param name="seconds">>Time to wait in seconds.</param>
        </member>
        <member name="M:Sandbox.TaskSource.DelaySeconds(System.Single,System.Threading.CancellationToken)">
            <summary>
            A task that does nothing for given amount of time in seconds.
            </summary>
            <param name="seconds">>Time to wait in seconds.</param>
            <param name="ct">Token to cancel the delay early.</param>
        </member>
        <member name="M:Sandbox.TaskSource.MainThread">
            <summary>
            Continues on the main thread.
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.WorkerThread">
            <summary>
            Continues on a worker thread.
            </summary>
        </member>
        <member name="P:Sandbox.TaskSource.CompletedTask">
            <inheritdoc cref="P:System.Threading.Tasks.Task.CompletedTask" />
        </member>
        <member name="M:Sandbox.TaskSource.FromResult``1(``0)">
            <inheritdoc cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
        </member>
        <member name="M:Sandbox.TaskSource.FromCanceled(System.Threading.CancellationToken)">
            <inheritdoc cref="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
        </member>
        <member name="M:Sandbox.TaskSource.FromException(System.Exception)">
            <inheritdoc cref="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAll(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAny(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
        </member>
        <member name="M:Sandbox.TaskSource.WaitAny(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WaitAll(System.Threading.Tasks.Task[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
        </member>
        <member name="M:Sandbox.TaskSource.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
        </member>
        <member name="M:Sandbox.TaskSource.Yield">
            <inheritdoc cref="M:System.Threading.Tasks.Task.Yield" />
        </member>
        <member name="M:Sandbox.TaskSource.Frame">
            <summary>
            Wait until the start of the next frame
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.FrameEnd">
            <summary>
            Wait until the end of the frame
            </summary>
        </member>
        <member name="M:Sandbox.TaskSource.FixedUpdate">
            <summary>
            Wait until the next fixed update
            </summary>
        </member>
        <member name="T:Sandbox.Http">
            <summary>
            Lets your game make async HTTP requests.
            </summary>
        </member>
        <member name="M:Sandbox.Http.IsAllowed(System.Uri)">
            <summary>
            Check if the given Uri matches the following requirements:
            1. Scheme is https/http or wss/ws
            2. If it's localhost, only allow ports 80/443/8080/8443
            3. Not an ip address
            </summary>
            <param name="uri">The Uri to check.</param>
            <returns>True if the Uri can be accessed, false if the Uri will be blocked.</returns>
        </member>
        <member name="M:Sandbox.Http.IsHeaderAllowed(System.String)">
            <summary>
            Checks if a given header is allowed to be set.
            </summary>
            <param name="header">The header name to check.</param>
            <returns>True if the header is allowed to be set.</returns>
        </member>
        <member name="M:Sandbox.Http.RequestStringAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Send a HTTP request to the specified URI and return the response body as a string in an asynchronous operation.
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to the response body as a string.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.RequestBytesAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Send a HTTP request to the specified URI and return the response body as a byte array in an asynchronous operation.
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to the response body as a byte array.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.RequestStreamAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Send a HTTP request to the specified URI and return the response body as a stream in an asynchronous operation.
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to the response body as a <see cref="T:System.IO.Stream"/>.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.RequestJsonAsync``1(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Sends a HTTP request to the specified URI and return the response body as a JSON deserialized object in an asynchronous operation.
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to the response body deserialized from JSON.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.RequestAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Sends a HTTP request to the specified URI and returns the response in an asynchronous operation. 
            </summary>
            <param name="requestUri">The URI to request.</param>
            <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
            <param name="content">The content to include within the request, or null if none should be sent.</param>
            <param name="headers">Headers to add to the request, or null if none should be added.</param>
            <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
            <returns>An asynchronous task which resolves to a <see cref="T:System.Net.Http.HttpResponseMessage"/> containing the response for the request.</returns>
            <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
            <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
        </member>
        <member name="M:Sandbox.Http.CreateJsonContent``1(``0)">
            <summary>
            Creates a new <see cref="T:System.Net.Http.HttpContent"/> instance containing the specified object serialized to JSON.
            </summary>
        </member>
        <member name="T:Sandbox.WebSocket">
            <summary>
            A WebSocket client for connecting to external services.
            </summary>
            <remarks>
            Events handlers will be called on the synchronization context that Connect was called on.
            </remarks>
        </member>
        <member name="T:Sandbox.WebSocket.MessageReceivedHandler">
            <summary>
            Event handler which processes text messages from the WebSocket service.
            </summary>
            <param name="message">The message text that was received.</param>
        </member>
        <member name="T:Sandbox.WebSocket.DataReceivedHandler">
            <summary>
            Event handler which processes binary messages from the WebSocket service.
            </summary>
            <param name="data">The binary message data that was received.</param>
        </member>
        <member name="T:Sandbox.WebSocket.DisconnectedHandler">
            <summary>
            Event handler which fires when the WebSocket disconnects from the server.
            </summary>
            <param name="status">The close status code from the server, or 0 if there was none. See known values here: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</param>
            <param name="reason">The reason string for closing the connection. This may not be populated, may be from the server, or may be a client exception message.</param>
        </member>
        <member name="P:Sandbox.WebSocket.IsConnected">
            <summary>
            Returns true as long as a WebSocket connection is established.
            </summary>
        </member>
        <member name="P:Sandbox.WebSocket.SubProtocol">
            <summary>
            Get the sub-protocol that was negotiated during the opening handshake.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnMessageReceived">
            <summary>
            Event which fires when a text message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnDataReceived">
            <summary>
            Event which fires when a binary message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnDisconnected">
            <summary>
            Event which fires when the connection to the WebSocket service is lost, for any reason.
            </summary>
        </member>
        <member name="P:Sandbox.WebSocket.EnableCompression">
            <summary>
            Enable or disable compression for the websocket. If the server supports it, compression will be enabled for all messages.
            Note: compression is disabled by default, and can be dangerous if you are sending secrets across the network.
            </summary>
        </member>
        <member name="M:Sandbox.WebSocket.#ctor(System.Int32)">
            <summary>
            Initialized a new WebSocket client.
            </summary>
            <param name="maxMessageSize">The maximum message size to allow from the server, in bytes. Default 64 KiB.</param>
        </member>
        <member name="M:Sandbox.WebSocket.Dispose">
            <summary>
            Cleans up resources used by the WebSocket client. This will also immediately close the connection if it is currently open.
            </summary>
        </member>
        <member name="M:Sandbox.WebSocket.AddSubProtocol(System.String)">
            <summary>
            Add a sub-protocol to be negotiated during the WebSocket connection handshake.
            </summary>
            <param name="protocol"></param>
        </member>
        <member name="M:Sandbox.WebSocket.Connect(System.String,System.Threading.CancellationToken)">
            <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
            <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
            <param name="ct">A <see cref="T:System.Threading.CancellationToken"/> which allows the connection attempt to be aborted if necessary.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the connection is established, or throws if it failed to connect.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Connect(System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
            <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
            <param name="headers">Headers to send with the connection request.</param>
            <param name="ct">A <see cref="T:System.Threading.CancellationToken"/> which allows the connection attempt to be aborted if necessary.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the connection is established, or throws if it failed to connect.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.String)">
            <summary>
            Sends a text message to the WebSocket server.
            </summary>
            <param name="message">The message text to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.Byte[])">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <remarks>
            The <see cref="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})"/> and <see cref="M:Sandbox.WebSocket.Send(System.Span{System.Byte})"/> overloads allow sending subsections of byte arrays.
            </remarks>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.Span{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
    </members>
</doc>
